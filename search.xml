<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DDD：领域、子域、限界上下文</title>
      <link href="/shi-xian-ling-yu-qu-dong-she-ji-ling-yu-zi-yu-xian-jie-shang-xia-wen.html"/>
      <url>/shi-xian-ling-yu-qu-dong-she-ji-ling-yu-zi-yu-xian-jie-shang-xia-wen.html</url>
      
        <content type="html"><![CDATA[<h2 id="领域、子域、限界上下文"><a href="#领域、子域、限界上下文" class="headerlink" title="领域、子域、限界上下文"></a>领域、子域、限界上下文</h2><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><ul><li>理解领域、子域和限界上下文等概念</li><li>理解问题空间和解决方案的概念</li><li>理解战略设计的重要性</li></ul><h3 id="重要点总结："><a href="#重要点总结：" class="headerlink" title="重要点总结："></a>重要点总结：</h3><h4 id="领域："><a href="#领域：" class="headerlink" title="领域："></a>领域：</h4><ol><li><p>从广义上讲，<strong>领域（Domain）</strong>即是一个组织所做的事情以及其中包含的一切，当你为某个组织开发软件时，你面对的便是这个组织的领域。</p></li><li><p>在DDD中一个领域被划分为若干子域，子域可以划分为<strong>核心域</strong>、<strong>支撑子域</strong>、<strong>通用子域。</strong></p></li><li><p>最好的情况下，<strong>一个子域对应一个限界上下文。</strong></p></li><li><p><strong>核心域</strong>是业务成功的主要促成因素，我们应该给予核心域最高的优先级，主要关注与此。</p></li><li><p>有时我们会创建或者购买某个限界上下文来<strong>支撑我们的业务</strong>，如果这样的限界上下文对应着业务的某些重要方面，但不是核心，那么它便是一个<strong>支撑子域</strong>。</p></li><li><p>如果子域被用于<strong>整个</strong>业务系统，那么这个子域便是<strong>通用子域</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD1.1.png" alt="领域划分"></p></li></ol><h4 id="问题空间和解决方案空间"><a href="#问题空间和解决方案空间" class="headerlink" title="问题空间和解决方案空间"></a>问题空间和解决方案空间</h4><ol><li><p>领域中还同时存在问题空间（problem space）和解决方案空间（solution space）。</p></li><li><p><strong>问题空间</strong>是核心域和其它子域的组合，问题空间是领域的一部分，对问题空间的开发将产生一个新的核心域。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD3.png" alt="问题空间"></p></li><li><p><strong>解决方案空间</strong>包括一个或多个限界上下文，即一组特定的<strong>软件模型</strong>，限界上下文即是一个特定的解决方案。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD4.png" alt="解决方案空间"></p></li></ol><h4 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h4><ol><li><p><strong>限界上下文是一个显式的边界，领域模型便存在于这个边界之内。在边界内通用语言中的所有术语和词组都有特定的含义，而模型需要准确地反映通用语言。</strong></p></li><li><p>不要试图去创建一个<strong>“大而全”</strong>的软件模型，导致每个概念在全局范围内只有一种定义，这是一个陷阱。最好的方法是正视这种不同，然后用限界上下文对领域模型进行分离。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD5.png" alt="一个拥有清晰子域的示例上下文"></p><h4 id="关于领域（Domain）、领域模型（Domain-Model）、边界上下文（Bounded-Context）的关系"><a href="#关于领域（Domain）、领域模型（Domain-Model）、边界上下文（Bounded-Context）的关系" class="headerlink" title="关于领域（Domain）、领域模型（Domain Model）、边界上下文（Bounded Context）的关系"></a>关于领域（Domain）、领域模型（Domain Model）、边界上下文（Bounded Context）的关系</h4><ul><li>领域就是问题域，问题空间；</li><li>领域模型是一种模型，表达了领域中哪些业务需求以及业务规则必须被满足；</li><li>每一个领域中的问题，都会有一个对应的领域模型去解决；</li><li>Bounded Context的作用是用来对领域模型进行划分；</li><li>划分领域就是对问题空间的划分，通俗的理解，就是将大问题拆分为小问题；</li><li>划分Bounded Context就是将一个大的领域模型划分为多个小的领域模型；</li><li>可以把Bounded Context看成是一种解决方案空间，所以，Bounded Context也可以理解为是对解决方案空间的划分；</li><li>理论上，一个Domain可能会对应多个Bounded Context；同样，一个Bounded Context可能也会对应多个Domain；所以他们之间没有绝对的关系。主要是他们划分的依据不同，一个是针对领域（问题空间），一个是针对领域模型（解决方案空间）；<strong>理想情况，一个Domain最好对应一个Bounded Context；</strong></li></ul><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD6.png" alt="关系"></p><h4 id="战略设计脑图："><a href="#战略设计脑图：" class="headerlink" title="战略设计脑图："></a>战略设计脑图：</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A11.png" alt="一个拥有清晰子域的示例上下文"></p></li></ol><p><strong>最后引用《领域驱动设计》中的一段描述：</strong></p><blockquote><p><strong>细胞膜不仅能把细胞内部和外部区分开来，而且还能决定通过的物质。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《实现领域驱动设计》导航页</title>
      <link href="/shi-xian-ling-yu-qu-dong-she-ji-dao-hang.html"/>
      <url>/shi-xian-ling-yu-qu-dong-she-ji-dao-hang.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现领域驱动设计介绍"><a href="#实现领域驱动设计介绍" class="headerlink" title="实现领域驱动设计介绍"></a>实现领域驱动设计介绍</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%B0%81%E9%9D%A2.jpg" alt="封面"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：<strong>如何将领域驱动设计付诸实践？</strong>Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。</p><p>《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为<strong>14</strong> 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。</p><p>《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。</p><h3 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h3><ul><li>第1章：DDD入门</li><li>第2章：领域、子域和限界上下文</li><li>第3章：上下文映射图</li><li>第4章：架构</li><li>第5章：实体</li><li>第6章：值对象</li><li>第7章：领域服务</li><li>第8章：领域事件</li><li>第9章：模块</li><li>第10章：聚合</li><li>第11章：工厂</li><li>第12章：资源库</li><li>第13章：集成限界上下文</li><li>第14章：应用程序</li><li>附录A：聚合事件源_A+ES</li></ul>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis组件的生命周期</title>
      <link href="/2.mybatis-of-javaee-hu-lian-wang-qing-liang-ji-kai-fa-zhi-sheng-ming-zhou-qi.html"/>
      <url>/2.mybatis-of-javaee-hu-lian-wang-qing-liang-ji-kai-fa-zhi-sheng-ming-zhou-qi.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis组件生命周期"><a href="#MyBatis组件生命周期" class="headerlink" title="MyBatis组件生命周期"></a>MyBatis组件生命周期</h1><p>生命周期是组件的重要问题，尤其是在多线程环境中，例如互联网应用、Socket请求中，错误的使用会造成严重的多线程并发问题。</p><p>我们会根据每一个组件的作用去确定他的生命周期。</p><h2 id="1-SqlSessionFactoryBuilder"><a href="#1-SqlSessionFactoryBuilder" class="headerlink" title="1.SqlSessionFactoryBuilder"></a>1.SqlSessionFactoryBuilder</h2><p>SqlSessionFactoryBuilder的作用在于创建SqlSessionFactory，创建成功之后，SqlSessionFactoryBuilder就失去了作用，<strong><code>所以它只能存在于SqlSessionFactory方法中</code></strong>，而不能长期存在。</p><h2 id="2-SqlSessionFactory"><a href="#2-SqlSessionFactory" class="headerlink" title="2.SqlSessionFactory"></a>2.SqlSessionFactory</h2><p>SqlSessionFactory可以被认为是一个<strong>数据库连接池</strong>，他的作用就是创建SqlSession接口对象，所以SqlSessionFactory的生命周期需要存在于整个应用之中，也可以认为<strong><code>SqlSessionFactory的生命周期就等同于MyBatis的应用周期。</code></strong></p><p>并且不能创建多个SqlSessionFactory对象，这样会导致存在多个数据库连接池，不利于数据库资源的控制，也会导致数据库连接资源被耗完。</p><p>因此在一般的应用中，我们往往希望SqlSessionFactory为一个<strong><code>单例</code></strong>，让它在应用中共享。</p><h2 id="3-SqlSession"><a href="#3-SqlSession" class="headerlink" title="3.SqlSession"></a>3.SqlSession</h2><p>SqlSession相当于一个数据库连接对象（Connection），你可以在一个事务里执行多条SQL，然后通过它的Commit、rollback等方法提交或者回滚事务。所以<strong><code>它应该存活在一个业务请求中</code></strong>。</p><p>处理完整个请求后，应该关闭这条连接，否则数据库资源会被耗光，系统会瘫痪，应该在<strong>finary</strong>语句中保证其正确关闭。</p><h2 id="4-Mapper"><a href="#4-Mapper" class="headerlink" title="4.Mapper"></a>4.Mapper</h2><p>Mapper是一个接口，它由SqlSession创建，所以它的生命周期至多和SqlSession相同，<strong><code>所以它的生命周期小于等于创建它的SqlSession生命周期</code></strong>。</p><p>Mapper代表的是一个请求中的业务处理，所以它应该在一个请求中，一旦处理完了相关的业务就应该废弃它。</p><p> 下图是MyBatis组件的生命周期图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/mybatis%20life.png" alt="Life Cycle"></p><h2 id="5-SqlSessionFactory的单例模式"><a href="#5-SqlSessionFactory的单例模式" class="headerlink" title="5.SqlSessionFactory的单例模式"></a>5.SqlSessionFactory的单例模式</h2><p>SqlSessionFactory应该采用单例模式，所以我们用单例模式构建它：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionFactoryUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 锁对象</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Class<span class="token operator">&lt;</span>SqlSessionFactoryUtils<span class="token operator">></span> LOCK <span class="token operator">=</span> SqlSessionFactoryUtils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SqlSessionFactoryUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 懒汉式单例模式,保证SqlSessionFactory实例在应用中只有一个</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SqlSessionFactory <span class="token function">getSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSessionFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> sqlSessionFactory<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            String resource <span class="token operator">=</span> <span class="token string">"mybatis-config.xml"</span><span class="token punctuation">;</span>            InputStream inputStream<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                inputStream <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>                sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> sqlSessionFactory<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取SqlSession方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SqlSession <span class="token function">openSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSessionFactory <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">getSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每次请求SqlSession都是新创建的</span>        <span class="token keyword">return</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis之核心组件</title>
      <link href="/1.mybatis-of-javaee-hu-lian-wang-qing-liang-ji-kai-fa-zhi-he-xin-zu-jian.html"/>
      <url>/1.mybatis-of-javaee-hu-lian-wang-qing-liang-ji-kai-fa-zhi-he-xin-zu-jian.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis组件创建以及基本应用"><a href="#MyBatis组件创建以及基本应用" class="headerlink" title="MyBatis组件创建以及基本应用"></a>MyBatis组件创建以及基本应用</h1><p>MyBatis最大的特点：</p><ul><li>不屏蔽SQL，意味着可以更为精确地<strong>定位SQL</strong>语句，可以对其进行优化和改造，这有利于<strong>互联网系统性能的提高</strong>，符合互联网性能优化的特点。</li><li>强大、灵活的<strong>映射机制</strong>。</li><li>在MyBatis中，提供了使用Mapper的接口编程，只要一个<strong>接口</strong>和一个<strong>XML</strong>就能创建映射器，进一步简化我们的工作，开发者能更集中于业务逻辑。</li></ul><h2 id="1-准备MyBatis环境"><a href="#1-准备MyBatis环境" class="headerlink" title="1. 准备MyBatis环境"></a>1. 准备MyBatis环境</h2><p><a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">MyBatis源码和jar包下载地址</a></p><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">MyBatis开发文档</a></p><h2 id="2-MyBatis核心组件"><a href="#2-MyBatis核心组件" class="headerlink" title="2. MyBatis核心组件"></a>2. MyBatis核心组件</h2><p>MyBatis的核心组件分为4个部分：</p><ul><li><p><strong>SqlSessionFactoryBuilder</strong>(构造器)：它会根据配置或者代码来生成SqlSessionFactory，采用的是分步构建Builder模式。</p></li><li><p><strong>SqlSessionFactory</strong>(工厂接口)：使用工厂模式生成SqlSession。</p></li><li><p><strong>SqlSession</strong>(会话)：一个既可以发送SQL执行结果返回，也可以获取Mapper的接口，在现有的技术中，一般我们会让其在业务逻辑代码中<code>“消失”</code>，而使用的是MyBatis 提供的 <strong>SQL Mapper</strong>接口编程技术，它能提高代码的可读性和可维护性。</p></li><li><p><strong>SQL Mapper</strong>(映射器)：它由一个Java接口和XML文件（或注解）构成，需要给出对应的SQL映射规则，它负责执行SQL并且返回结果。</p></li></ul><p>下图展示了四个核心组件之间的关系：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/mybatisCore.png" alt="组件之间的关系"></p><h3 id="2-1-SqlSessionFactory-工厂接口"><a href="#2-1-SqlSessionFactory-工厂接口" class="headerlink" title="2.1 SqlSessionFactory(工厂接口)"></a>2.1 SqlSessionFactory(工厂接口)</h3><p>我们可以使用<strong>XML</strong>文件的形式生成SqlSessionFactory，也可以通过<strong>Java代码</strong>的形式生成，<strong>推荐采用XML的形式</strong>，这样可以减少因为修改代码而导致的再次编译。</p><p>当配置了XML或者提供代码之后，MyBatis会读取配置文件，然后通过<code>Configuration</code>类对象构建整个MyBatis的上下文。</p><p>SqlSessionFactory是一个接口，它由两个实现类：</p><ul><li>DefaultSqlSessionFactory：用于单线程模式下使用</li><li>SqlSessionManager：可用于多线程环境下</li></ul><p>它们之间的关系可以用下图展示：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/mybatisFactory.png" alt="factory"></p><p>一个SqlSessionFactory的责任是唯一的，就是为了创建SqlSession对象，所以一般在应用中只需要一个SqlSessionFactory对象，所以通常使用<strong>单例模式</strong>来处理它。</p><h4 id="2-1-1-使用XML构建SqlSessionFactory"><a href="#2-1-1-使用XML构建SqlSessionFactory" class="headerlink" title="2.1.1 使用XML构建SqlSessionFactory"></a>2.1.1 使用XML构建SqlSessionFactory</h4><p>一下是一份简易的基础配置文件，我们将他命名<code>mybatis-config.xml</code>：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    使用别名替代类的全限定名，--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pojo.Role<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    数据库环境,现在是开发环境数据库配置，可以指定环境进行数据库配置切换--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--        因为上面的default制定了development,那么就匹配到id=development的配置节点--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!--         具体的mysql数据库配--!>            &lt;dataSource type="POOLED">                &lt;property name="driver" value="com.mysql.jdbc.Driver"/>                &lt;property name="url" value="jdbc:mysql://localhost:3306/school?useSSL=false" />                &lt;property name="username" value="root"/>                &lt;property name="password" value="123456"/>            &lt;/dataSource>        &lt;/environment>    &lt;/environments>&lt;!--    映射文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper/RoleMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>描述一下配置文件的各个节点意义：</p><ul><li><code>&lt;typeAlias&gt;</code>：使用别名role代替pojo.Role这个类。</li><li><code>&lt;environment&gt;</code>：描述数据库。</li><li><code>&lt;transactionManager&gt;</code>：配置事务管理器，这里采用MyBatis的JDBC管理器方式。</li><li><code>&lt;dataSource&gt;</code>：配置数据库，其中<strong>“type=POOLED”</strong>属性代表采用MyBatis内部提供的连接池方式。</li><li><code>&lt;Mapper&gt;</code>：代表引入的那些映射器</li></ul><p>下面代码通过XML创建了SqlSessionFactory：</p><pre class="line-numbers language-java"><code class="language-java">          <span class="token comment" spellcheck="true">//region 根据配置文件构建SqlSessionFactory</span>        SqlSessionFactory sqlSessionfactory <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 配置文件路径</span>        String resource <span class="token operator">=</span> <span class="token string">"mybatis-config.xml"</span><span class="token punctuation">;</span>        InputStream inputStream<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 加载配置文件流</span>            inputStream <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 传入配置流生成Configuration类，然后build后创建sqlSessionFactory类</span>            sqlSessionfactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//endregion</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>采用<strong>XML的创建形式</strong>，信息在配置文件中，有利于我们日后的维护和修改，避免了重新编译代码，所以推荐使用这种方式。</p><h4 id="2-1-2-使用代码创建SqlSessionFactory"><a href="#2-1-2-使用代码创建SqlSessionFactory" class="headerlink" title="2.1.2 使用代码创建SqlSessionFactory"></a>2.1.2 使用代码创建SqlSessionFactory</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> SqlSessionFactory <span class="token function">CreateFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 配置数据库连接池信息</span>        PooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriver</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/ssm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置是否默认自动提交回滚,设置false代表其中一句sql出错，事务不会回滚之前的任何操作，除非遇到中断型错误就会结束</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDefaultAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 采用MyBatis的JDBC事务方式</span>        TransactionFactory transactionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTransactionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// environment配置 id、事务管理模式、和数据库配置</span>        Environment environment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Environment</span><span class="token punctuation">(</span><span class="token string">"development"</span><span class="token punctuation">,</span>transactionFactory<span class="token punctuation">,</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建Configuration对象</span>        org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>Configuration configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注册一个MyBatis上下文别名</span>        configuration<span class="token punctuation">.</span><span class="token function">getTypeAliasRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerAlias</span><span class="token punctuation">(</span><span class="token string">"role"</span><span class="token punctuation">,</span>Role<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加一个映射器</span>        configuration<span class="token punctuation">.</span><span class="token function">addMapper</span><span class="token punctuation">(</span>RoleMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 根据configuration构建SqlSessionFactory</span>        SqlSessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码方式实现的功能和XML是一致的，只是方式不同，但是代码冗长，如果发生系统修改，那么有可能需要重新编译代码才能继续，所以这种方式不推荐。</p><p>除非有特殊 需要 ，比如在配置文件重需要<strong>配置加密过的数据库用户名和密码</strong>，需要我们在生成 SqlSessionFactory前解密为明文的时 才会考虑使用这样的方式</p><h3 id="2-2-SqlSession"><a href="#2-2-SqlSession" class="headerlink" title="2.2 SqlSession"></a>2.2 SqlSession</h3><p>SqlSession是核心接口，它有两个实现类：</p><ul><li>DefaultSqlSession：单线程使用</li><li>SqlSessionManager：多线程环境使用</li></ul><p>SqlSession类似于JDBC中的<code>Connection</code>对象，代表着一个连接资源的启用。</p><p>它的作用有三个：</p><ul><li>获取对应的Mapper接口</li><li>执行SQL</li><li>控制数据库事务</li></ul><p>我们使用SqlSessionFactory创建SqlSession对象：</p><pre class="line-numbers language-java"><code class="language-java">     SqlSession sqlSession <span class="token operator">=</span> sqlSessionfactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SqlSession是一个<strong>门面接口</strong>，它包含很多方法，我们可以用它直接发送SQL。</p><p>真正干活的是<code>Executor</code>对象。</p><p>使用SqlSession控制<strong>事务</strong>：</p><pre class="line-numbers language-java"><code class="language-java">        SqlSession sqlSession <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            sqlSession <span class="token operator">=</span> sqlSessionfactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// .... do sth   ....           </span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sqlSession<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 需要释放资源</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSession <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-映射器"><a href="#2-3-映射器" class="headerlink" title="2.3 映射器"></a>2.3 映射器</h3><p>它由一个接口和对应的XML文件（或注解）组成。</p><p>它可以配置一下内容：</p><ul><li>描述映射规则</li><li>提供SQL语句</li><li>配置缓存</li><li>提供动态SQL</li></ul><p>先定义一个<strong>POJO</strong> ：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>        <span class="token keyword">private</span>  String roleName<span class="token punctuation">;</span>        <span class="token keyword">private</span> String note<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** getter and setter...**/</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射器的主要作用就是为了将<strong><code>SQL查询到的结果映射成POJO</code></strong>，或者将POJO的数据插入到数据库中，并定义一些关于缓存的重要内容。</p><p>MyBatis运用<strong>了动态代理技术</strong>为映射接口通过映射配置文件（或者代注解）生成一个代理对象，代理对象会处理相关数据库逻辑。</p><h4 id="2-3-1-用XML实现映射器"><a href="#2-3-1-用XML实现映射器" class="headerlink" title="2.3.1 用XML实现映射器"></a>2.3.1 用XML实现映射器</h4><p>用XML定义映射器分为两个部分：</p><ul><li>接口</li><li>XML</li></ul><h5 id="①定义一个Mapper配置接口"><a href="#①定义一个Mapper配置接口" class="headerlink" title="①定义一个Mapper配置接口"></a>①定义一个<strong>Mapper配置接口</strong></h5><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 映射器接口     */</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RoleMapper</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 根据id获取Role的POJO</span>         Role <span class="token function">getRole</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在之前的配置文件<code>mybatis-config.xml</code>中有这么一个配置：</p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper/RoleMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>resource</code>属性中的属性值就是创建的映射器XML配置的路径，它的作用就是引入XML Mapper 配置文件。</p><h5 id="②创建XML-Mapper文件"><a href="#②创建XML-Mapper文件" class="headerlink" title="②创建XML Mapper文件"></a>②创建XML Mapper文件</h5><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token comment" spellcheck="true">&lt;!--MyBatis 真正的力量是在映射语句中。这里是奇迹发生的地方。    对于所有的力量,SQL 映射的 XML 文件是相当的简单。    当然如果你将它们和对等功能的 JDBC 代码来比较,你会发现映射文件节省了大约 95%的代码量。    MyBatis 的构建就是聚焦于 SQL 的,使其远离于普通的方式。--></span><span class="token comment" spellcheck="true">&lt;!--映射器创建配置文件--></span>        <span class="token comment" spellcheck="true">&lt;!--namespace为全限定名，使用该映射文件中配置的已映射的sql语句时，最好加上全限定名，不然可能会造成语句模糊。--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper.RoleMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    select表明这是一条查询语句，id标志了这条sql,parameterType="long"说明传递给sql的是Long型参数    ，resultType="role"表示返回值是role类型的，而role是之前配置文件设定的别名，#{id}代表是传递进去的参数--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getRole<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>long<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select id,role_name as roleName, note from t_role where id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了之前两个步骤：</p><ul><li>创建配置接口</li><li>创建XML配置文件</li></ul><p>我们就完成了要给映射器的定义。</p><p>映射器XML配置文件通过其中节点配置来关联对应的映射器配置接口：</p><ul><li><p><code>&lt;mapper&gt;</code>元素的属性<code>namespace</code>对应的是映射接口的全限定类名，于是MyBatis上下文就可以通过它来找到对应的映射接口。</p></li><li><p><code>&lt;select&gt;</code>元素表明这是一条查询语句</p><ul><li><p>属性<strong>id</strong>是这条SQL的标识</p></li><li><p>属性<strong>parameterType</strong>代表传递给SQL的参数类型，这里是Long类型</p></li><li><p>属性<strong>resultType</strong>代表的是这条select语句返回值类型，这里是role,这个role对应之前<code>mybatis-config.xml</code>文件中的配置节，指代的就是Role这个对象。</p><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pojo.Role<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p><strong>#{id}</strong>表示传递进去的参数。</p></li></ul><h4 id="2-3-2-注解实现映射器"><a href="#2-3-2-注解实现映射器" class="headerlink" title="2.3.2 注解实现映射器"></a>2.3.2 注解实现映射器</h4><p>之前使用XML方式实现映射器我们需要两个东西：</p><ul><li>XML配置文件</li><li>Mapper配置接口</li></ul><p>而使用注解方式，我们只需要定义一个接口即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 注解映射器</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RoleMapper2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注解方式配置 ，简单项目可以 但是一般推荐XML的方式</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"SELECT id , role_name AS roleName ,note FROM t_role WHERE id = #{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Role <span class="token function">getRole</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能看起来注解的方式创建映射器要比XML方式简单，但是使用XML方式创建映射器将会覆盖注解方式，<strong><code>所以MyBatis官方推荐XML方式</code></strong>。</p><p>因为实际情况中，很多SQL语句不止那么简单，复杂程度远远超过上面的一句SELECT语句，如果将复杂的SQL语句放入java代码中，这样java代码的可读性下降，如果同时还要考虑动态SQL，还要加入其它逻辑，不利于日后的维护和修改。</p><p>此外，XML可以相互引入，而注解不可以，在一些复杂的场景下，使用XML方式更为灵活方便，大部分企业使用的是XML方式创建映射器，当然在一些简单的场景下，使用注解方式比较简单。</p><h4 id="2-3-3-使用SqlSession执行SQL"><a href="#2-3-3-使用SqlSession执行SQL" class="headerlink" title="2.3.3 使用SqlSession执行SQL"></a>2.3.3 使用SqlSession执行SQL</h4><p>有了映射器我们就可以使用<code>SqlSession</code>来执行SQL：</p><pre class="line-numbers language-java"><code class="language-java">     String methodId <span class="token operator">=</span> <span class="token string">"mapper.RoleMapper.getRole"</span><span class="token punctuation">;</span>     Role role <span class="token operator">=</span> <span class="token punctuation">(</span>Role<span class="token punctuation">)</span>sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>methodId<span class="token punctuation">,</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们使用<code>selectOne</code>方法传入参数<code>1L</code>执行<code>methodId</code>指示的接口方法中的SQL，并且返回Role对象。</p><p>其中<strong><code>methodId</code></strong>定位了具体要执行的SQL语句，如果在MyBatis中只有一个id为getRole的SQL，那么也可以简写为一下形式：</p><pre class="line-numbers language-java"><code class="language-java">     Role role <span class="token operator">=</span> <span class="token punctuation">(</span>Role<span class="token punctuation">)</span>sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">"getRole"</span><span class="token punctuation">,</span> 1L<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-3-4使用Mapper接口执行SQL"><a href="#2-3-4使用Mapper接口执行SQL" class="headerlink" title="2.3.4使用Mapper接口执行SQL"></a>2.3.4使用Mapper接口执行SQL</h4><p>SqlSession可以获取Mapper接口，然后通过Mapper接口执行SQL：</p><pre class="line-numbers language-java"><code class="language-java">     <span class="token comment" spellcheck="true">// Mapper接口发送SQL，建议使用这种方式执行SQL</span>    RoleMapper roleMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>RoleMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Role role2 <span class="token operator">=</span> roleMapper<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过SqlSession的<code>getMapper</code>我们就可以获取一个Mapper接口，然后调用其中的方法。</p><h4 id="2-3-5-两种方法对比"><a href="#2-3-5-两种方法对比" class="headerlink" title="2.3.5 两种方法对比"></a>2.3.5 两种方法对比</h4><p><code>建议使用Mapper方式执行SQL语句：</code></p><ul><li>使用Mapper接口表示可以消除SqlSession带来的功能性代码，提高可读性，而使用SqlSession执行SQL代码，需要设置SQL id，使用Mapper根据语义化并且体现业务逻辑。</li><li>使用<strong>Mapper.getRole(1L)</strong>方式，当参数传入错误时，IDE会提示错误，而使用<strong>SqlSession.selectOne(“getRole”,1L)</strong>方式，只有在运行时才能知道是否产生错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理到责任链模式</title>
      <link href="/dong-tai-dai-li.html"/>
      <url>/dong-tai-dai-li.html</url>
      
        <content type="html"><![CDATA[<h1 id="从动态代理到责任链模式"><a href="#从动态代理到责任链模式" class="headerlink" title="从动态代理到责任链模式"></a>从动态代理到责任链模式</h1><p>代理一般来说需要两个步骤：</p><ul><li>代理对象和真实对象建立代理关系</li><li>实现代理对象的代理逻辑方法</li></ul><h2 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1.JDK动态代理"></a>1.JDK动态代理</h2><p>JDK 动态代理是 <code>java.lang.reflect.*</code>包提供的方式，它必须借助一个<code>接口</code>才能产生代理对象，</p><p>所以必须先定义一个接口：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后提供实现类<code>HelloWordImpl</code>来实现接口：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldImpl</span> <span class="token keyword">implements</span>  <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是最简单的Java接口和实现类的关系，此时可以开始动态代理了。</p><p>就像之前所说，生成代理需要两个步骤，<strong>一是先建立起代理对象和真实服务对象的关系，然后实现代码逻辑。</strong></p><p>在<code>JDK动态代理中</code>，要实现代理逻辑类必须去实现<code>java.lang.reflect.InvocationHandler</code>接口，它里面定义了一个<code>invoke</code>方法，并提供接口数组用于下挂代理对象：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkProxyExample</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 真实对象</span>        <span class="token keyword">private</span>  Object target <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 建立代理对象和真实对象的代理关系，并且返回代理对象         * @param target 真实对象         * @return 代理对象         */</span>        <span class="token keyword">public</span> Object <span class="token function">bind</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 真实对象引用赋值</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回代理对象</span>            <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>                    <span class="token comment" spellcheck="true">// 获得类加载器，此代码用的是真实对象的类加载器</span>                    target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// 设置动态生成的代理对象挂在哪些接口下，此代码用的是真实对象的类</span>                    target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// this代表当前对象，此对象必须实现InvocationHandler接口</span>                    <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         *         * @param proxy 代理对象         * @param method 当前调度方法         * @param args 当前方法参数         * @return 代理结果返回         * @throws Throwable 异常         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入代理逻辑方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在调度真实对象之前的服务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用真实对象的方法</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用真实对象之后的服务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span>  obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用结果</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>①第一步建立代理对象和真实对象的关系</strong></p><p>这里是用<code>bind()</code>方法完成的。</p><p>方法里面首先用类的属性<code>target</code>保存了<strong>真实对象</strong>，然后通过如下代码建立并生成了代理对象：</p><pre class="line-numbers language-java"><code class="language-java"> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>                    <span class="token comment" spellcheck="true">// 获得类加载器，此代码用的是真实对象的类加载器</span>                    target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// 设置动态生成的代理对象挂在哪些接口下，此代码用的是真实对象的类</span>                    target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// this代表当前对象，此对象必须实现InvocationHandler接口</span>                    <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>newProxyInstance()</code>方法包含了三个形参：</p><ul><li>第一个是类加载器，我们采用了target本身的类加载器。</li><li>第二个是指定生成的动态代理对象的挂载接口，代码中的写法就是放在了target实现的接口下，如果真实对象是<code>HelloWorldImpl</code>那么它的实现接口就是<code>HelloWorld</code>，那么代理对象就可以这样声明：<code>HelloWorld proxy = xxxx;</code></li><li>第三个是定义实现方法逻辑的<strong>代理类</strong>，this代表当前对象，它必须实现<code>InvocationHandler</code>接口的<code>invoke</code>方法，它就是代理逻辑方法的实现方法。</li></ul><p><strong>②第二步，实现代理逻辑方法</strong></p><p><code>invoke</code>方法就是实现代理逻辑的方法，它有三个参数：</p><ul><li><strong>proxy</strong>，代理对象，就是<code>bind</code>方法生成的对象。</li><li><strong>method</strong>，当前调度的方法。</li><li><strong>args</strong>，调度方法的参数。</li></ul><p>当代理对象调度对方法后，他就会调用<code>invoke</code>方法。</p><p><strong>测试调用结果</strong></p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJdkProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        JdkProxyExample jdk <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JdkProxyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 绑定关系，bind方法中将代理对象挂载到实现类的接口下，所以可以(HelloWorld)proxy显式转换代理对象为HelloWorld</span>        HelloWorld proxy<span class="token operator">=</span> <span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span>jdk<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HelloWorldimpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行代理逻辑方法invoke</span>        proxy<span class="token punctuation">.</span><span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 输出：</span>    进入代理逻辑方法    在调度真实对象之前的服务    Hello World     在调度真实对象之后的服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-CGLIB动态代理"><a href="#2-CGLIB动态代理" class="headerlink" title="2. CGLIB动态代理"></a>2. CGLIB动态代理</h2><p>因为JDK动态代理必须<strong>提供接口</strong>才能使用，在一些不能提供接口的环境中，只能采用其它第三方技术，例如<strong><code>CGLIB</code></strong>动态代理。它的优势在于不需要提供接口，只要一个<strong>非抽象类</strong>就能实现动态代理。</p><p>下面是一个例子，要给一个非抽象类<code>ReflectServiceImpl</code>通过<code>CGLIB</code>实现动态代理：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectServiceImpl</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写具体的CGLIB代理逻辑：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibProxyExample</span>  <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成CGLIB代理对象     * @param cls 实际对象的Class类     * @return Class类的CGLIB代理对象     */</span>    <span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// CGLIB enhancer增强类对象</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置增强类型（超类）</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定义代理类当前对象，要求当前对象实现MethodInterceptor方法</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 生成并且返回代理对象</span>        <span class="token keyword">return</span>  enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 代理逻辑方法     * @param proxy 代理对象     * @param method 方法     * @param args 参数     * @param methodProxy 方法代理     * @return 代理结果返回     * @throws Throwable     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用真实对象前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// CGLIB反射调用真实对象方法</span>        Object result  <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用真实对象后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里运用了CGLIB的加强者<code>Enhancer</code>通过设置超类<code>(setSuperclass)</code>，然后通过<code>setCallback</code>方法设置哪个类为它的代理类。其中，参数this就意味着是当前对象，那就要用this这个对象实现接口MethodInterceptor方法—<code>intercept</code>，然后使用<code>enhancer.create()</code>返回代理对象。</p><p>此时当前类的<code>intercept</code>方法就是其代理逻辑方法，当调用原类的某一方法后，此方法就会被执行，我们在反射真实对象的前后进行了打印，CGLIB通过如下代码反射执行真实对象方法：</p><pre class="line-numbers language-java"><code class="language-java">     <span class="token comment" spellcheck="true">// 执行超类的方法，也就是执行被代理对象的真实方法</span>    Object result  <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后测试一下代理：</p><pre class="line-numbers language-java"><code class="language-java">        CglibProxyExample cpe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibProxyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReflectServiceImpl obj <span class="token operator">=</span> <span class="token punctuation">(</span>ReflectServiceImpl<span class="token punctuation">)</span>                    cpe<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>ReflectServiceImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"wukai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java"><code class="language-java">    调用真实对象前    hello world wukai    调用真实对象后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>掌握了JDK动态代理就很容易掌握CGLIB动态代理，因为二者类似，不同的是：</p><ul><li>JDK动态代理需要设置下挂接口</li><li>CGLIB动态代理需要设置超类</li></ul><h2 id="3-拦截器"><a href="#3-拦截器" class="headerlink" title="3. 拦截器"></a>3. 拦截器</h2><p>拦截器接口封装了动态代理的实现，让开发者无需知道动态代理如何实现的，只需要知道拦截器接口的方法、含义和作用即可，用JDK动态代理来实现一个拦截器的逻辑，为此先定义拦截器接口<code>Interceptor</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 反射方法前执行     * @param proxy 代理对象     * @param target 被代理真实目标对象     * @param method 需要执行的方法     * @param args 参数     * @return     */</span>    <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际逻辑</span>    <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 反射方法后执行</span>    <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码定义了3个方法，<code>before</code>、<code>around</code>、<code>after</code>方法：</p><ul><li>三个方法的参数为<ol><li>proxy：代理对象</li><li>target：被代理的真实目标对象</li><li>method：执行方法</li><li>args：运行参数</li></ol></li><li>before方法的返回值是boolean，此方法在真实对象前调用，如果返回true则反射调用真实对象的方法，如果返回false，则接下来调用around方法。</li><li>在反射调用真实对象方法或调用around方法之后调用after方法。</li></ul><p>接下来用<code>MyInterceptor</code>实现<code>Interceptor</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span>  <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反射方法前执行逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回false，不反射调用对象原有方法</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"取代被代理对象的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反射方法后逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MyInterceptor</code>类实现了所有的<code>Interceptor</code>接口方法，接下来使用<strong>JDK动态代理</strong>，实现这些方法在适当时的调用逻辑：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorJdkProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 被代理的真实对象</span>    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拦截器全限定名</span>    <span class="token keyword">private</span> String interceptorClass <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">InterceptorJdkProxy</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> String interceptorClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>interceptorClass <span class="token operator">=</span> interceptorClass<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">bind</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> String interceptorClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回被代理对象</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InterceptorJdkProxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> interceptorClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>interceptorClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没有设置拦截器，直接反射执行原对象方法</span>            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过反射生成拦截器</span>        Interceptor interceptor <span class="token operator">=</span>                <span class="token punctuation">(</span>Interceptor<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>interceptorClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>interceptor<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果为true则反射调用原有被代理对象方法</span>            result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若返回false则执行around方法</span>            interceptor<span class="token punctuation">.</span><span class="token function">around</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 最后调用后置方法</span>        interceptor<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回执行结果</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有两个属性：</p><ul><li>target：它代表被代理的真实对象</li><li>interceptorClass它是一个拦截器的全限定名</li></ul><p><strong>解释一下这段代码的执行步骤：</strong></p><ul><li><p>第一步，在bind方法中用JDK动态代理绑定了一个对象，然后返回代理对象</p></li><li><p>第二步，在invoke方法中编写逻辑，如果没有设置拦截器，则直接反射调用真实对象的方法，然后结束，否则进行第三步。</p></li><li><p>第三步，通过反射生成拦截器</p></li><li><p>第四步，调用拦截器的before方法，如果返回ture,反射原来的方法；否则运行拦截器的around方法。</p></li><li><p>第五步，调用拦截器的after方法</p></li><li><p>第六步，返回结果</p></li></ul><p>下图是拦截器工作流程：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/interceptorWorkflow.png" alt="拦截器工作流程"></p><ul><li>开发者只需要知道拦截器的<strong>作用</strong>就可以编写拦截器，编写完成之后可以设置拦截器，这样就完成了任务，简化了开发流程。</li><li>设计者完成动态代理的逻辑，开发者可以不用知道具体实现过程。</li><li>设计者只把拦截器接口暴露给开发者使用，隐藏了动态代理的逻辑</li></ul><p>拦截器更进一步地简化了动态代理的使用方法，使程序变得更简单：</p><pre class="line-numbers language-java"><code class="language-java">        HelloWorld proxy <span class="token operator">=</span> <span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> InterceptorJdkProxy<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">HelloWorldImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">"InterceptorTest.MyInterceptor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后输出：</p><pre class="line-numbers language-java"><code class="language-java">    反射方法前执行逻辑    取代被代理对象的方法    反射方法后逻辑<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明拦截器设置成功。</p><p>简而言之，使用拦截器，开发者只需要根据接口<strong>实现自己的拦截器</strong>即可，不需要关注如何实现代理类，隐藏了动态代理实现逻辑。</p><h2 id="4-责任链模式"><a href="#4-责任链模式" class="headerlink" title="4. 责任链模式"></a>4. 责任链模式</h2><p>现实开发中，往往需要<strong>多个拦截器</strong>来对一个流程进行拦截。</p><p>举个例子：</p><p>一个程序员需要请假一周。如果把<strong>请假申请单</strong>看成一个对象，那么它可能需要经过项目经理、部门经理、人事等多个角色的审批，没有角色都有机会通过拦截这个申请单进行审批或者修改。</p><p>把每个角色看出一个拦截器，那么就需要三个拦截器，而传递的则是请假单：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/leave%20approval.png" alt="请假流程"></p><p>当一个对象在责任链上被多个拦截器处理（拦截器也可以选择不拦截处理它）时，我们把这样的设计模式称为<strong><code>责任链模式</code></strong>，它用于一个对象在多个角色中传递的场景。</p><p>例如请假申请这个例子，申请单走到了项目经理这，经理可能把”一周“时间改为了”5天“，从而影响了后面的审批，后面的审批都要根据前面的结果进行。这个时候可以考虑用<strong>层层代理</strong>来实现，就是当申请单（<code>target</code> ）走到项目经理处，使用第 个动态代理 <code>proxyl</code> 。当它走到部门经理处，部门经理会得到 个在项目经理的代理 proxyl 基础上生成的 <code>proxy2</code> 来处理经理的逻辑。当它走到人事处，会在 proxy2 基础生成 <code>proxy3</code> 如果还有其他角色，依此类推即可，可以用下图来描述拦截逻辑：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Java/Spring/interactorLogic.png" alt="拦截逻辑图"></p><p>以之前定义的拦截器接口为例，定义三个拦截器：</p><p>拦截器1：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interceptor1</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器1的 before 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行被代理对象的方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器1的 after 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拦截器2：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interceptor2</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器2的 before 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行被代理对象的方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器2的 after 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拦截器3：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interceptor3</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器3的 before 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行被代理对象的方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拦截器3的 after 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写测试代码：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 生成原对象的代理类proxy1</span>        HelloWorld proxy1 <span class="token operator">=</span> <span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> InterceptorJdkProxy<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">HelloWorldImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">"InterceptorTest.Interceptor1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生成拦截器1</span>        <span class="token comment" spellcheck="true">// 生成proxy1的代理proxy2</span>        HelloWorld proxy2 <span class="token operator">=</span> <span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> InterceptorJdkProxy<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>                proxy1<span class="token punctuation">,</span>                <span class="token string">"InterceptorTest.Interceptor2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生成拦截器2</span>        <span class="token comment" spellcheck="true">// 生成proxy2的代理proxy3</span>        HelloWorld proxy3 <span class="token operator">=</span> <span class="token punctuation">(</span>HelloWorld<span class="token punctuation">)</span> InterceptorJdkProxy<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>                proxy2<span class="token punctuation">,</span>                <span class="token string">"InterceptorTest.Interceptor3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 生成拦截器3</span>        <span class="token comment" spellcheck="true">// 调用proxy3的代理方法</span>        proxy3<span class="token punctuation">.</span><span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后输出：</p><pre class="line-numbers language-java"><code class="language-java">    拦截器<span class="token number">3</span>的 before 方法    拦截器<span class="token number">2</span>的 before 方法    拦截器<span class="token number">1</span>的 before 方法    Hello World    拦截器<span class="token number">1</span>的 after 方法    拦截器<span class="token number">2</span>的 after 方法    拦截器<span class="token number">3</span>的 after 方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>before方法执行顺序从最后一个拦截器到第一个拦截器加载顺序运行，而after方法则相反。</p><p>这时候我们如果想要多一道拦截，就可以在责任链上加入新的拦截器，增加拦截逻辑，缺点是性能不好，因为增加了代理和反射。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java扩展 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql约束</title>
      <link href="/mysql-yue-shu.html"/>
      <url>/mysql-yue-shu.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL约束概述"><a href="#MySQL约束概述" class="headerlink" title="MySQL约束概述"></a>MySQL约束概述</h1><p>在 MySQL 中，约束是指对表中数据的一种约束，能够帮助数据库管理员更好地管理数据库，并且能够确保数据库中数据的<strong>正确性</strong>和<strong>有效性</strong>。</p><p>MySQL有六类约束：</p><ol><li>主键约束</li><li>外键约束</li><li>唯一约束</li><li>检查约束</li><li>非空约束</li><li>默认值约束</li></ol><h2 id="1-主键约束"><a href="#1-主键约束" class="headerlink" title="1.主键约束"></a>1.主键约束</h2><p><strong>主键（<code>PRIMARY KEY</code>）</strong>的完整称呼是“主键约束”，为了便于DBMS更快的查找到表中的记录</p><p>主键分为：（复合主键和联合主键很多地方都被认为是一个东西）</p><ul><li>单字段主键：常见的主键，一个表格使用一个字段定义成主键</li><li>复合主键：一个表使用多个字段形成一个主键</li><li>联合主键：两个表是多对多关系，需要通过两个数据表的主键来组成联合主键（中间表），来确定一条记录</li></ul><p>创建主键需要注意的是：</p><ul><li>每个表只能定义一个主键</li><li>主键不能为NULL，并且具有唯一性</li><li>在联合主键中，一个字段名只能在其中出现一次</li><li>复合主键不能包含不必要的多余字段（最小化原则），及当把复合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性的原则，那么这个复合主键是不正确的。</li></ul><h3 id="1-1-在创建表时设置主键约束"><a href="#1-1-在创建表时设置主键约束" class="headerlink" title="1.1 在创建表时设置主键约束"></a>1.1 在创建表时设置主键约束</h3><p>在创建表时就可以为表中的一个字段或多个字段设置主键或者复合主键，但是需要遵守的原则就是：<strong>一个表只能设置一个主键</strong>。</p><h4 id="1-1-1-设置单字段主键"><a href="#1-1-1-设置单字段主键" class="headerlink" title="1.1.1 设置单字段主键"></a>1.1.1 设置单字段主键</h4><p>在创建表时设置主键主要有两种方法：</p><ol><li><p>在定义字段的<strong>同时</strong>指定主键：</p><pre class="line-numbers language-mysql"><code class="language-mysql">        -- <字段名> <数据类型> PRIMARY KEY [默认值]        CREATE TABLE tb_emp3(            id INT(11) PRIMARY KEY,            name VARCHAR(25),            salary FLOAT        );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在定义完所有字段<strong>之后</strong>指定主键：</p><pre class="line-numbers language-mysql"><code class="language-mysql">         -- [CONSTRAINT <约束名>] PRIMARY KEY [字段名]         CREATE TABLE tb_emp4(            id INT(11) NOT NULL,            name VARCHAR(32),            -- CONSTRAINT tb_PRIMARYKEY PRIMARY KEY (id)            -- 也可以写成                PRIMARY KEY (id)        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="1-1-2-在创建表时设置复合主键"><a href="#1-1-2-在创建表时设置复合主键" class="headerlink" title="1.1.2 在创建表时设置复合主键"></a>1.1.2 在创建表时设置复合主键</h4><p>所谓的复合主键就是这个主键由一张表中的多个字段组成。</p><pre class="line-numbers language-mysql"><code class="language-mysql">         -- [CONSTRAINT <约束名>] PRIMARY KEY [字段1,字段2]        CREATE TABLE tb_emp5(            deptId INT(11) NOT NULL,            name VARCHAR(32),            PRIMARY KEY (deptId,name)        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-在修改表时添加主键约束"><a href="#1-2-在修改表时添加主键约束" class="headerlink" title="1.2 在修改表时添加主键约束"></a>1.2 在修改表时添加主键约束</h3><p>我们可以在创建表格之后修改表时添加主键，需要注意的是，设置成主键约束的字段不允许有空值。</p><p>修改表时添加主键约束：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    -- ALTER TABLE <数据表名> ADD PRIMARY KEY(<字段名>);    ALTER TABLE tb_emp3 ADD PRIMARY KEY (id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-删除主键约束"><a href="#1-3-删除主键约束" class="headerlink" title="1.3 删除主键约束"></a>1.3 删除主键约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为在一个表格中只包含一个主键约束，所以不需要指定主键名</p><h3 id="1-4-设定主键自增长"><a href="#1-4-设定主键自增长" class="headerlink" title="1.4 设定主键自增长"></a>1.4 设定主键自增长</h3><p>通过给字段添加<code>AUTO_INCREMENT</code>属性来实现主键自增长：</p><pre class="line-numbers language-mysql"><code class="language-mysql">字段名 数据类型 AUTO_INCREMENTCREATE TABLE tb_student(     id INT(4) PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(25) NOT NULL    );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-指定自增字段初始值"><a href="#1-5-指定自增字段初始值" class="headerlink" title="1.5 指定自增字段初始值"></a>1.5 指定自增字段初始值</h3><p>我们可以为自增字段指定初始值，指定之后字段会从设定的初始值开始往后加。</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CREATE TABLE tb_student2 (         id INT NOT NULL AUTO_INCREMENT,        NAME VARCHAR ( 20 ) NOT NULL,         PRIMARY KEY ( ID )     ) AUTO_INCREMENT = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在末尾添加 <code>AUTO_INCREMENT = 100;</code></p><p>删除主键并且设置自增主键列：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_dept1  DROP PRIMARY KEY;    ALTER TABLE tb_dept1 MODIFY id INT AUTO_INCREMENT PRIMARY KEY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2.外键约束"></a>2.外键约束</h2><p><code>MySQL 外键约束（FOREIGN KEY）</code>是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。</p><h3 id="2-1在创建表时设置外键约束"><a href="#2-1在创建表时设置外键约束" class="headerlink" title="2.1在创建表时设置外键约束"></a>2.1在创建表时设置外键约束</h3><p>在<strong>CREATE TABLE</strong>语句中，通过<code>FOREIGN KEY</code>关键字来指定外键：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    [CONSTRAINT <外键名>] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES <主表名> 主键列1 [，主键列2，…]    CONSTRAINT fk_emp_dept1 FOREIGN KEY(depId)           REFERENCES tb_dept1 (id)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了展现表与表之间的外键关系，需要创建两个表：</p><p>部门表</p><pre class="line-numbers language-mysql"><code class="language-mysql">        CREATE TABLE tb_dept1(        id INT(11) NOT NULL,        name VARCHAR(22) NOT NULL,        location VARCHAR(50),        PRIMARY KEY(id)    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建数据表<code>tb_emp6</code>并且在此表上创建外键约束，让它的键<code>deptId</code>作为外键关联到<code>tb_dept1</code>的主键id:</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CREATE TABLE tb_emp6(        id     INT(11) AUTO_INCREMENT,        name VARCHAR(25),        depId INT(11),        salary FLOAT,        PRIMARY KEY (id),        CONSTRAINT fk_emp_dept1 FOREIGN KEY(depId) REFERENCES tb_dept1 (id)    ) AUTO_INCREMENT =100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-在修改表时添加外键约束"><a href="#2-2-在修改表时添加外键约束" class="headerlink" title="2.2 在修改表时添加外键约束"></a>2.2 在修改表时添加外键约束</h3><p>在修改数据表时添加外键约束的语法格式为：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> ADD CONSTRAINT <外键名> FOREIGN KEY(<列名>) REFERENCES <主表名> (<列名>);    ALTER TABLE tb_enp6  ADD CONSTRAINT FK_emp_dep2 FOREIGN KEY (depId) REFERENCES dep2 (Id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-删除外键约束"><a href="#2-3-删除外键约束" class="headerlink" title="2.3 删除外键约束"></a>2.3 删除外键约束</h3><p>删除外键约束的语法格式如下所示：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <表名> DROP FOREIGN KEY <外键约束名>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-唯一约束"><a href="#3-唯一约束" class="headerlink" title="3. 唯一约束"></a>3. 唯一约束</h2><p><code>MySQL 唯一约束（Unique Key）</code>是指所有记录中字段的值不能重复出现。</p><h3 id="3-1-在创建表时设置唯一约束"><a href="#3-1-在创建表时设置唯一约束" class="headerlink" title="3.1 在创建表时设置唯一约束"></a>3.1 在创建表时设置唯一约束</h3><p>唯一约束通常设置在除了主键以外的其它列上：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    <字段名> <数据类型> UNIQUE     name VARCHAR(22) UNIQUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CREATE     TABLE tb_dept2(        id INT(11) PRIMARY KEY,        name VARCHAR(22) UNIQUE,        location VARCHAR(50)    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-在修改表时添加唯一约束"><a href="#3-2-在修改表时添加唯一约束" class="headerlink" title="3.2 在修改表时添加唯一约束"></a>3.2 在修改表时添加唯一约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <表名> ADD CONSTRAINT <唯一约束名> UNIQUE （<列名>）    ALTER TABLE tb_dept2 ADD CONSTRAINT unique_name UNIQUE (name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-3-删除唯一约束"><a href="#3-3-删除唯一约束" class="headerlink" title="3.3 删除唯一约束"></a>3.3 删除唯一约束</h3><p>DROP后面是<code>INDEX</code></p><pre class="line-numbers language-mysql"><code class="language-mysql">     ALTER TABLE <表名> DROP INDEX <约束名> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-检查约束"><a href="#4-检查约束" class="headerlink" title="4.检查约束"></a>4.检查约束</h2><p><code>MySQL检查约束（CHECK）</code>是用来检查数据表中字段值有效性的一种手段，这样能够减少无效数据的输入。</p><p>检查约束使用<code>CHECK</code>关键字，具体语法如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CHECK <表达式><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的<strong>”<em>表达式</em>“</strong>指的就是SQL表达式，用于指定需要检查的限定条件，并且允许使用复杂的表达式作为限定条件。</p><p>若将CHECK约束子句置于表中某个列的定义<strong>之后</strong>，这种约束称为<strong>基于列</strong>的CHECK约束。</p><p>若将CHECK约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为<strong>基于表</strong>的CHECK约束。</p><h3 id="4-1-在创建表时设置检查约束"><a href="#4-1-在创建表时设置检查约束" class="headerlink" title="4.1 在创建表时设置检查约束"></a>4.1 在创建表时设置检查约束</h3><p>语法格式如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CHECK (<检查约束>)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下示例在数据库中创建<code>tb_emp7</code>数据库，要求salary的字段值<strong>大于0且小于10000</strong>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    CREATE     TABLE tb_emp7(        id INT(11) PRIMARY KEY AUTO_INCREMENT,        name     VARCHAR(25),        depId INT(11),        salary FLOAT,        CHECK(salary >0 AND salary < 10000),        CONSTRAINT fk_emp_dep FOREIGN KEY (depId) REFERENCES tb_dept1(id)    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">        salary FLOAT,        CHECK(salary >0 AND salary < 10000),<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-2-在修改表时添加检查约束"><a href="#4-2-在修改表时添加检查约束" class="headerlink" title="4.2 在修改表时添加检查约束"></a>4.2 在修改表时添加检查约束</h3><p>修改表时设置检查约束的语法格式如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_emp7 ADD CONSTRAINT <检查约束名> CHECK(<检查约束>)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_emp7 ADD CONSTRAINT check_id CHECK(id>0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-删除检查约束"><a href="#4-3-删除检查约束" class="headerlink" title="4.3 删除检查约束"></a>4.3 删除检查约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> DROP CONSTRAINT <检查约束名>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_emp7 DROP CONSTRAINT check_salary<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-默认约束"><a href="#5-默认约束" class="headerlink" title="5.默认约束"></a>5.默认约束</h2><h3 id="5-1-创建表时设置默认值约束"><a href="#5-1-创建表时设置默认值约束" class="headerlink" title="5.1 创建表时设置默认值约束"></a>5.1 创建表时设置默认值约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    <字段名> <数据类型> DEFAULT <默认值>;    location VARCHAR(50) DEFAULT 'Beijing'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">    CREATE TABLE tb_dept3(        id INT(11) PRIMARY KEY,        location VARCHAR(50) DEFAULT 'Beijing'    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-在修改表时添加默认值约束"><a href="#5-2-在修改表时添加默认值约束" class="headerlink" title="5.2 在修改表时添加默认值约束"></a>5.2 在修改表时添加默认值约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> CHANGE COLUMN <字段名> <字段名> <数据类型> DEFAULT <默认值>;    ALTER TABLE tb_dept3  CHANGE COLUMN location location  VARCHAR(50) DEFAULT 'Shanghai';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-3-删除默认值约束"><a href="#5-3-删除默认值约束" class="headerlink" title="5.3 删除默认值约束"></a>5.3 删除默认值约束</h3><p>将DEFAULT后的值改为<code>NULL</code>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> CHANGE COLUMN <字段名> <字段名> <数据类型> DEFAULT NULL;    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-非空约束"><a href="#6-非空约束" class="headerlink" title="6.非空约束"></a>6.非空约束</h2><h3 id="6-1-在创建表时设置非空约束"><a href="#6-1-在创建表时设置非空约束" class="headerlink" title="6.1 在创建表时设置非空约束"></a>6.1 在创建表时设置非空约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    <字段名> <数据类型> NOT NULL;    name VARCHAR(22) NOT NULL,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-2-在修改表时添加非空约束"><a href="#6-2-在修改表时添加非空约束" class="headerlink" title="6.2 在修改表时添加非空约束"></a>6.2 在修改表时添加非空约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE <数据表名> CHANGE COLUMN <字段名> <字段名> <数据类型> NOT NULL;    ALTER TABLE tb_dept4 CHANGE COLUMN location location VARCHAR(50) NOT NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-3-删除非空约束"><a href="#6-3-删除非空约束" class="headerlink" title="6.3 删除非空约束"></a>6.3 删除非空约束</h3><p>和修改表类似，只要把NOT NULL改为<strong>NULL</strong>即可：</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_dept4 CHANGE COLUMN location location VARCHAR(50)  NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><h3 id="7-1-在创建表时设置约束"><a href="#7-1-在创建表时设置约束" class="headerlink" title="7.1 在创建表时设置约束"></a>7.1 在创建表时设置约束</h3><h4 id="①主键"><a href="#①主键" class="headerlink" title="①主键"></a>①主键</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    id INT(11) PRIMARY KEY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者在定义完一个键之后，在最后定义主键，并且可以指定主键名</p><pre class="line-numbers language-mysql"><code class="language-mysql">    id INT(11),    CONSTRAINT primarykey_id PRIMARY KEY(id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="②外键"><a href="#②外键" class="headerlink" title="②外键"></a>②外键</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    CONSTRAINT fk_emp_dept1 FOREIGN KEY(depId) REFERENCES tb_dept1(Id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③唯一约束"><a href="#③唯一约束" class="headerlink" title="③唯一约束"></a>③唯一约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    name VARCHAR(32) UNIQUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="④检查约束"><a href="#④检查约束" class="headerlink" title="④检查约束"></a>④检查约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    salary FLOAT ,    CHECK(salary > 0 AND salary <10000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="⑤默认约束"><a href="#⑤默认约束" class="headerlink" title="⑤默认约束"></a>⑤默认约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    location VARCHAR(128) DEFAULT 'BeiJing'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="⑥非空约束"><a href="#⑥非空约束" class="headerlink" title="⑥非空约束"></a>⑥非空约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    location VARCHAR(128) NOT NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-2-在修改表时添加约束"><a href="#7-2-在修改表时添加约束" class="headerlink" title="7.2 在修改表时添加约束"></a>7.2 在修改表时添加约束</h3><h4 id="①主键-1"><a href="#①主键-1" class="headerlink" title="①主键"></a>①主键</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp ADD [CONSTRAINT primarykey_id] PRIMARY KEY (Id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②外键-1"><a href="#②外键-1" class="headerlink" title="②外键"></a>②外键</h4><pre class="line-numbers language-mysql"><code class="language-mysql">     ALTER TABLE tb_temp ADD CONSTRAINT fk_temp_dept1 FOREIGN KEY (depId) REFERENCES tb_dept1 (Id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③唯一约束-1"><a href="#③唯一约束-1" class="headerlink" title="③唯一约束"></a>③唯一约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp ADD CONSTRAINT unique_name UNIQUE (name)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="④检查约束-1"><a href="#④检查约束-1" class="headerlink" title="④检查约束"></a>④检查约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp ADD CONSTRAINT check_salary CHECK (salary>100) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="⑤默认约束-1"><a href="#⑤默认约束-1" class="headerlink" title="⑤默认约束"></a>⑤默认约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp CHANGE COLUMN  location location VARCHAR(128) DEFAULT 'ShangHai'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="⑥非空约束-1"><a href="#⑥非空约束-1" class="headerlink" title="⑥非空约束"></a>⑥非空约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp CHANGE COLUMN location location VARCHAR(128) NOT NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-3-删除约束"><a href="#7-3-删除约束" class="headerlink" title="7.3 删除约束"></a>7.3 删除约束</h3><h4 id="①主键-2"><a href="#①主键-2" class="headerlink" title="①主键"></a>①主键</h4><p>因为一个表只有一个主键，所以删除主键<strong>不用指定主键名</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">     ALTER TABLE tb_temp DROP PRIMARY KEY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②外键-2"><a href="#②外键-2" class="headerlink" title="②外键"></a>②外键</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp DROP FOREIGN KEY fk_temp_dept1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③唯一约束-2"><a href="#③唯一约束-2" class="headerlink" title="③唯一约束"></a>③唯一约束</h4><p>唯一约束删除DROP后面是<code>INDEX</code>而不是UNIQUE，因为唯一约束最后还是利用唯一索引来保证唯一性。</p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp DROP INDEX name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="④检查约束-2"><a href="#④检查约束-2" class="headerlink" title="④检查约束"></a>④检查约束</h4><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp DROP CONSTRAINT check_salary<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="⑤默认约束-2"><a href="#⑤默认约束-2" class="headerlink" title="⑤默认约束"></a>⑤默认约束</h4><p>DEFALUT 后面的值为<code>NULL</code></p><pre class="line-numbers language-mysql"><code class="language-mysql">    ALTER TABLE tb_temp CHANGE COLUMN location location VARCHAR(128) DEFAULT NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="⑥非空约束-2"><a href="#⑥非空约束-2" class="headerlink" title="⑥非空约束"></a>⑥非空约束</h4><pre class="line-numbers language-MYSQL"><code class="language-MYSQL">    ALTER TABLE tb_temp CHANGE COLUMN name name VARCHAR(128) NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mysql约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/java-fan-she.html"/>
      <url>/java-fan-she.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="1-类的加载、连接和初始化"><a href="#1-类的加载、连接和初始化" class="headerlink" title="1. 类的加载、连接和初始化"></a>1. 类的加载、连接和初始化</h3><p>系统可能在第一次使用某个类时加载或使用<strong>预加载</strong>机制加载某个类。</p><h4 id="1-1-类的加载"><a href="#1-1-类的加载" class="headerlink" title="1.1 类的加载"></a>1.1 类的加载</h4><p>当程序主动使用某个类时，如果该类还<strong>未被加载</strong>到内存中，则系统会通过<strong>加载、连接、初始化</strong>三个步骤来对该类进行初始化。</p><p>当没有出现意外时，<strong>JVM</strong>将会连续完成这三个步骤，所以有时也把这三个步骤统称为<strong>类加载</strong>或类的<strong>初始化</strong>。</p><p><strong>类的加载指的是将类的 class 文件读入内存，并为之创建 <code>java.lang.Class</code> 对象</strong></p><p>也就是说，当程序使用任何类时，系统都会为之创建一个 <code>java.lang.Class</code>对象。</p><h4 id="1-2-类的连接"><a href="#1-2-类的连接" class="headerlink" title="1.2 类的连接"></a>1.2 类的连接</h4><p>当类被加载之后，系统为之生成一个对应的 <code>Class</code> 对象，接着将会进入<strong>连接阶段</strong>，连接阶段负责把类的<strong>二进制</strong>数据合并到<code>JRE</code>中 。类连接又可分为如下三个阶段：</p><ol><li><strong>验证</strong>：验证阶段用于检验被加载的类是否有正确的<strong>内部结构</strong>，并和其他类协调一致。</li><li><strong>准备</strong>：类准备阶段则负责为类的<strong>类变量分配内存</strong>，并设置默认<strong>初始值</strong>。</li><li><strong>解析</strong>：将类的二进制数据中的符号引用<strong>替换成直接引用</strong></li></ol><h4 id="1-3-类的初始化"><a href="#1-3-类的初始化" class="headerlink" title="1.3 类的初始化"></a>1.3 类的初始化</h4><p>在类的初始化阶段，<strong>虚拟机</strong>负责对类进行初始化，主要就是对<strong>类变量</strong>进行初始化（Static）</p><ul><li><p>声明类变量时指定初始值</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span>    <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">5</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用静态初始化块为类变量指定初始值</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span>    <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>            a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="1-4-类初始化的时机"><a href="#1-4-类初始化的时机" class="headerlink" title="1.4 类初始化的时机"></a>1.4 类初始化的时机</h4><p>当Java程序首次通过下面6种方式来使用某个类或者接口时，系统就会初<strong>始化该类或接口</strong>：</p><ol><li>创建类的实例：<ul><li>new</li><li>反射</li><li>反序列化</li></ul></li><li>调用某个类的类方法（Static修饰的方法）</li><li>访问某个类或接口的类变量（Static修饰）</li><li>使用反射来强制创建某个类或接口对应的<code>java.lang.Class</code>对象：<ul><li><code>Class.forName(&quot;Person&quot;)</code></li></ul></li><li>初始化某个类的<strong>子类</strong>，当初始化某个子类时，该子类的<strong>所有父类</strong>都会被初始化。</li><li>直接使用<code>java.exe</code>命令来运行某个主类。</li></ol><p>需要指出的是：对于一个final型的变量，如果该类变量的值在编译时就可以确定下来，那么这个类变量相当于<code>宏变量</code>，Java编译器会在编译时直接把这个类变量出现的地方<strong>替换成它的值</strong>，因此即使程序使用该静态变量时，也不会导致该类的初始化。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">MyTest</span>    <span class="token punctuation">{</span>        <span class="token keyword">static</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块。。"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// static final修饰的字符串类变量</span>        <span class="token keyword">static</span> <span class="token keyword">final</span> String constant <span class="token operator">=</span> <span class="token string">"WuKai"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 访问并输出MyTest中的类变量constant</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>MyTest<span class="token punctuation">.</span>constant<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ①</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序的<code>MyTest</code>类中有一个<code>constant</code>的<strong>类变量</strong>，并且该类变量使用了final修饰，而且它的值可以在编译时确定下来，因此该类变量会被当成<code>宏变量</code>来处理。相当于使用常量。</p><p>所以在<code>①</code>处，编译时就会被替换成“<code>WuKai</code>”，所以①行代码不会导致初始化 <code>MyTest</code></p><p>如果是一下这种情况，<strong>无法在编译时确定的：</strong>则会初始化该类。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 采用系统当前时间为static final类变量赋值</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String compileConstant <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当使用 <code>ClassLoader</code> 类的 <code>loadClass()</code> 方法来加载某个类时，该方法只是<strong>加载该类</strong>，并不会执行该类的初始化</p><p>使用 <code>Class额forName()</code>静态方法才会导致强制初始化该类</p><pre class="line-numbers language-java"><code class="language-java">    ClassLoader cl <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仅加载</span>    cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"Tester"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化</span>    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"Tester"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><p>类加载器负责将<code>.class</code>文件（可能在本地磁盘上，也可能在网络上）加载到内存中，并为之生成对应的<code>java.lang.Class</code>对象。</p><h4 id="2-1-类加载机制"><a href="#2-1-类加载机制" class="headerlink" title="2.1 类加载机制"></a>2.1 类加载机制</h4><p>类加载器负责加载所有的类，系统为所有被载入内存重的类生成了一个<code>java.lang.Class</code>实例。一旦一个类被载入<code>JVM</code>中，<strong>同一个类</strong>就不会被再次载入了。</p><p><strong>那么如何才能算是同一个类呢？</strong></p><p>正如一个对象有一个唯一的标识一样,一个载入JVM中的类也有一个唯一的标识.</p><p>在Java中,一个类用其<strong>全限定类</strong>作为唯一标识,但是在一JVM中,一个类用其<strong>全限定类名和其类加载器</strong>作为唯一标识.</p><p>例如在<code>pg</code>的包中有一个名为<code>Person</code>的类,被类加载器<code>ClassLoader</code>的实例<code>k1</code>负责加载,则该Person类对应的Class对象在JVM中表示为<code>(Person、pg、kl)</code>和<code>(Person、pg、k2)</code>是不同的，所以它们所加载的类也是完全不同，互不兼容的。</p><p>当JVM启动时，会形成由三个类加载器组成的<strong>初始类加载器</strong>层次结构：</p><ul><li>Bootstrap ClassLoader：根类加载器</li><li>Extension ClassLoader：扩展类加载器</li><li>System ClassLoader：系统类加载器</li></ul><p><code>Bootstarp ClassLoader</code> 被成为引导（也称为原始或根）类加载器，它负责加载Java的<strong>核心类</strong>。</p><p>JVM的类加载机制主要有如下三种：</p><ol><li><strong>全盘负责</strong>：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所<strong>依赖的和引用</strong>的其它Class也由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</li><li><strong>父类委托</strong>：先让<strong>父类加载器</strong>试图加载该Class，只有在父类加载器无法加载该类时，才尝试从自己的类路径加载该类。</li><li><strong>缓存机制</strong>：该机制会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区搜寻该Class，只有当缓存种不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存中，这就是为什么修改了Class后，必须<strong>重启JVM</strong>，程序所作的修改才会生效。</li></ol><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="JVM中类加载器的关系"></p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 获得系统类加载器</span>        ClassLoader systemLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取系统类加载器的父类加载器，得到扩展类加载器</span>        ClassLoader extensionLader <span class="token operator">=</span> systemLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-通过反射查看类信息"><a href="#3-通过反射查看类信息" class="headerlink" title="3. 通过反射查看类信息"></a>3. 通过反射查看类信息</h3><p>Java很多对象在运行时都会出现两种类型：</p><ul><li>编译类型</li><li>运行时类型</li></ul><p>例如代码<code>Person p = new Student()</code>这行代码会产生一个p变量，该变量的<strong>编译时</strong>类型为<code>Person</code>(只能使用Person中的属性和方法)，<strong>运行时</strong>类型为<code>Student</code></p><p>编译时类型是由<strong>声明</strong>该变量时使用的类型所决定，运行时类型是由该变量<strong>指向</strong>的对象类型决定</p><p>并且对象只能调用<strong>编译时类型</strong>的属性和运行时类型的方法</p><p>那么如何让对象在编译时就可以使用运行时类的方法呢：</p><ul><li>当在编译时和运行时知道类型的具体信息，那么可以先用<code>instanceof</code>运算符进行判断，然后进行强制转换。</li><li>编译时无法预知该对象和类可能属于那些类，只能靠运行时信息发现该对象和类的真实信息，那么必须使用<strong>反射</strong>。</li></ul><h4 id="3-1-获得Class对象"><a href="#3-1-获得Class对象" class="headerlink" title="3.1 获得Class对象"></a>3.1 获得Class对象</h4><p>当类被加载后，系统就会为该类生成一个对应的<code>Class</code>对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常由如下三种方式：</p><ol><li>使用Class类的<code>forName(String clazzName)</code>静态方法。该方法需要传入字符串参数，该参数需要某个类的<strong>全限定</strong>类名。</li><li>调用某个类的class属性来获取该类对应的Class对象，例如<code>Person.class</code></li><li>调用某个对象的<code>getClass()</code>方法。该方法是Object类中的一个方法。</li></ol><p>对比第一种和第二种方法，第二种方式由如下两点优势：</p><ol><li>代码更安全：程序在编译阶段就可以检查需要访问的Class对象是否存在</li><li>性能更好：无需调用方法</li></ol><h4 id="3-2-从Class中获取信息"><a href="#3-2-从Class中获取信息" class="headerlink" title="3.2 从Class中获取信息"></a>3.2 从Class中获取信息</h4><p>获取Class对应类所包含的<strong>构造器</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="构造器方法"></p><p>获取Class对应类所包含的<strong>方法</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E6%96%B9%E6%B3%95.png" alt="Method"></p><p>访问Class对应类所包含的<strong>成员变量</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="Fields"></p><p>访问Class对应类上所包含的<strong>Annotation</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E6%B3%A8%E8%A7%A3.png" alt="Annotation"></p><p>访问Class的<strong>内部类</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="Inner class"></p><p>获取Class对象对应类的修饰符，所在包，类名等<strong>基本信息</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="Base Information"></p><p>判断是否为接口、枚举、注解等：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/CrazyJava/%E5%88%A4%E6%96%AD.png" alt="Judge"></p><p>举例，如何获取重载方法中的具体一个方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"no param info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"have msg info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> Integer count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"two param info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，有三个重载方法<code>info</code></p><p>此时我们要获取第二个info方法，可以这样写：</p><pre class="line-numbers language-java"><code class="language-java">        Class<span class="token operator">&lt;</span>Person<span class="token operator">></span> personClass <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> personClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">"msg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用指定实例方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-Executable基类"><a href="#3-3-Executable基类" class="headerlink" title="3.3 Executable基类"></a>3.3 Executable基类</h4><p><code>Executable</code>抽象基类代表可执行的类成员，该类派生了<code>Constructor</code>、<code>Method</code>两个子类。</p><p>Executable提供了下面两个方法获取方法或者构造器的形参个数或者形参名：</p><ul><li>int getParameterCount() :获取形参个数</li><li>Parameter[] getParameters():获取所有形参</li></ul><p>其中Parameter对象代表方法或者构造器的一个参数，它提供了大量方法获取声明该参数的泛型信息：</p><ul><li>getModifiers()：获取修饰该形参的修饰符</li><li>String getName()：获取形参名</li><li>Type getParameterizedType()：获取形参类型</li><li>Class&lt;?&gt; getType()：获取形参类型</li><li>boolean isNamePresent()：该方法返回该类的Class文件中是否包含了方法的形参名信息</li><li>boolean isVarArgs()：判断参数是否为可变形参</li></ul><h3 id="4-使用反射生成对象并且操作"><a href="#4-使用反射生成对象并且操作" class="headerlink" title="4. 使用反射生成对象并且操作"></a>4. 使用反射生成对象并且操作</h3><h4 id="4-1-创建对象"><a href="#4-1-创建对象" class="headerlink" title="4.1 创建对象"></a>4.1 创建对象</h4><p>使用对象的class对象获取指定的<code>Constructor</code>对象，然后调用<code>newInstance</code>方法创建实例：</p><pre class="line-numbers language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用 clazz 对应类的默认构造器创建实例</span><span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newlnstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-2-调用方法"><a href="#4-2-调用方法" class="headerlink" title="4.2 调用方法"></a>4.2 调用方法</h4><pre class="line-numbers language-java"><code class="language-java">Method mtd <span class="token operator">=</span> targetClass<span class="token punctuation">.</span> <span class="token function">getMethod</span><span class="token punctuation">(</span>mtdName <span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>mtd<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>targetInstance<span class="token punctuation">,</span>par<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/java-fan-xing.html"/>
      <url>/java-fan-xing.html</url>
      
        <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="1-泛型入门"><a href="#1-泛型入门" class="headerlink" title="1.泛型入门"></a>1.泛型入门</h3><h4 id="1-1-使用泛型"><a href="#1-1-使用泛型" class="headerlink" title="1.1 使用泛型"></a>1.1 使用泛型</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 创建一个只保存字符串的List集合</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> strList<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-2-菱形语法"><a href="#1-2-菱形语法" class="headerlink" title="1.2 菱形语法"></a>1.2 菱形语法</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// Java自动推断&lt;>中应该是String ,List&lt;Integer></span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> demoMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java 9中增强的菱形语法，它允许在创建匿名内部类中使用菱形语法：</p><pre class="line-numbers language-java"><code class="language-java">    Interface <span class="token class-name">Foo</span><span class="token operator">&lt;</span>T<span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnoymousTest</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 指定Foo类中泛型为String</span>            Foo<span class="token operator">&lt;</span>String<span class="token operator">></span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>String t<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-深入泛型"><a href="#2-深入泛型" class="headerlink" title="2. 深入泛型"></a>2. 深入泛型</h3><p>定义泛型接口：</p><pre class="line-numbers language-java"><code class="language-java">    Public <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果为E形参传入<strong>String</strong>类型实参，则产生了一个<strong>新的类型</strong>：<code>List&lt;String&gt;</code>类型。</p><p>也就是说，虽然程序只定义了一个<code>List&lt;E&gt;</code>接口，但实际使用时，可以产生无数多个List接口，只要为E传入不同的类型实参，系统就会多出一个新的List子接口。</p><p>必须指出，<code>List&lt;String&gt;</code>这种子类型是动态生成的<strong>逻辑子类</strong>，但这种子类在物理上并不存在（二进制代码中没有，磁盘和内存中也没有）。</p><h4 id="2-1-从泛型类派生子类"><a href="#2-1-从泛型类派生子类" class="headerlink" title="2.1 从泛型类派生子类"></a>2.1 从泛型类派生子类</h4><p>可以为泛型接口创建墀醯胺类，或从该弗雷派生子类，需要指出的是，当使用这些接口、父类时<strong>不能再包含泛型形参</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 错误，不能跟泛型形参T</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 使用Apple类时可以为T形参传入String类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以不为泛型形参传入实际的类型参数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>像这种使用Apple类时省略泛型的形式被称为<code>原始类型（raw type）</code></p><p>此时系统挥发Apple<t>类里的T形参当成<strong>Object</strong>类型处理：</t></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A2</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// super.getInfo()返回的是Object类型，所以需要加toString()才能返回String类型</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-并不存在泛型类"><a href="#2-2-并不存在泛型类" class="headerlink" title="2.2 并不存在泛型类"></a>2.2 并不存在泛型类</h4><p>之前提到可以把<strong>List<string></string></strong>类当成是<strong>List</strong>的子类，但是该<strong>List<string></string></strong>只能添加String对象作为集合元素，实际上系统并没有为<strong>List<string></string></strong>生成新的class文件，而且也不会把<strong>List<string></string></strong>当初新类来处理。</p><p>不管泛型的实际类型参数是什么，他们在运行时但总有<strong>同样的类</strong>（class），在内存中也只占用一块内存空间，因此在<strong>静态方法</strong>、<strong>静态初始块</strong>或者<strong>静态变量</strong>的声明和初始化中<strong>不允许</strong>使用泛型参数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">R</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代码错误，不能在静态变量中使用泛型形参</span>    <span class="token keyword">static</span> T info<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于系统并不会真正生成泛型类，所以<code>instanceof</code>运算符后不能使用泛型类。</p><pre class="line-numbers language-java"><code class="language-java">Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cs <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cs nstanceof ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-类型通配符"><a href="#3-类型通配符" class="headerlink" title="3. 类型通配符"></a>3. 类型通配符</h3><p>需要注意的是，List<string>对象不能被当成List<object>对象使用，<strong>也就是说说前者类并不是后着类的子类。</strong></object></string></p><p>在Java中，允许<code>Integer[]</code>数组赋值给<code>Number[]</code>变量，这不是一种安全的设计：</p><pre class="line-numbers language-java"><code class="language-java">        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> ia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Number<span class="token punctuation">[</span><span class="token punctuation">]</span> na <span class="token operator">=</span>ia<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 允许赋值</span>        na<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 运行时引发ArrayStoreException</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时<strong>ClassCaseException</strong>异常：</p><pre class="line-numbers language-java"><code class="language-java">        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 编译错误</span>        List<span class="token operator">&lt;</span>Number<span class="token operator">></span> nList <span class="token operator">=</span> iList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中将<code>List&lt;Integer&gt;</code>赋值给<code>List&lt;Number&gt;</code>就会出现编译错误。</p><p>数组和泛型不同点在于：如果<code>Foo</code>是<code>Bar</code>的一个字类型（子类型或者子接口），那么<code>Foo[]</code>依然是Bar[]的子类型；但<code>G&lt;Foo&gt;</code>不是<code>G&lt;Bar&gt;</code>的子类型。<code>Foo[]</code>自动<strong>向上转型</strong>为<code>Bar[]</code>方式被称为<code>型变</code>。</p><p>也就是说，<strong>Java的数组支持型变，但Java集合不支持型变。</strong></p><h4 id="3-1-使用类型通配符"><a href="#3-1-使用类型通配符" class="headerlink" title="3.1 使用类型通配符"></a>3.1 使用类型通配符</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Object<span class="token operator">></span>  objects<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了表示各种泛型List的父类，可以使用<strong>类型通配符</strong>，类型通配符是一个<code>？</code>号，例如<code>List&lt;T&gt;</code>意思是元素类型未知的List，它的元素类型可以匹配任何类型。</p><p>例如：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> objects<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以使用任何类型的List来调用它，程序依然可以访问c中的元素，其元素的类型时<code>Object</code>，不管List的真实类型是什么，它包含的都是<strong>Object</strong>。</p><pre class="line-numbers language-java"><code class="language-java">        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> listL<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Integer类型的List调用</span>        listL<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        listL<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> listS<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// String类型的List调用</span>        listS<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Wu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        listS<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Kai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">test</span><span class="token punctuation">(</span>listL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2</span>        <span class="token function">test</span><span class="token punctuation">(</span>listS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Wu Kai</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种通配符的List仅表示它是各种泛型List的<strong>父类</strong>， 但是并不能把元素加入其中，例如以下代码会引发编译错误：</p><pre class="line-numbers language-java"><code class="language-java">        List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 引发编译错误</span>        c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 引发编译错误</span>        c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为程序<strong>无法确定c集合中元素的类型</strong>，所以不能向其中添加对象。</p><h4 id="3-2-设定通配符的上限（协变）"><a href="#3-2-设定通配符的上限（协变）" class="headerlink" title="3.2 设定通配符的上限（协变）"></a>3.2 设定通配符的上限（协变）</h4><p> 直接使用<code>List&lt;?&gt;</code>这种形式，即表明这个List集合可以是任何泛型List的<strong>父类</strong>。</p><p>但还有一种特殊情况，程序不希望这个List&lt;?&gt;是任何泛型List的父类，只希望它代表<strong>某一类</strong>泛型List的父类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个抽象类Shape</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span>  <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个Shape的子类Circle</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在画布"</span> <span class="token operator">+</span> canvas <span class="token operator">+</span> <span class="token string">"上画了一个圆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个Shape的子类Rectangle</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"把一个矩形划到了画布"</span> <span class="token operator">+</span> canvas <span class="token operator">+</span> <span class="token string">"上"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义一个Canvas类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Canvas</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 同时在画布上绘制多个形状</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawAll</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Shape<span class="token operator">></span> shapes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Shape s <span class="token operator">:</span> shapes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下代码无法编译通过：</p><pre class="line-numbers language-java"><code class="language-java">        List<span class="token operator">&lt;</span>Circle<span class="token operator">></span> circleList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Canvas c <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Canvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 编译错误，List&lt;Circle>不是List&lt;Shape>子类</span>        c<span class="token punctuation">.</span><span class="token function">drawAll</span><span class="token punctuation">(</span>circleList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>List&lt;Circle&gt;</code>不是<code>List&lt;Shape&gt;</code>子类。</p><p>这个时候可以使用类型通配符，用<code>List&lt;?&gt;</code>替代<code>List&lt;Shape&gt;</code>，但是此时从<code>List&lt;?&gt;</code>取出来的元素只能被编译器当成Object处理，为了表示List集合的所有元素是Shape的子类，Java泛型提供了被<code>限制的</code>泛型通配符：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 它表示泛型形参必须是Shape子类的List</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将上面的Canvas程序改为如下形式就可以编译通过了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Canvas</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用被限制的泛型通配符</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawAll</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token operator">></span> shapes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Shape s <span class="token operator">:</span> shapes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时可以把<code>List&lt;Circle&gt;</code>对象当成<code>List&lt;? extends Shape&gt;</code>使用。</p><p><strong>即<code>List&lt;? extends Shape&gt;</code>可以表示成<code>List&lt;Circle&gt;</code>和<code>List&lt;Rectangle&gt;</code>的父类。</strong></p><p>此时可以把Shape称为这个通配符的<strong>上限（Upper bound）</strong></p><p>但是此时程序还是无法确定这个受限制的通配符的具体类型，所以无法将任何对象添加到这种集合中。</p><blockquote><p> <strong>简而言之，这种指定通配符上限的集合，只能从集合中取元素（取出的元素总是设定上限的类型），但是不能向集合中添加元素（因为编译器无法确定集合元素实际是哪种字类型）</strong></p></blockquote><p>指定通配符上限就是为了支持类型型变。比如<code>Foo</code>是<code>Bar</code>的子类，这样<code>A&lt;Bar&gt;</code>就相当于<code>A&lt;? extends Foo&gt;</code>的子类，可以将<code>A&lt;Bar&gt;</code>赋值给<code>A&lt;? extends Foo&gt;</code>类型的变量，这种方式呗成为<strong>协变</strong>。</p><p>对于协变的泛型类来说，它只能调用泛型类型作为<strong>返回值</strong>类型的方法，此时编译器会将该方法返回值当成通配符上限的类型；</p><p>而不能调用泛型类型作为参数的方法。</p><p><span style="color:red;font-weight:800;font-size:20px">口诀是：协变只出不进！</span></p><h4 id="3-3-设定类型通配符下限（逆变）"><a href="#3-3-设定类型通配符下限（逆变）" class="headerlink" title="3.3 设定类型通配符下限（逆变）"></a>3.3 设定类型通配符下限（逆变）</h4><p>通配符下限用<code>&lt;? super 类型&gt;</code>的方式来指定，通配符下限的作用和上限作用<strong>相反</strong>。</p><p>例如<code>Son</code>是<code>Parent</code>的子类，当程序需要一个<code>A&lt;? super Parent&gt;</code>变量时，程序可以将<code>A&lt;Son&gt;</code>、<code>A&lt;Object&gt;</code><strong>赋值</strong>给<code>A&lt;? super Parent&gt;</code>类型的变量，这种型变方式被成为<strong>逆变</strong>。</p><p>对于逆变的泛型集合来说，编译器只知道集合元素的<strong>下限</strong>的父类型，但是具体是哪种父类型则不确定。因此，这种逆变的泛型集合能向其中<strong>添加元素</strong>（因为实际赋值的集合元素总是逆变声明的父类），从集合中取元素时值能被当成是<code>Object</code>类型处理（因为编译器无法确定取出的到底是哪个父类的对象）。</p><h4 id="3-4-设定泛型形参上限"><a href="#3-4-设定泛型形参上限" class="headerlink" title="3.4 设定泛型形参上限"></a>3.4 设定泛型形参上限</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">// 设定泛型形参上限</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为泛型形参设定多个上限：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token operator">&amp;</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 设定多个泛型形参上限</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，设定多个上限时，类上限要位于第一位。</p><h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h3><h4 id="4-1-定义泛型方法"><a href="#4-1-定义泛型方法" class="headerlink" title="4.1 定义泛型方法"></a>4.1 定义泛型方法</h4><p>定义一个方法，将一个Object数组的所有元素添加到一个Collection集合中：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fromArrayToCollection</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>Object<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是c形参的数据类型是Collection<object>,正如之前所介绍，Collection<string>并不是Collection<object>的子类型，所以这个方法的功能十分有限，只能将Object数组中的元素添加到Object集合中。</object></string></object></p><pre class="line-numbers language-java"><code class="language-java">        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> strList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 报错 因为List&lt;String>并不是List&lt;Object>的子类</span>        <span class="token function">fromArrayToCollection</span><span class="token punctuation">(</span>strArr<span class="token punctuation">,</span>strList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决这个问题，可以使用<strong>泛型方法（Generic Method）</strong>：</p><pre class="line-numbers language-java"><code class="language-java">    修饰符<span class="token operator">&lt;</span>T <span class="token punctuation">,</span> S<span class="token operator">></span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span>    <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 方法体</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时就可以把之前的方法改为泛型方法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">fromArrayToCollection</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>T o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时之前报错的代码就可以编译通过了。</p><p>但是还有如下这种情形：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span>from <span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>T ele<span class="token operator">:</span> from             <span class="token punctuation">)</span> <span class="token punctuation">{</span>            to<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上泛型方法将前一个集合中的元素复制到下一个集合中，该方法中的两个形参的类型都是<code>Collection&lt;T&gt;</code>，这要求两个集合中的泛型类型相同，否则<strong>编译器无法准确推断出泛型方法中泛型形参的类型</strong>：</p><pre class="line-numbers language-java"><code class="language-java">        List<span class="token operator">&lt;</span>Object<span class="token operator">></span> to <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> from <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 无法编译通过</span>        <span class="token function">test</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种错误，可以将该方法改为如下形式：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span>from <span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>T ele<span class="token operator">:</span> from             <span class="token punctuation">)</span> <span class="token punctuation">{</span>            to<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面方法将前一个形参类型改为<code>Collection&lt;? extends T&gt;</code>，这种采用类型通配符表示方式，只要test方法的前一个Collection集合里的元素是后一个Collection集合里的元素类型的<strong>子类</strong>即可。</p><p><strong>那么到底何时采用泛型方法，何时使用类型通配符呢？</strong></p><h4 id="4-2-泛型方法和类型通配符的区别"><a href="#4-2-泛型方法和类型通配符的区别" class="headerlink" title="4.2 泛型方法和类型通配符的区别"></a>4.2 泛型方法和类型通配符的区别</h4><p>对于Java的<strong>Collection</strong>接口中两个方法的定义：</p><p>使用<strong>通配符</strong>的方法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> extendsd E<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<strong>泛型方法</strong>： </p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Colleection<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果泛型形参T产生的<strong>唯一效果</strong>是可以在不同的调用点传入不同的实际类型（只用一次），对于这种情况应该<strong>使用通配符</strong>。</p><p><strong>通配符就是被设计用来支持灵活的子类化的。</strong></p><p>如果方法中一个形参（a）的类型或返回值的类型依赖于另一个形参(b)的类型，则形参（b）的类型声明<strong>不应该使用通配符</strong>，因为形参（a）或返回值的类型依赖于该形参（b）的类型，如果形参（b）的类型无法确定，程序就无法定义形参（a）的类型，在这种情况下，只能考虑使用在方法签名中声明泛型。</p><p>也可以<strong>同时使用</strong>泛型方法和通配符：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Collections</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> coid <span class="token function">copy</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> dest <span class="token punctuation">,</span> List<span class="token operator">&lt;</span><span class="token operator">?</span> extend T<span class="token operator">></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也可以将以上方法改造成只使用泛型方法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Colleciton</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token punctuation">,</span> S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>List <span class="token operator">&lt;</span>T<span class="token operator">></span> dest <span class="token punctuation">,</span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> src<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是，上面的泛型参数S，它仅使用了一次，其他参数或者方法返回值的类型都不依赖于它，所以泛型参数S就没有存在的必要，则这时候就应该使用通配符来代替参数S。</strong></p><h4 id="4-3-泛型构造器"><a href="#4-3-泛型构造器" class="headerlink" title="4.3 泛型构造器"></a>4.3 泛型构造器</h4><p>Java允许在<strong>构造器</strong>签名中声明泛型参数，这就产生了所谓的<strong>泛型构造器</strong>。</p><pre class="line-numbers language-java"><code class="language-java">            <span class="token comment" spellcheck="true">// 定义泛型构造器</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">Foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 自动推测泛型构造器中T的类型为String</span>        <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">"WuKai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 显示指定</span>        <span class="token keyword">new</span> <span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token string">"WuKai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 传入的具体参数与显式指定的参数类型不一致，下面代码出错</span>        <span class="token keyword">new</span> <span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">12.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型构造器使用<strong>菱形</strong>语法：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 泛型类 E类型</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 泛型构造器 T类型</span>            <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">Foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// E是String类型，T是Integer类型，Foo后面使用了菱形语法，省略了String类型</span>    Foo<span class="token operator">&lt;</span>String<span class="token operator">></span> mc1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//显示指定E类型和T类型</span>    Foo<span class="token operator">&lt;</span>String<span class="token operator">></span> mc2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token operator">&lt;</span>Integer<span class="token operator">></span>Foo<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下面代码错误，显示指定了E类型。并且也显示指定了T类型，此时就不能使用菱形语法</span>    Foo<span class="token operator">&lt;</span>String<span class="token operator">></span> mc3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token operator">&lt;</span>Integer<span class="token operator">></span> Foo<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core依赖注入容器剖析</title>
      <link href="/asp.net-core-yi-lai-zhu-ru-di-ceng.html"/>
      <url>/asp.net-core-yi-lai-zhu-ru-di-ceng.html</url>
      
        <content type="html"><![CDATA[<p>图片稍大，请稍等：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Core/ASP.NET%20Core%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1.png" alt="思维导图"></p>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架揭秘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core文件系统</title>
      <link href="/wen-jian-xi-tong.html"/>
      <url>/wen-jian-xi-tong.html</url>
      
        <content type="html"><![CDATA[<p>图片较大，请稍等：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Core/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="文件系统"></p>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架揭秘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ进阶</title>
      <link href="/rabbitmq-jin-jie.html"/>
      <url>/rabbitmq-jin-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ进阶"><a href="#RabbitMQ进阶" class="headerlink" title="RabbitMQ进阶"></a>RabbitMQ进阶</h1><p>总结一些RabbitMQ的一些高级用法。</p><p>本片博客思维导图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ%E8%BF%9B%E9%98%B6.png" alt="思维导图"></p><h2 id="1-处理未被路由的消息"><a href="#1-处理未被路由的消息" class="headerlink" title="1.处理未被路由的消息"></a>1.处理未被路由的消息</h2><p>通过前两篇博客我们知道，消息是通过路由键<code>routingKey</code>、<code>bindingKey</code>和交换机类型这些条件进行路由的，那必定会出现消息发出后无法找到匹配队列这一情况，那么我们该如何处理这些消息呢？</p><h3 id="1-1mandatory参数"><a href="#1-1mandatory参数" class="headerlink" title="1.1mandatory参数"></a>1.1mandatory参数</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicPublish</span><span class="token punctuation">(</span><span class="token keyword">string</span> exchange<span class="token punctuation">,</span> <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> <span class="token keyword">bool</span> mandatory<span class="token punctuation">,</span>                   IBasicProperties basicProperties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在<code>BasicPublish</code>方法中有一个<code>mandatory</code>参数，当<code>mandatory</code>参数设置为<code>true</code>时，如果交换机无法根据自身类型和路由键找到一个合适的队列，那么RabbitMQ将会调用<code>Basic.Return</code>命令将消息返回给生产者，如果设置为<code>false</code>，出现上述情形，消息会被直接丢弃。</p><p>那么生产者如何获取这类被返回的消息呢？</p><p>我们通过订阅<code>BasicReturn</code>事件就可以获得这类消息：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_ReturnEvent.png" alt="BasicReturn"></p><p>事件方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Channel_BasicReturn</span><span class="token punctuation">(</span>        <span class="token keyword">object</span> sender<span class="token punctuation">,</span> BasicReturnEventArgs e<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Basic.Return返回的消息内容是{0}"</span><span class="token punctuation">,</span>                                       e<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中事件参数<code>BasicReturnEventArgs</code>中包含了返回的消息的内容和附加属性集等信息：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_ReturnArgs.png" alt="`BasicReturnEventArgs`"></p><p>从<code>AMQP</code>层面表示如下图所示：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_ReturnAMQP.png" alt="AMQP-Return"></p><h3 id="1-2备份交换机"><a href="#1-2备份交换机" class="headerlink" title="1.2备份交换机"></a>1.2备份交换机</h3><p>备份交换机，英文名称为<code>Alternate Exchange</code>，简称为<code>AE</code>，当然，可以直白的称为”备胎交换机”（哭晕在厕所）…如果我们将<code>mandatory</code>设置为<code>false</code>，那么消息没有被路由后会被<strong>丢弃</strong>，这时候我们设置一个备份交换机就可以将未被路由的消息存储在RabbitMQ中，在我们需要的时候处理这些消息。</p><p>我们在声明交换机的方法<code>channel.ExchangeDeclare</code>时有一个参数<code>argument</code>，代表了交换机的附加属性：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>     <span class="token keyword">string</span> exchange<span class="token punctuation">,</span>     <span class="token keyword">string</span> type<span class="token punctuation">,</span>     <span class="token keyword">bool</span> durable<span class="token punctuation">,</span>     <span class="token keyword">bool</span> autoDelete<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">//其它一些结构化参数，指定一些扩展属性</span>    IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这扩展属性中添加<code>alternate-exchange</code>在声明的时候指定此交换机为备份交换机：</p><pre class="line-numbers language-csharp"><code class="language-csharp">Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明指定交换机为备份交换机</span>args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"alternate-exchange"</span><span class="token punctuation">,</span> <span class="token string">"myAe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果我们想实现下图所示的消息功能，该如何编写代码？</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_DeclareAE.png" alt="设置备份交换机"></p><p>代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//给普通交换机添加备份交换机扩展属性</span>            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"alternate-exchange"</span><span class="token punctuation">,</span> <span class="token string">"myAe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明普通交换机，类型为Direct</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"normalExchange"</span><span class="token punctuation">,</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明备份交换机，类型为Fanout</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"myAe"</span><span class="token punctuation">,</span> ExchangeType<span class="token punctuation">.</span>Fanout<span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明和普通交换机绑定的队列</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"normalQueue"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明和备份交换机绑定的队列</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"unroutedQueue"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//普通交换机和普通队列绑定，并指定routingKey</span>            channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token string">"normalQueue"</span><span class="token punctuation">,</span> <span class="token string">"normalExchange"</span><span class="token punctuation">,</span> <span class="token string">"routingKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//备份交换机和unroutedQueue队列绑定，因为交换机类型是fanout，所以routingkey可以是任何</span>            channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token string">"unroutedQueue"</span><span class="token punctuation">,</span> <span class="token string">"myAe"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于备份交换机，它有以下的特点：</p><ul><li>即使设置的备份<strong>交换机不存在</strong>，客户端和RabbitMQ服务端也不会出现异常，此时消息将会丢失。</li><li>如果备份交换机<strong>没有绑定队列</strong>，客户端和RabbitMQ服务端也不会出现异常，此时消息将会丢失。</li><li>如果备份交换机<strong>没有任何匹配</strong>的队列，客户端和RabbitMQ服务端也不会出现异常，此时消息将会丢失。</li><li>如果备份交换机和<code>mandatory</code>参数一起使用，那么<code>mandatory</code>参数将会失效。</li></ul><h2 id="2-过期时间"><a href="#2-过期时间" class="headerlink" title="2.过期时间"></a>2.过期时间</h2><p><code>TTL</code>，Time to live 的简称，代表过期时间，RabbitMQ可以对<strong>消息和队列</strong>设置TTL。</p><h3 id="2-1设置消息的TTL"><a href="#2-1设置消息的TTL" class="headerlink" title="2.1设置消息的TTL"></a>2.1设置消息的TTL</h3><p>我们可以给消息设置TTL，目前有两种方法：</p><ol><li>通过队列的扩展属性设置，此时，队列中的所有消息都有相同的过期时间。</li><li>对消息的本身设置过期时间，此时，每条消息的过期时间可以不同</li></ol><p>注意：如果即设置了统一的过期时间，又设置了单个的过期时间，过期时间以<strong>较小的</strong>过期时间为准。</p><p>当消息存在的时间超过了过期时间，那么词条消息会变成<code>死信（Dead Message）</code></p><h4 id="对队列中的消息设置统一TTL"><a href="#对队列中的消息设置统一TTL" class="headerlink" title="对队列中的消息设置统一TTL"></a>对队列中的消息设置统一TTL</h4><p>我们在声明队列的时候，可以设置队列中消息的TTL：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> argss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            argss<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"queueName"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> argss<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上代码中，我们在声明队列的时候，通过在队列的扩展属性集中加入了<code>x-message-ttl</code>这个参数，设置统一的TTL值，这个参数的单位是<strong>毫秒</strong>。</p><h4 id="对每条消息设置TTL"><a href="#对每条消息设置TTL" class="headerlink" title="对每条消息设置TTL"></a>对每条消息设置TTL</h4><pre class="line-numbers language-csharp"><code class="language-csharp"> <span class="token keyword">var</span> prop <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置消息的TTL</span> prop<span class="token punctuation">.</span>Expiration <span class="token operator">=</span> <span class="token string">"60000"</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span><span class="token string">"exchangeName"</span><span class="token punctuation">,</span><span class="token string">"routingKey"</span><span class="token punctuation">,</span>prop<span class="token punctuation">,</span>Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2设置队列的TTL"><a href="#2-2设置队列的TTL" class="headerlink" title="2.2设置队列的TTL"></a>2.2设置队列的TTL</h3><p>在声明队列<code>channel.QueueDeclare</code>方法中，我们在队列的扩展属性集中设置<code>x-expires</code>参数可以控制队列在被自动删除前处于<strong>未使用状态</strong>的时间，未使用状态指的是该队列没有任何消费者，队列也没有被重新声明，并且在这时间段没也没有调用<code>Basic.Get</code>命令。</p><p>当队列达到设置的过期时间后，队列将会被删除，但是这个删除动作不是及时的。在RabbitMQ服务重启后，队列的过期时间将会被<strong>重新计算</strong>。</p><p><code>x-expires</code>的参数也是以毫秒为单位的。</p><p>以下代码演示了如何在声明队列的时候给队列设置过期时间：</p><pre class="line-numbers language-csharp"><code class="language-csharp"> Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在扩展属性集中添加x-expires参数，并且设置为60000毫秒也就是60秒后过期</span> args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-expires"</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"queueName"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-死信队列"><a href="#3-死信队列" class="headerlink" title="3.死信队列"></a>3.死信队列</h2><p><code>Dead-Letter-Exchange</code>简称<code>DLX</code>，可以称之为死信交换机，也有人称为死信邮箱。</p><p>当消息在队列中过期之后成为死信之后，它能重新被发送到另一个交换机，这个交换机就是<code>DLX</code>。</p><p><strong>与<code>DLX</code>的绑定队列就是<code>死信队列</code>。</strong></p><p>以下几种情况会导致消息成为死信：</p><ul><li>消息被拒绝（Basic.Reject/Basic.Nack），并且设置了<code>requeue</code>参数为<code>false</code></li><li>消息过期</li><li>队列达到了最长长度</li></ul><p>可以在任何队列上绑定<code>DLX</code>,<code>DLX</code>和普通交换机一样，当这个队列存在死信时，RabbitMQ就会自动的将这个消息重发到队列绑定的<code>DLX</code>上去，进而被路由到死信队列上去，我们可以监听这个队列，从而进行相应的处理。</p><p>我们可以在声明队列的方法<code>channel.QueueDeclare</code>中在其扩展属性集<code>arguments</code>中加入<code>x-dead-letter-exchange</code>参数来为这个队列添加<code>DLX</code>：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//声明一个名为dlx-exchange，类型为direct的交换机</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"dlx-exchange"</span><span class="token punctuation">,</span>ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">)</span><span class="token punctuation">;</span>            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//添加DLX参数</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> <span class="token string">"dxl_exchange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明队列，并且绑定相应的交换机，此时被绑定的交换机被称为死信交换机</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"myqueue"</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以为被转发到<code>DLX</code>上的消息重新定义<code>RoutingKey</code>，设定方法是在<code>channel.QueueDeclare</code>中添加<code>x-dead-letter-routing-key</code>这个参数：</p><pre class="line-numbers language-csharp"><code class="language-csharp">args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"newRoutingKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有特殊指定，那么消息将会使用原来的路由键。</p><p>我们尝试编写代码实现下图的<code>死信队列</code>功能：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_DLX.png" alt="死信队列"></p><p>代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//声明正常交换机</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"exchange.normal"</span><span class="token punctuation">,</span> ExchangeType<span class="token punctuation">.</span>Fanout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义队列附加属性集</span>            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//为队列中的消息设置过期时间（TTL）</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明死信交换机（DLX）</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"exchange-dlx"</span><span class="token punctuation">,</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//为队列绑定DLX,并且为路由到DLX的消息设定新的RoutingKey</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> <span class="token string">"exchange-dlx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"routingKey-dlx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"queue.normal"</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正常队列声明完毕</span>            <span class="token comment" spellcheck="true">//声明正常交换机</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"exhcange.normal"</span><span class="token punctuation">,</span> ExchangeType<span class="token punctuation">.</span>Fanout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//正常交换机和正常队列绑定</span>            channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token string">"queue.normal"</span><span class="token punctuation">,</span> <span class="token string">"exhcange.normal"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明死信队列</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"queue.dlx"</span><span class="token punctuation">,</span><span class="token keyword">true</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//死信队列和死信交换机绑定</span>            channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token string">"queue.dlx"</span><span class="token punctuation">,</span> <span class="token string">"exchange-dlx"</span><span class="token punctuation">,</span> <span class="token string">"routingKey-dlx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//发布消息</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                <span class="token string">"exchange.normal"</span><span class="token punctuation">,</span>                 <span class="token string">"rk"</span><span class="token punctuation">,</span>                 channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里创建了两个交换机：<code>exchange.normal</code>和<code>exchange-dlx</code>，一个为正常交换机，一个为死信交换机，并且为转发到死信交换机上的信息设置了新的<code>RoutingKey</code></p><p>随之也声明了两个队列：<code>queue.normal</code>和<code>queue.dlx</code>，一个为正常队列，一个为死信队列。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_DLXWeb.png" alt="队列属性Web展示"></p><p>在<code>RabbitMQ Web</code>管理界面中，我们可以在<code>Features</code>状态栏中看这两个队列都被标记了<code>D</code>，这个时<code>durable</code>的缩写，即设置了队列持久化，在<code>queue.normal</code>中我们还可以看到<code>TTL DLX DLK</code>这三个标记，其中<code>DLX</code>指的是队列设置了死信交换机，<code>DLX</code>指的是为被路由到私信交换机上的信息设置了新的<code>RoutingKey</code>。</p><p>生产者发送了一条路由键为<code>rk</code>的消息，此消息可以顺利地被路由到<code>queue.normal</code>队列上。因为该队列设置了过期时间为<code>10s</code>，如果<code>10s</code>之内没有消费者消费这条消息，那么该消息被判定为过期，成为死信，随之该消息被转发到死信交换机<code>exchange.dlx</code>上，并且其路由键变为<code>routingKey-dlx</code>，根据路由键和交换机类型，该消息被路由到死信队列<code>queue.dlx</code>上，我们可以监听此队列，对上面的消息进行进一步的处理。</p><p><strong>DLX是一个非常有用的特性，它可以处理异常情况，当消费者对消息调用了<code>Basic.Nack或者Basic.Reject</code>时，消息将会被置入死新队列，这时候我们就可以消费此队列的信息，从而分析当时所遇到的异常情况，从而改善和优化系统。</strong></p><h2 id="4-延迟队列"><a href="#4-延迟队列" class="headerlink" title="4.延迟队列"></a>4.延迟队列</h2><p>试想一下以下两种情景：</p><ul><li>用户通过手机远程操控家里的智能设备在指定时间进行工作。</li><li>在订单系统中，用户有30分钟的时间进行支付，超过三十分钟之后这个订单将进行异常处理。</li></ul><p>可以使用<code>延迟队列</code>来实现这两种情景。</p><p><code>延迟队列</code>指的是消息被发送以后，并不是立刻被消费的，而是等待指定时间后才能拿到这个消息进行消费。</p><p>在<code>AMQP</code>协议中，或者RabbitMQ本身并没有支持延迟队列的功能，但是可以通过之前介绍的<code>DLX</code>和<code>TTL</code>模拟出延迟队列的功能。</p><p>例如之前实现死信队列的那张图，消费者实际订阅的是<code>queue.dlx</code>队列而不是<code>queue.normal</code>，我们给队列消息设置不同的过期时间，当消息过期时，就会被转入死信队列，消费者消费死信队列中的消息，这样就模拟出了延迟队列的功能，这里的死信队列<code>queue.dlx</code>也可以称之为延迟队列。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_DelayQueue.png" alt="延迟队列"></p><p>上图中，我们将延迟时间作为<code>RoutingKey</code>，消费者订阅的都是延迟队列，这样就可以做到分不同延迟等级进行消费了。</p><h2 id="5-优先级队列"><a href="#5-优先级队列" class="headerlink" title="5.优先级队列"></a>5.优先级队列</h2><p>顾名思义，<code>优先级队列</code>就是具有不同优先级的队列，优先级高的队列中的消息具有优先被消费的特权。</p><p>我们可以在声明队列<code>channel.DeclareQueue</code>方法的附加属性集参数<code>arguments</code>中设置<code>x-max-priority</code>来实现优先级队列：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            args<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"x-max-priority"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token string">"queue.priority"</span><span class="token punctuation">,</span><span class="token keyword">true</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个队列如果设置了<code>x-max-priority</code>，那么我们可以在<code>RabbitMQ Web</code>看到相应的标记<code>Pri</code></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_PriWeb.png" alt="优先级队列标记"></p><p>在设置完队列优先级之后，我们需要给发送至此队列的消息设置优先级，默认最低为0，最高为消息设置的优先级：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> props <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            props<span class="token punctuation">.</span>Priority <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                <span class="token string">"exchange-priority"</span><span class="token punctuation">,</span>                <span class="token string">"rk_Priority"</span><span class="token punctuation">,</span>                 props<span class="token punctuation">,</span>Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，优先级消息也是有前提的：</p><ul><li>Broker中有消息堆积</li><li>生产者生产消息的速度要大于消费者消费消息的速度</li></ul><h2 id="6-实现RPC"><a href="#6-实现RPC" class="headerlink" title="6.实现RPC"></a>6.实现RPC</h2><p><code>RPC</code>是<code>Remote Procedure Call</code>的简称，即本地应用可以调用远程应用提供的函数或者方法的一种技术，由于两个应用不在一个内存空间中，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。</p><p>实现RPC的协议有很多，例如<code>CORBA</code>、<code>Java RMI</code>、<code>WebService的RPC风格</code>、<code>Hessian</code>、<code>Thrift</code>甚至可以是<code>Restful API</code>。</p><p>一般我们在RabbitMQ中实现RPC是很容易的。</p><p>客户端发送请求消息，服务端回应响应的消息。为了接受响应的消息，我们需要在请求消息中发送一个<code>回调队列</code>（参考下面代码中的ReplayTo属性），回调队列可以使用默认的队列：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//声明一个默认队列（非持久化的、排他的、自动删除的），并且保存队列名</span>            <span class="token keyword">string</span> callbackQueueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>QueueName<span class="token punctuation">;</span>            <span class="token keyword">var</span> props <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在请求消息附加属性中设置回调队列</span>            props<span class="token punctuation">.</span>ReplyTo <span class="token operator">=</span> callbackQueueName<span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>              exchange<span class="token punctuation">:</span> <span class="token string">"exchangeName"</span><span class="token punctuation">,</span>               routingKey<span class="token punctuation">:</span> <span class="token string">"rpc_queue"</span><span class="token punctuation">,</span>               props<span class="token punctuation">,</span>               Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，我们为每条消息都设定了一个回调队列，这样的做法是十分<strong>低效</strong>的，这时候我们有一个通用的解决方案：</p><ul><li>为每个客户端创建一个单一的回调队列</li></ul><p>那么这样就产生了一个问题：<strong>对于回调队列而言，在其收到一条回复的消息之后，如何知道此条消息和哪个请求匹配？</strong></p><p>这时候就可以用到<code>CorrelationId</code>这个属性了，我们因该为每一个请求设置一个唯一的<code>CorrectionId</code>：</p><ul><li>CorrectionId：用来关联请求和其调用RPC之后的回复</li></ul><p>在回调队列接受到回调消息时，可以根据这个属性匹配到响应的请求，如果回调消息接收到了一条未知的<code>CorrectionId</code>，我们可以简单地将其丢弃。</p><p>参考如下流程图：</p><p><img src="./medias/loading.gif" data-original="C:%5CUsers%5CTony%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200405165626119.png" alt="RPC流程"></p><p>根据上图，RPC地处理流程如下：</p><ol><li>客户端启动时，创建一个单一的回调队列，例如图中所示的<code>amq.gen-U....</code></li><li>当发送一条RPC请求之时，为请求设置<code>ReplayTo</code>和<code>CorrelationId</code>这两个属性值，告知服务端回复请求时的回调队列，并且标记一个请求</li><li>请求被发送到了回调队列<code>rpc_queue</code></li><li>服务端监听<code>rpc_queue</code>这个队列，当收到请求后，服务端处理请求，处理完毕之后将带有处理结果的消息发送至客户端，接受回复的队列就是之前<code>ReplayTo</code>属性设置的回调队列。</li><li>客户端监听回调队列，当有消息时，检查<code>CorrelationId</code>这个属性值，如果属性值匹配，那么得到结果。</li></ol><p>通过以下例子，创建一个客户端和一个可扩展的 RPC 服务器。由于我们没有什么耗时任务值得分发，那干脆就创建一个返回<strong>斐波那契数列</strong>的虚拟 RPC 服务吧。</p><p>具体看下面这个博客：</p><p><a href="https://www.cnblogs.com/esofar/p/rabbitmq-rpc.html" target="_blank" rel="noopener">[译]RabbitMQ教程C#版 - 远程过程调用(RPC)</a></p><p>有一个很坑的地方是，使用using方式时，消费者的回调事件注册需要放在队列声明之前：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_fib.png" alt="fib"></p><h2 id="7-持久化"><a href="#7-持久化" class="headerlink" title="7.持久化"></a>7.持久化</h2><p>持久化可以提高RabbitMQ的可靠性，以访在异常情况（重启、关闭、宕机）下的数据丢失。</p><p>RabbitMQ的持久化分为三个部分：</p><ul><li>消息持久化</li><li>队列持久化</li><li>交换机持久化</li></ul><h4 id="交换机的持久化"><a href="#交换机的持久化" class="headerlink" title="交换机的持久化"></a>交换机的持久化</h4><p>在声明交换机的方法<code>channel.DeclareExchange</code>中。将参数<code>durable</code>设置为<code>true</code>可以实现交换机持久化。</p><p>需要注意的是，如果交换机不设置为持久化，当服务器重启时，相关交换机的元素会丢失，但是消息不会丢失，只是不能把消息发送至这个交换机中了，如果交换机长期使用，建议将其设置为持久化。</p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>在声明队列的方法<code>channel.DelcareQueue</code>中，将参数<code>durable</code>设置为<code>true</code>可以实现队列的持久化，如果队列不设置持久化，那么服务器重启后，队列和队列中的消息都会消失。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>仅仅将队列设置为持久化，并不能保证队列中存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。</p><p>通过将消息的<strong>投递模式</strong>设置为<code>2</code>，即可实现消息持久化：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> prop <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prop<span class="token punctuation">.</span>DeliveryMode <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，保证消息持久化需要一个前提，那就是<strong>队列也需要设置为持久化</strong>。</p><p>如果单单只设置消息持久化，那么服务器重启之时，队列消失，继而消息也会丢失。</p><h3 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h3><p>将所有消息设置为持久化将会影响RabbitMQ的吞吐量，对于那些可靠性要求不那么高的消息可以不采用持久化处理以提高吞吐量。</p><p>在选择是或否要将消息持久化时，需要在<strong>可靠性和吞吐量之间做一个权衡</strong></p><p>持久化并不能百分之百保证数据不丢失，可以引入<code>镜像队列</code>机制保证高可用性。</p><p>还可以在发送端引入<code>事务机制</code>或者<code>发送方确认</code>机制来保证消息已经正确地发送并存储至RabbitMQ中。</p><h2 id="8-生产者确认"><a href="#8-生产者确认" class="headerlink" title="8.生产者确认"></a>8.生产者确认</h2><p>当生产者将消息发送出去之后，我们怎么知道消息有没有正确地到达服务器呢？如果连消息都没正确到达服务器，那又谈何持久化？</p><p>RabbitMQ针对这个问题，提供了两种解决方案：</p><ol><li>事务机制</li><li>发送方确认机制</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ客户端中与事务有关的方法有三个：</p><ol><li><code>channel.TxSelect</code>：开启一个事务</li><li><code>channel.TxCommit</code>：事务提交</li><li><code>channel.TxRollback</code>：事务回滚</li></ol><p>参考以下核心代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">try</span>            <span class="token punctuation">{</span>                channel<span class="token punctuation">.</span><span class="token function">TxSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>                channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                     <span class="token string">"exchangeName"</span><span class="token punctuation">,</span>                     <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                     channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                     Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"transaction messages"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">TxCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//事务提交</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">TxRollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//发送出错事务回滚</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手动开启事务之后，如果在事务提交之前捕获到了异常，显示提交事务回滚，之后进行消息重发。</p><p>对应的<code>AMQP</code>的运转流程如下图所示：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_Transaction.png" alt="Transaction"></p><ul><li>客户端发送<code>Tx.Select</code>，将信道置为事务模式；</li><li>Broker回复<code>Tx.Select-OK</code>，确认已经将信道置于事务模式；</li><li>客户端发送消息</li><li>发送出错，客户端发送<code>Tx.Rollback</code>命令给Broker，告知需要进行回滚</li><li>Broker发送<code>Tx.Rollback-Ok</code>确认回滚</li></ul><p>如果需要发送多条消息，只要把<code>channel.txCommit</code>方法包裹在循环内。而<code>channe.TxSelect</code>只要执行一次就行。</p><p>事务机制会严重影响RabbitMQ的性能，使用发送方确认机制可以更好的改进方案。</p><h3 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h3><p>生产者可以将使用<code>channel.ConfirmSelect()</code>方法将信道设置成<code>confirm</code>模式，一旦信道进入<code>confirm</code>模式，所有在该信道上面发布的消息都会被指派一个唯一的<code>ID</code>(从1开始)，该<code>ID</code>将会包含在RabbitMQ回传给生产者的确认消息的<code>deliveryTag</code>中。</p><p>当消息被投递到所匹配的队列之后，RabbitMQ就会发送一个确认<code>Basic.Ack</code>给生产者（其中包含消息的唯一ID），这样生产者就可以知道消息已经正确到达了目的地了，如果消息和队列是可持久化了，那么当消息写入磁盘后才会发送确认。</p><p><code>publisher confirm</code>运作机制看以下简要代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">try</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//将信道置为confirm模式</span>                channel<span class="token punctuation">.</span><span class="token function">ConfirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                    <span class="token string">"exchangeName"</span><span class="token punctuation">,</span>                     <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                     <span class="token keyword">null</span><span class="token punctuation">,</span>                     Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"publicher confirm test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel<span class="token punctuation">.</span><span class="token function">WaitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//没有被确认，即消息未被RabbitMQ接受</span>                <span class="token punctuation">{</span>                    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"send message filed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//do something else</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">throw</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>channel.ConfirmSelect()</code>指示信道开启<code>confirm</code>模式</p><p>对于<code>channel.WaitForConfirms()</code>方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">bool</span> <span class="token function">WaitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">WaitForConfirms</span><span class="token punctuation">(</span>TimeSpan timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">WaitForConfirms</span><span class="token punctuation">(</span>TimeSpan timeout<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token keyword">bool</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于没有参数的<code>WaitForConfirms</code>方法来说，当消息被<code>Ack</code>了就返回<code>True</code>，如果消息被<code>Nack</code>或者中断了就返回<code>False</code></p><p>参数<code>TimeSpan timeout</code>表示等待返回最多等待时间，在等待RabbitMQ的过程中超过规定回复时间，那么就会抛出错误。</p><p>参数<code>out bool timedOut</code>代表如果超时原因是因为超时过期而不是消息被<code>Nack</code>，则值为<code>True</code></p><p>下图是发送消息时的AMQP流转过程图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_Confirm.png" alt="Confirm"></p><p>我们可以看到，客户端每发送一条消息，Broker都会回应一条<code>Basic.Ack</code>来确认成功收到消息。</p><p>之前代码展示的是一种<strong>串行同步等待</strong>的方式，它和事务机制一样，都需要服务端确认之后才能执行下一步操作，而<code>publisher confirm</code>的优势在于并不一定需要<strong>同步确认</strong>，它还可以是以下两种方式：</p><ul><li>批量confirm：每发送<strong>一批</strong>消息之后，调用<code>channel.WaitForConfirms</code>方法，等待服务器确认返回</li><li>异步confirm：通过一个回调方法，当服务器确认了一条或者多条消息后客户端会调用这个回调方法。</li></ul><h4 id="批量confirm"><a href="#批量confirm" class="headerlink" title="批量confirm"></a>批量confirm</h4><p>在批量confirm方法中，客户端程序需要<strong>定期</strong>或者<strong>定量</strong>或者两种方式结合调用<code>channel.WaitForConfirm</code>方法来等待RabbitMQ确认返回。相比于每条消息都confirm，效率大大提升。</p><p>问题在于，出现返回<code>Basic.Nack</code>或者超时情况，那么客户端需要将这段时间积累的消息一次性都重发，这回带来明显的重复消息数量，并且如果消息经常丢失，批量confirm的性能不升返降。</p><p>以下代码演示了定量方式的批量confirm方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//设定批量的消息为60条</span>            <span class="token keyword">int</span> BATCH_COUNT <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//开启 punlisher confirm</span>            channel<span class="token punctuation">.</span><span class="token function">ConfirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//初始化消息数量</span>            <span class="token keyword">int</span> MsgCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//发送消息</span>                channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                    <span class="token string">"exchangeName"</span><span class="token punctuation">,</span>                     <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                     <span class="token keyword">null</span><span class="token punctuation">,</span>                     Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"batch confirm test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//TODO:将消息进行缓存</span>                <span class="token comment" spellcheck="true">//如果积累的消息数量大于设定的数量</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>MsgCount <span class="token operator">></span> BATCH_COUNT<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//归零</span>                    MsgCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span>                    <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">WaitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果被确认</span>                        <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//TODO：将缓存中的消息清空</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span>                        <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//TODO: 重新发送缓存中的消息</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//重新发送缓存中的消息</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上面的代码：</p><ul><li>首先设定了一个定量最大消息值（60条）</li><li>开启 punlisher confirm</li><li>每发送一条消息就将消息进行缓存，并且将消息数加1</li><li>如果消息条数到达最大消息数量，就调用<code>channel.WaitForConfirms</code>方法等待服务器确认返回，并且将消息数置0</li><li>如果之前消息都正确到达Broker，那么缓存中的消息清空</li><li>如果出现回复超时或者<code>Nack</code>的情况，则重新发送缓存中的消息</li></ul><h4 id="异步confirm"><a href="#异步confirm" class="headerlink" title="异步confirm"></a>异步confirm</h4><pre class="line-numbers language-csharp"><code class="language-csharp">         <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 存放未被确认的消息序列号的集合</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        SortedSet<span class="token operator">&lt;</span><span class="token keyword">ulong</span><span class="token operator">></span> unconfirmSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortedSet</span><span class="token operator">&lt;</span><span class="token keyword">ulong</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">using</span> <span class="token keyword">var</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">CreateConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">using</span> <span class="token keyword">var</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">CreateModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//开启确认模式</span>            channel<span class="token punctuation">.</span><span class="token function">ConfirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//没有被确认时触发</span>            channel<span class="token punctuation">.</span>BasicNacks <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">,</span> ea<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//Broker未确认后触发此事件</span>                <span class="token keyword">var</span> multiple <span class="token operator">=</span> ea<span class="token punctuation">.</span>Multiple<span class="token punctuation">;</span>                <span class="token keyword">var</span> deliveryTag <span class="token operator">=</span> ea<span class="token punctuation">.</span>DeliveryTag<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果开启了批量确认</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//移除序列号小于此消息序列号的所有序列号（比此条消息早的）</span>                    unconfirmSet<span class="token punctuation">.</span><span class="token function">RemoveWhere</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">&lt;</span> deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//移除此序列号</span>                    unconfirmSet<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//将消息进行重发</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//被确认时触发</span>            channel<span class="token punctuation">.</span>BasicAcks <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">,</span> ea<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//生产者发送消息至broker后失败，触发此事件</span>                <span class="token keyword">var</span> multiple <span class="token operator">=</span> ea<span class="token punctuation">.</span>Multiple<span class="token punctuation">;</span>                <span class="token keyword">var</span> deliveryTag <span class="token operator">=</span> ea<span class="token punctuation">.</span>DeliveryTag<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果开启了批量确认</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//移除序列号小于此消息序列号的所有序列号（比此条消息早的）</span>                    unconfirmSet<span class="token punctuation">.</span><span class="token function">RemoveWhere</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">&lt;</span> deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//移除此序列号</span>                    unconfirmSet<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//模拟一直发消息的情景</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">ulong</span> nextSeqNo <span class="token operator">=</span> channel<span class="token punctuation">.</span>NextPublishSeqNo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取下一条将要发布消息的的seqno（序列号）</span>                <span class="token keyword">var</span> bytesMessage <span class="token operator">=</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"confirm message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                    exchange<span class="token punctuation">:</span> <span class="token string">"confirmExchange"</span><span class="token punctuation">,</span>                    routingKey<span class="token punctuation">:</span> <span class="token string">"confirmRoutingKey"</span><span class="token punctuation">,</span>                    basicProperties<span class="token punctuation">:</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    body<span class="token punctuation">:</span> bytesMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//未确认序列号集合添加这条消息的序列号</span>                unconfirmSet<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>nextSeqNo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>确认模式和事务模式不可同时存在</p><h2 id="9-消费端要点介绍"><a href="#9-消费端要点介绍" class="headerlink" title="9.消费端要点介绍"></a>9.消费端要点介绍</h2><p>消费端可以通过拉模式和推模式的方式进行消费，消费者处理完业务逻辑后需要手动确认消息已被接受，这样RabbitMQ才能把消息从队列中标记删除，消费者还能拒绝消息<code>BasicNack</code>或者<code>BasicReject</code></p><h3 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h3><p>当队列拥有多个消费者时，队列收到的消息将以<code>轮询（round-robin）</code>的分发方式发送给消费者，<strong>每条消息只会发送个一个消费者</strong>。</p><p>这种方式非常适合扩展，如果扩展加重，只需要增加消费者就行。</p><p>但是这一分发方式有时候并不是十分优雅：默认情况下，如果有n个消费者，那么RabbitMQ将会把第m条消息分发给第<code>m%n</code>（取余）个消费者，不管该消费者是否消费并且确认积累的消息，这样就会出现有些消费者任务繁重，而有些消费者很空闲的情况。</p><p>这时候就需要使用<code>channel.BasicQos</code>这个方法解决这个问题：</p><ul><li>channel.BasicQos：现指消费者所能保持的最大未确认消息的数量</li></ul><p>如果一个消费者达到未确认消息数量最大值，那么RabbitMQ将不会再给这个消费者分发消息了。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicQos</span><span class="token punctuation">(</span><span class="token keyword">uint</span> prefetchSize<span class="token punctuation">,</span> <span class="token keyword">ushort</span> prefetchCount<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token keyword">global</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法参数：</p><ul><li>prefetchSize：表示消费者所能接受未确认消息的总体大小，单位为B，设置0为没有上限</li><li>prefetchCount：表示允许消费者所能接受的最大未确认消息</li><li>global：当设置为true的时候，信道上所有的消费者都需要遵从prefetchCount的限定值，当设置为false的时候，信道上<strong>新的</strong>消费者需要遵从prefetchCount的限定值</li></ul><p>为了性能，最好将global设置为false</p><p><strong>注意：</strong></p><p>Basic.Qos的使用对拉模式的消费方式无效</p><h3 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h3><p>如果生产者发布的消息分别为<code>msg1</code>、<code>msg2</code>、<code>msg3</code>，那么消费者必然也是按照<code>msg1</code>、<code>msg2</code>、<code>msg3</code>进行消费的，RabbitMQ在大多数情况下都能保障顺序性，但是在某些情况下：</p><ul><li>消息发送失败，重发逻辑在另一个线程中实现，那么在源头就出现了消息错序</li><li>生产者为发送的消息设置了<strong>不同的</strong>超时时间，并且也设置了死信队列，整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ客户端的开发</title>
      <link href="/kai-fa-rabbitmq-ke-hu-duan.html"/>
      <url>/kai-fa-rabbitmq-ke-hu-duan.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ客户端开发"><a href="#RabbitMQ客户端开发" class="headerlink" title="RabbitMQ客户端开发"></a>RabbitMQ客户端开发</h1><p>本篇博客思维导图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91.png" alt="思维导图"></p><p>RabbitMQ中关键的Class有<code>Channel</code>、<code>Connection</code>、<code>ConnectionFactory</code>、<code>Consumer</code>等，AMQP协议层面的操作通过<code>Channel</code>接口实现（C#中现在为<code>IModel</code>接口）</p><p><code>Connection</code>用来开启一个<code>Channel</code>，RabbitMQ的开发工作基本也是围绕<code>Connetion</code>和<code>Channel</code>两个类展开的。</p><p>本篇通过一个完整运转流程进行讲解：</p><ol><li>连接</li><li>交换机和队列的声明和绑定</li><li>发送消息</li><li>消费消息</li><li>消息确认</li><li>关闭连接</li></ol><h2 id="1-连接RabbitMQ"><a href="#1-连接RabbitMQ" class="headerlink" title="1. 连接RabbitMQ"></a>1. 连接RabbitMQ</h2><h3 id="1-1创建Connection和Channel"><a href="#1-1创建Connection和Channel" class="headerlink" title="1.1创建Connection和Channel"></a>1.1创建Connection和Channel</h3><p>给定参数连接RabbitMQ，并且创建多个<code>Channel</code>：</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//创建连接工厂，提供用户名等信息</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>UserName <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>Password <span class="token operator">=</span> <span class="token string">"123465"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>VirtualHost <span class="token operator">=</span> <span class="token string">"virtual"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>HostName <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>Port <span class="token operator">=</span> <span class="token number">2020</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        IConnection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">CreateConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建多个信道</span>        <span class="token keyword">var</span> channel1 <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">CreateModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> channel2 <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">CreateModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到一个<code>Connection</code>可以创建多个<code>Channel</code>，但是我们应该为每一个线程开辟一个<code>Channel</code>，因为<code>Channel</code>实例是<strong>非线程安全</strong>的，并发情况下可能会导致网络上出现错误的通信帧交错，也会影响到发送方确认机制（publisher confirm）的运行。</p><p>创建好<code>Channel</code>之后，我们就可以使用它来发送或者接收消息了。</p><h3 id="1-2-连接状态判定"><a href="#1-2-连接状态判定" class="headerlink" title="1.2 连接状态判定"></a>1.2 连接状态判定</h3><h4 id="IsOpen属性判定"><a href="#IsOpen属性判定" class="headerlink" title="IsOpen属性判定"></a>IsOpen属性判定</h4><p><code>Channle</code>和<code>Connection</code>都有一个<code>IsOpen</code>的属性，这个属性可以判断<code>Channel</code>和<code>Connection</code>是否开启，但是并<strong>不推荐</strong>在实际生产环境中使用<code>IsOpen</code>，因为这个属性依赖于<code>CloseReason</code>(关闭原因)，如果此属性为<code>null</code>就代表<code>Channel</code>或者<code>Connection</code>是开启状态。</p><p>但是需要<code>注意</code>的是:</p><p><code>CloseReason</code>可能会产生竞争，所以使用<code>IsOpen</code>判断<code>Connection</code>和<code>Channel</code>是否在线是不可靠的。</p><p>看下面这一段代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span>IsOpen<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//此刻IsOpen为true，判断通过</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//做某些事</span>                <span class="token comment" spellcheck="true">//...</span>                <span class="token comment" spellcheck="true">//....</span>                <span class="token comment" spellcheck="true">//做某些事的这段时间之间，channel发生离线</span>                <span class="token comment" spellcheck="true">//也就是说CloseReason不为null，执行下面的代码程序就会报错</span>                channel<span class="token punctuation">.</span><span class="token function">BasicQos</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//因为离线，所以执行失败，可能导致程序奔溃</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RabbitMQ关于<code>IsOpen</code>的摘要：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_IsOpen.png" alt="IsOpen"></p><p>RabbitMQ关于<code>CloseReason</code>的摘要：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_CloseReason.png" alt="CloseReason"></p><h4 id="try-catch判定"><a href="#try-catch判定" class="headerlink" title="try/catch判定"></a>try/catch判定</h4><p>当我们使用<code>Channel</code>的时候，如果其处于关闭状态，那么RabbitMQ可能会抛出诸如<code>RabbitMQ.Client.Exceptions.OperationInterruptedException</code>之类的错误，我们只需要捕获这些一场即可。</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//...</span>            channel<span class="token punctuation">.</span><span class="token function">BasicQos</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RabbitMQ<span class="token punctuation">.</span>Client<span class="token punctuation">.</span>Exceptions<span class="token punctuation">.</span>OperationInterruptedException</span> e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            channel<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-声明交换机和队列"><a href="#2-声明交换机和队列" class="headerlink" title="2. 声明交换机和队列"></a>2. 声明交换机和队列</h2><p>交换机<code>Exchange</code>和队列<code>Queue</code>是<code>AMQP</code>高层面构建的模块，应用程序需要确保在使用它们的时候其已存在，在使用它们的时候我们必须先声明（<code>Delare</code>）它们。</p><p>以下代码演示如何声明一个交换机和队列：</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//声明一个持久化、非自动删除、Direct类型的交换机</span>        channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>            exchange<span class="token punctuation">:</span> EXCHANGE_NAME<span class="token punctuation">,</span>            type<span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">,</span>            durable<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>            autoDelete<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            arguments<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明一个默认的队列（非持久化、排他的、自动删除），名称由RabbitMQ自动生成</span>        <span class="token keyword">string</span> queueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>QueueName<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定队列和交换机</span>        channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然你也可以不声明默认队列，根据自己的需求配置参数。</p><h3 id="2-1-ExchangeDeclare方法详解"><a href="#2-1-ExchangeDeclare方法详解" class="headerlink" title="2.1 ExchangeDeclare方法详解"></a>2.1 ExchangeDeclare方法详解</h3><h4 id="方法1：ExchangeDeclare"><a href="#方法1：ExchangeDeclare" class="headerlink" title="方法1：ExchangeDeclare"></a>方法1：ExchangeDeclare</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> exchange<span class="token punctuation">,</span>     <span class="token keyword">string</span> type<span class="token punctuation">,</span>     <span class="token keyword">bool</span> durable<span class="token punctuation">,</span>     <span class="token keyword">bool</span> autoDelete<span class="token punctuation">,</span>     IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数详解：</p><ul><li>exchange：交换机的名称</li><li>type：交换机类型，可以使用枚举<code>ExchangeType</code>设定</li><li>durable：是否持久化，设置为true的时候表示持久化，反之表示非持久化。持久化可以将交换机存在硬盘中，即使服务器重启，交换机的信息也不会丢失。</li><li>autoDelete：是否自动删除，true表示自动删除。自动删除有一个前提，在删除前至少有一个队列或者交换机与之绑定，之后所有的绑定都与之<strong>解绑</strong>，才会执行自动删除。</li><li>arguments：其它一些结构化的参数，指定扩展属性</li></ul><h4 id="方法2：ExchangeDeclareNoWait"><a href="#方法2：ExchangeDeclareNoWait" class="headerlink" title="方法2：ExchangeDeclareNoWait"></a>方法2：ExchangeDeclareNoWait</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeDeclareNoWait</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> exchange<span class="token punctuation">,</span>     <span class="token keyword">string</span> type<span class="token punctuation">,</span>     <span class="token keyword">bool</span> durable<span class="token punctuation">,</span>     <span class="token keyword">bool</span> autoDelete<span class="token punctuation">,</span>     IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此声明方法特点是<strong>不需要</strong>服务节点（Broker）返回确认，而<code>ExchangeDeclare</code>方法声明交换机需要服务器返回AMQP命令<code>Exchange.Declare-Ok</code>表示交换机在服务器中创建成功。</p><p>使用<code>ExchangeDeclareNoWait</code>方法可能会出现声明交换机之后立即使用，但是服务器可能没有创建完成这一情况，所有没有特殊原因和应用场景<strong>不建议</strong>使用此方法声明交换机。</p><h4 id="方法3：ExchangeDeclarePassive"><a href="#方法3：ExchangeDeclarePassive" class="headerlink" title="方法3：ExchangeDeclarePassive"></a>方法3：ExchangeDeclarePassive</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeDeclarePassive</span><span class="token punctuation">(</span><span class="token keyword">string</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此方法检测指定交换机是否存在，如果交换机在服务节点中已存在，则正常返回，如果不存在则抛出异常<code>404 channel exception</code>同时Channel也会被关闭，这种方法在实际应用中很常见。</p><p>我们可以写一个检测交换机是否存在的工具方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">IsExchangeExisted</span><span class="token punctuation">(</span>IModel channel<span class="token punctuation">,</span> <span class="token keyword">string</span> exchangeName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">bool</span> result <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclarePassive</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不存在则抛出错误</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//no - op</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除交换机"><a href="#删除交换机" class="headerlink" title="删除交换机"></a>删除交换机</h4><p>删除交换机的方法如下：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">void</span> <span class="token function">ExchangeDelete</span><span class="token punctuation">(</span><span class="token keyword">string</span> exchange<span class="token punctuation">,</span> <span class="token keyword">bool</span> ifUnused<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对应参数：</p><ul><li>exchange：交换机名</li><li>ifUnuser：设置是否在交换机<strong>没有被使用</strong>的情况下删除，设置true则只有在此交换机没有被使用的情况下被删除。</li></ul><p>当然还有<code>ExchangeDeleteNoWait</code>方法，Like ExchangeDelete but sets nowait to true.</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeDeleteNoWait</span><span class="token punctuation">(</span><span class="token keyword">string</span> exchange<span class="token punctuation">,</span> <span class="token keyword">bool</span> ifUnused<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-QueueDeclare方法详解"><a href="#2-2-QueueDeclare方法详解" class="headerlink" title="2.2  QueueDeclare方法详解"></a>2.2  QueueDeclare方法详解</h3><p>声明队列有四种方法</p><h4 id="方法1：QueueDeclare"><a href="#方法1：QueueDeclare" class="headerlink" title="方法1：QueueDeclare"></a>方法1：QueueDeclare</h4><pre class="line-numbers language-csharp"><code class="language-csharp">QueueDeclareOk <span class="token function">QueueDeclare</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> queue<span class="token punctuation">,</span>     <span class="token keyword">bool</span> durable<span class="token punctuation">,</span>     <span class="token keyword">bool</span> exclusive<span class="token punctuation">,</span>     <span class="token keyword">bool</span> autoDelete<span class="token punctuation">,</span>     IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法2：声明默认的队列，名称由RabbitMQ生成"><a href="#方法2：声明默认的队列，名称由RabbitMQ生成" class="headerlink" title="方法2：声明默认的队列，名称由RabbitMQ生成"></a>方法2：声明默认的队列，名称由RabbitMQ生成</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> QueueDeclareOk <span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token keyword">this</span> IModel model<span class="token punctuation">,</span> <span class="token keyword">string</span> queue <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> durable <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> exclusive <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> autoDelete <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">,</span> IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="方法3：QueueDeclarePassive"><a href="#方法3：QueueDeclarePassive" class="headerlink" title="方法3：QueueDeclarePassive"></a>方法3：QueueDeclarePassive</h4><pre class="line-numbers language-csharp"><code class="language-csharp">QueueDeclareOk <span class="token function">QueueDeclarePassive</span><span class="token punctuation">(</span><span class="token keyword">string</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="方法4：QueueDeclareNoWait"><a href="#方法4：QueueDeclareNoWait" class="headerlink" title="方法4：QueueDeclareNoWait"></a>方法4：QueueDeclareNoWait</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">QueueDeclareNoWait</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> queue<span class="token punctuation">,</span>     <span class="token keyword">bool</span> durable<span class="token punctuation">,</span>     <span class="token keyword">bool</span> exclusive<span class="token punctuation">,</span>     <span class="token keyword">bool</span> autoDelete<span class="token punctuation">,</span>     IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数作用类似之前的交换机声明，就不再细说，需要注意的一个参数是：<code>exclusive</code></p><p>exclusive：设置是否排他，设置为true时队列是排他队列</p><p>如果队列被设置为排他队列，那么此队列有以下特点</p><ol><li><p>仅对首次声明它的连接可见</p></li><li><p>连接断开时自动删除（即使设置为持久化）</p></li></ol><p>对于第一点：另一个连接(<code>Connection</code>)无法声明一个同样的队列，并且<strong>只区别连接（Connection）而不是通道（Channel）</strong>，即同一连接(<code>Connection</code>)的不同信道(<code>Channel</code>)是可以同时访问此队列的。</p><p>如果试图在一个不同的连接中重新声明或访问（如publish，consume）该排他性队列，会得到资源被锁定的错误：</p><pre class="line-numbers language-csharp"><code class="language-csharp">ESOURCE_LOCKED <span class="token operator">-</span> cannot obtain exclusive access to locked queue <span class="token string">'UserLogin2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于第二点：RabbitMQ会自动删除这个队列，而不管这个队列是否被声明成持久性的（<code>Durable =true</code>)。 也就是说即使客户端程序将一个排他性的队列声明成了<code>Durable</code>的，只要调用了连接的<code>Close</code>方法或者客户端程序退出了，RabbitMQ都会删除这个队列。<strong>注意这里是连接断开的时候，而不是通道断开</strong>。这个其实前一点保持一致，只区别连接而非通道。</p><p><strong>这种队列适用于一个客户端同时发送和读取消息的应用场景。</strong></p><h4 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h4><p>生产者和消费者都能使用<code>QueueDeclare</code>声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了，必须先取消订阅，然后将信道置为“传输”模式，之后才能声明队列。</p><h4 id="删除队列"><a href="#删除队列" class="headerlink" title="删除队列"></a>删除队列</h4><p>QueueDelete</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//Returns the number of messages purged during queue deletion</span><span class="token keyword">uint</span> <span class="token function">QueueDelete</span><span class="token punctuation">(</span><span class="token keyword">string</span> queue<span class="token punctuation">,</span> <span class="token keyword">bool</span> ifUnused<span class="token punctuation">,</span> <span class="token keyword">bool</span> ifEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它返回一个<code>uint</code>类型的值，代表队列删除期间清除的消息数量。</p><p>与删除交换机不同的是多了个参数<code>ifEmpty</code>,当此参数设置为true之时，表示队列里面<strong>没有任何消息堆积</strong>的情况下才能够删除。</p><p>QueuePurge 此方法用于删除队列上的消息而不删除队列本身</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">uint</span> <span class="token function">QueuePurge</span><span class="token punctuation">(</span><span class="token keyword">string</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-绑定"><a href="#3-绑定" class="headerlink" title="3. 绑定"></a>3. 绑定</h2><h3 id="3-1-交换机和队列之间的绑定"><a href="#3-1-交换机和队列之间的绑定" class="headerlink" title="3.1 交换机和队列之间的绑定"></a>3.1 交换机和队列之间的绑定</h3><p>将交换机和队列绑定的方法如下两种，可以和之前的方法定义进行类比：</p><p>QueueBind</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">QueueBind</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> queue<span class="token punctuation">,</span>     <span class="token keyword">string</span> exchange<span class="token punctuation">,</span>     <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> I    Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>QueueBindNoWait</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">QueueBindNoWait</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> queue<span class="token punctuation">,</span>     <span class="token keyword">string</span> exchange<span class="token punctuation">,</span>     <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span>     IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-交换机和交换机之间的绑定"><a href="#3-2-交换机和交换机之间的绑定" class="headerlink" title="3.2 交换机和交换机之间的绑定"></a>3.2 交换机和交换机之间的绑定</h3><p>不仅队列和交换机之间可以进行绑定，两个交换机之间也能绑定，两个交换机绑定之后，消息从<code>source</code>交换机转发到<code>destination</code>交换机，从某种程度上来说<code>destination</code>交换机可以看做一个队列。</p><p>ExchangeBind</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeBind</span><span class="token punctuation">(</span>    <span class="token keyword">string</span> destination<span class="token punctuation">,</span>     <span class="token keyword">string</span> source<span class="token punctuation">,</span>     <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> I    Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ExchangeBindNoWait</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ExchangeBindNoWait</span><span class="token punctuation">(</span><span class="token keyword">string</span> destination<span class="token punctuation">,</span> <span class="token keyword">string</span> source<span class="token punctuation">,</span> <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中参数：</p><ul><li>destination：目的交换机</li><li>source：源交换机</li></ul><p>思考一下如何实现下面图片上所示的绑定关系</p><p><img src="./medias/loading.gif" data-original="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200402110800655.png" alt="绑定交换机"></p><p>代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//声明源交换机</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>                exchange<span class="token punctuation">:</span> <span class="token string">"source"</span><span class="token punctuation">,</span>                type<span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明目的交换机</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>                exchange<span class="token punctuation">:</span> <span class="token string">"destination"</span><span class="token punctuation">,</span>                type<span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Fanout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明队列</span>            channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span>                queue<span class="token punctuation">:</span> <span class="token string">"queue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//绑定</span>            channel<span class="token punctuation">.</span><span class="token function">ExchangeBind</span><span class="token punctuation">(</span>destination<span class="token punctuation">:</span> <span class="token string">"destination"</span><span class="token punctuation">,</span> source<span class="token punctuation">:</span> <span class="token string">"source"</span><span class="token punctuation">,</span> routingKey<span class="token punctuation">:</span> <span class="token string">"routingKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token string">"queue"</span><span class="token punctuation">,</span> exchange<span class="token punctuation">:</span> <span class="token string">"destination"</span><span class="token punctuation">,</span> <span class="token string">"routingKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//发布消息至源交换机</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                exchange<span class="token punctuation">:</span> <span class="token string">"source"</span><span class="token punctuation">,</span>                routingKey<span class="token punctuation">:</span> <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                basicProperties<span class="token punctuation">:</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-消息发送与消费"><a href="#4-消息发送与消费" class="headerlink" title="4.消息发送与消费"></a>4.消息发送与消费</h2><h3 id="4-1-发送消息"><a href="#4-1-发送消息" class="headerlink" title="4.1 发送消息"></a>4.1 发送消息</h3><p>使用<code>Channel</code>的<code>BasicPublish</code>方法可以发送消息。</p><p>例如一下代码所示，发送一条”hello”的消息到名为”myExchange”的交换机。</p><pre class="line-numbers language-csharp"><code class="language-csharp"> channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                exchange<span class="token punctuation">:</span> <span class="token string">"myExchange"</span><span class="token punctuation">,</span>                routingKey<span class="token punctuation">:</span> <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                basicProperties<span class="token punctuation">:</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看一下<code>BasicPublish</code>方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicPublish</span><span class="token punctuation">(</span><span class="token keyword">string</span> exchange<span class="token punctuation">,</span> <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> <span class="token keyword">bool</span> mandatory<span class="token punctuation">,</span> IBasicProperties basicProperties<span class="token punctuation">,</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其它参数大同小异，主要关注<code>mandatory</code>和<code>basicProperties</code>这两个参数：</p><ul><li>mandatory：</li><li>basicProperties：消息的基本属性集，其中包括多个属性成员</li></ul><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_Prop.png" alt="Prop"></p><p><code>basicProperties</code>可以定义消息的特定属性，之前用的都是默认属性，现在我们定义消息优先级（<code>priority</code>）和内容类型：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> prop <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prop<span class="token punctuation">.</span>Priority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//优先级设置为2</span>            prop<span class="token punctuation">.</span>ContentType <span class="token operator">=</span> <span class="token string">"text/plan"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//content-type</span>            <span class="token comment" spellcheck="true">//发布消息至源交换机</span>            channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>                exchange<span class="token punctuation">:</span> <span class="token string">"source"</span><span class="token punctuation">,</span>                routingKey<span class="token punctuation">:</span> <span class="token string">"routingKey"</span><span class="token punctuation">,</span>                basicProperties<span class="token punctuation">:</span> prop<span class="token punctuation">,</span>                Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以定义过期时间（<code>expiration</code>）：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> prop <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prop<span class="token punctuation">.</span>Expiration <span class="token operator">=</span> <span class="token string">"60000"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还可以定义头部（<code>header</code>）：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> prop <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Dictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> header <span class="token operator">=</span>                 <span class="token keyword">new</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            header<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"localtion"</span><span class="token punctuation">,</span> <span class="token string">"here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            header<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"time"</span><span class="token punctuation">,</span> <span class="token string">"today"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prop<span class="token punctuation">.</span>Headers <span class="token operator">=</span> header<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-消费消息"><a href="#4-2-消费消息" class="headerlink" title="4.2 消费消息"></a>4.2 消费消息</h3><p>RabbitMQ有两种消费消息的方式：推模式（<code>Push</code>）和拉模式（<code>Pull</code>）。推模式对应的AMQP协议是<code>Basic.Consume</code>，拉模式对应的AMQP协议是<code>Basic.Get</code>。</p><h4 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h4><p>在推模式中，我们可以通过<code>持续订阅</code>的方式来消费消息。</p><p>使用<code>BasicConsume</code>方法我们可以设置并且订阅某一队列：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">string</span> <span class="token function">BasicConsume</span><span class="token punctuation">(</span><span class="token keyword">string</span> queue<span class="token punctuation">,</span> <span class="token keyword">bool</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">string</span> consumerTag<span class="token punctuation">,</span> <span class="token keyword">bool</span> noLocal<span class="token punctuation">,</span> <span class="token keyword">bool</span> exclusive<span class="token punctuation">,</span> IDictionary<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token operator">></span> arguments<span class="token punctuation">,</span> IBasicConsumer consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中各项参数：</p><ul><li>queue：队列名</li><li>autoAck：设置是否自动确认（建议设置成false，即消费者手动确认）</li><li>consumerTag：消费者标签，用来区分多个消费者</li><li>noLocal：设置同一个Connection中生产者发送的消息能否被这个Connection中的消费者消费（是否自产自销）</li><li>arguments：设置消费者其它参数</li><li>consumer：消费者回调类（可以继承IBasicConsumer重写其中的方法）</li></ul><p>我们看一下一个继承了<code>IBasicConsumer接口</code>的消费者类是怎么样的：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConsumer</span> <span class="token punctuation">:</span> IBasicConsumer    <span class="token punctuation">{</span>        <span class="token keyword">public</span> IModel Model <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">TestConsumer</span><span class="token punctuation">(</span>IModel channel<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>Model <span class="token operator">=</span> channel<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">event</span> EventHandler<span class="token operator">&lt;</span>ConsumerEventArgs<span class="token operator">></span> ConsumerCancelled<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 消费者显式（basicCancel）以外的其它原因被取消时订阅式调用，例如：队列被删除</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;param name="consumerTag">&lt;/param></span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HandleBasicCancel</span><span class="token punctuation">(</span><span class="token keyword">string</span> consumerTag<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotImplementedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 消费者通过显式（basicCancel）取消订阅后调用</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;param name="consumerTag">&lt;/param></span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HandleBasicCancelOk</span><span class="token punctuation">(</span><span class="token keyword">string</span> consumerTag<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Cancel-OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//throw new NotImplementedException();</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 在其他方法前都会调用此方法</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;param name="consumerTag">&lt;/param></span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HandleBasicConsumeOk</span><span class="token punctuation">(</span><span class="token keyword">string</span> consumerTag<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 接收到任一消息时调用</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HandleBasicDeliver</span><span class="token punctuation">(</span><span class="token keyword">string</span> consumerTag<span class="token punctuation">,</span> <span class="token keyword">ulong</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">bool</span> redelivered<span class="token punctuation">,</span> <span class="token keyword">string</span> exchange<span class="token punctuation">,</span> <span class="token keyword">string</span> routingKey<span class="token punctuation">,</span> IBasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"message arrive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//....消费消息....</span>            <span class="token comment" spellcheck="true">//消费完后手动Ack</span>           <span class="token comment" spellcheck="true">// Model.BasicAck(deliveryTag, false);</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// Channel和Connetion关闭的时候调用</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;param name="model">&lt;/param></span>        <span class="token comment" spellcheck="true">/// &lt;param name="reason">&lt;/param></span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">HandleModelShutdown</span><span class="token punctuation">(</span><span class="token keyword">object</span> model<span class="token punctuation">,</span> ShutdownEventArgs reason<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotImplementedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，例如我们在客户端调用了<code>BasicCancel()</code>方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp"> channel<span class="token punctuation">.</span><span class="token function">BasicCancel</span><span class="token punctuation">(</span><span class="token string">"MyConsumerTag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时调用方法的顺序是：<code>HandleBasicConsumeOk</code>==&gt;<code>HandleBasicCancelOk</code></p><p style="color:red;font-Weight:800">需要注意的是:</p>和生产者一样，消费者客户端同样需要考虑`线程安全`的问题。消费者客户端的这些`callback`会被分配到与`Channel`不同的线程上，这意味着消费者客户端可以安全的调用一些`阻塞`方法，例如`channel.QueueDeclare`、`channel.BasicCancel`(就算你在一个Consumer 的HandleBasicDeliver方法中阻塞了很长时间也不会影响客户端调用)<p>一般的做法是每个<code>Channel</code>对应一个消费者，当然也可以在一个<code>Channel</code>中维护多个消费者，但是这样会产生一个问题，如果<code>Channel</code>中的一个消费者一直在运行，那么它就会阻塞其它消费者。</p><h4 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h4><p>拉模式通过<code>channel.BasicGet</code>方法单条地获取消息，其返回值是<code>BasicGetResult</code>(GetResponse)</p><p>BasicGet方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp">BasicGetResult <span class="token function">BasicGet</span><span class="token punctuation">(</span><span class="token keyword">string</span> queue<span class="token punctuation">,</span> <span class="token keyword">bool</span> autoAck<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下代码是拉模式的关键代码：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            BasicGetResult result <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">BasicGet</span><span class="token punctuation">(</span><span class="token string">"MyQueue"</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">BasicAck</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>DeliveryTag<span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p style="color:red;font-Weight:800">需要注意的是:</p>只想获得单条消息而不是持续订阅，建议使用拉模式，但是我们不能将 `BasicGet`放在一个`While`循环里来代替`Basic.Consume`，这样会`严重影响`RabbitMQ的性能。<p>若要<strong>实现高吞吐量</strong>，建议使用推模式。</p><h2 id="5-消费端的确认与拒绝"><a href="#5-消费端的确认与拒绝" class="headerlink" title="5.消费端的确认与拒绝"></a>5.消费端的确认与拒绝</h2><p>为了提高消息的可靠性，RabbitMQ提供了<strong>消息确认机制。</strong></p><p>之前我们订阅队列时，有一个<code>autoAck</code>参数，定义是否设置自动确认模式，建议设置为<code>false</code>，既不自动确认。这样，RabbitMQ会显式地回复确认信号后才从内存（或者磁盘）中移除消息（实际上是先打上删除标记，之后再真正删除），如果我们设置为<code>true</code>，RabbitMQ自动就把发送的消息设置为已确认，然后从内存或者磁盘中删除，而不管消费端是否真正收到了这些消息。</p><h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><p>BasicAck方法</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicAck</span><span class="token punctuation">(</span><span class="token keyword">ulong</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">bool</span> multiple<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><ul><li>deliveryTag：消息唯一编号，区分每一条消息</li><li>multiple：是否批量确认</li></ul><p>当设置<code>autoAck</code>参数为<code>false</code>的时候，RabbitMQ会一直<code>等待</code>消息被消费者显式调用<code>Basic.Ack</code>命令才将之删除并发送下一条消息。</p><p>此时队列中的消息会被分成两个部分：</p><ol><li>已经投递给消费者但是还没有收到消费者确认信号的消息</li><li>等待投递给消费者的消息</li></ol><p>如果RabbitMQ一直没有收到消费者的确认信号，并且消费者此时已经断开连接，那么RabbitMQ会安排消息重新入列，等待投递给下个一消费者，当然那个消费者也有可能是原来的消费者。</p><p>在Web上可以看到一个队列的两种消息：</p><ul><li>Ready：等待投递消息数</li><li>Unacked：已投递未确认消息数</li></ul><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_Ack.png" alt="Web管理界面上的消息类型"></p><p>RabbitMQ允许消费者消费一条消息的时间可以很久，判断是否需要<strong>重新投递</strong>消息的依据只有一种：消费者是否断开连接</p><h4 id="消息拒绝"><a href="#消息拒绝" class="headerlink" title="消息拒绝"></a>消息拒绝</h4><p>有确认消息，也会有<strong>拒绝</strong>消息，拒绝消息的命令就是<code>Basic.Reject</code>，消费者可以调用与其对应的<code>Channel.BasicReject</code>方法来告诉RabbitMQ拒绝这个消息。</p><p>BasicReject方法</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicReject</span><span class="token punctuation">(</span><span class="token keyword">ulong</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">bool</span> requeue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><ul><li>deliveryTag：消息编号，区分每条消息</li><li>requeue：是否重新入列</li></ul><p>如果将<code>requeue</code>设置为<code>true</code>，那么RabbitMQ就会将这条被拒绝的消息重新入列，发送下一个订阅队列的消费者。如果设置为<code>false</code>，则RabbitMQ就会立即把这条消息删除，不会被再次消费。</p><p>需要注意的是<code>Basic.Reject</code><strong>一次只能拒绝一条消息</strong>，如果需要批量拒绝消息，可以使用<code>Basic.Nack</code>这个命令，对应的客户端方法为<code>channel.BasicNack</code></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">BasicNack</span><span class="token punctuation">(</span><span class="token keyword">ulong</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">bool</span> multiple<span class="token punctuation">,</span> <span class="token keyword">bool</span> requeue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法比<code>BasicReject</code>多了一个参数<code>multiple</code>，设置是否批量拒绝消息，如果设置为true，则表示拒绝此<code>deliveryTag</code>标签之前所有未被当前消费者确认的消息。</p><p style="background-color:#eaf8ff;font-weight:800">将参数`requeue`设置为`false`可以开启死信队列功能（详见下一篇）。</p><h2 id="6-关闭连接"><a href="#6-关闭连接" class="headerlink" title="6. 关闭连接"></a>6. 关闭连接</h2><h4 id="显式关闭"><a href="#显式关闭" class="headerlink" title="显式关闭"></a>显式关闭</h4><p>在应用程序使用完之后我们需要<strong>关闭连接</strong>从而释放资源：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    channel<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显式关闭是一个好习惯，但也不是必须的，当<code>connection</code>关闭的时候，<code>channel</code>也会自动的关闭。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><code>connection</code>和<code>channel</code>采用的是同一种方式管理网络失败、内部错误和显式关闭连接，所以它们具有相同类型的生命周期：</p><ul><li>Open：开启状态，代表当前对象可以使用</li><li>Closing：正在关闭状态。当前对象已经被显式地通知调用关闭方法(shutdown)，这样就会出现这种状态，已发送关闭请求，并等待关闭操作的完成</li><li>Closed：已经关闭状态</li></ul><p><code>connection</code>和<code>channel</code>最终会成为<code>Closed</code>这一状态，不管是何原因导致的（例如网络异常、显式调用或者客户端异常）</p><h4 id="监控关闭"><a href="#监控关闭" class="headerlink" title="监控关闭"></a>监控关闭</h4><p>我们可以订阅<code>ConnectionShutdown</code>事件，当连接关闭时，就会触发此事件</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_ShutdownReason.png" alt="关闭事件"></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Connection_ConnectionShutdown</span><span class="token punctuation">(</span><span class="token keyword">object</span> sender<span class="token punctuation">,</span> ShutdownEventArgs e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//TODO：日志记录等</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>ShutdownEventArgs</code>这个参数包括了此次关闭的原因，其中<code>ShutdownInitiator</code>包含了此次关闭的位置定位信息。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_ShutdownEventArgs.png" alt="`ShutdownEventArgs`"></p><p>我们还可以使用<code>connection.CloseReason</code>方法获得相关关闭信息，如果连接还处于可用状态的话返回<code>null</code></p><pre class="line-numbers language-csharp"><code class="language-csharp"> ShutdownEventArgs reason <span class="token operator">=</span> connection<span class="token punctuation">.</span>CloseReason<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/rabbitmq-ru-men.html"/>
      <url>/rabbitmq-ru-men.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><p>本篇博客的思维导图</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ%E5%85%A5%E9%97%A82.png" alt="思维导图"></p><p>本篇解决的问题：</p><ul><li>RabbitMQ的模型架构是什么？</li><li>AMQP协议是什么？</li><li>两者之间有什么紧密关系？</li><li>消息从生产者发出到消费者这一过程经历了什么？</li></ul><h2 id="1-RabbitMQ的模型架构"><a href="#1-RabbitMQ的模型架构" class="headerlink" title="1. RabbitMQ的模型架构"></a>1. RabbitMQ的模型架构</h2><p>RabbitMQ整体上是一个<strong>生产者与消费者</strong>模型，主要负责接收、存储和转发消息。</p><p>我们可以把消息传递的过程想象成：你把一个<strong>包裹</strong>送到<strong>邮局</strong>，<strong>邮局</strong>会暂存并最终将邮件通过<strong>邮递员</strong>送到收件人手上，RabbitMQ就好比邮局、邮箱、邮递员组成的一个系统。</p><p>从计算机术语层面来说，RabbitMQ模型更像一种<strong>交换机模型</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ模型架构"></p><h3 id="1-1-生产者和消费者"><a href="#1-1-生产者和消费者" class="headerlink" title="1.1 生产者和消费者"></a>1.1 生产者和消费者</h3><h4 id="生产者-Producer"><a href="#生产者-Producer" class="headerlink" title="生产者 Producer"></a>生产者 Producer</h4><p>定义：创建/投递消息的一方</p><p>消息包含两个部分：</p><ul><li>消息体（<code>payload</code>）—带有业务逻辑结构的数据，例如一个JSON字符串</li><li>标签（<code>Label</code>）—-用来表述这条消息，例如交换机名称和路由键</li></ul><h4 id="消费者-Consumer"><a href="#消费者-Consumer" class="headerlink" title="消费者 Consumer"></a>消费者 Consumer</h4><p>定义：接收消息的一方</p><p>消费者订阅队列，并且消费消息体（<code>payload</code>）,消费者并不知道此条消息的生产者是谁，当然也不需要知道</p><h4 id="服务节点-Broker"><a href="#服务节点-Broker" class="headerlink" title="服务节点 Broker"></a>服务节点 Broker</h4><p>定义：消息中间件的服务节点</p><p>大多数情况下一台<strong>RabbitMQ服务器</strong>就是一个<code>Broker</code></p><h4 id="消息队列运转流程"><a href="#消息队列运转流程" class="headerlink" title="消息队列运转流程"></a>消息队列运转流程</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_%E8%BF%90%E8%BD%AC%E6%B5%81%E7%A8%8B.png" alt="消息队列的运转流程"></p><h3 id="1-2-队列-Queue"><a href="#1-2-队列-Queue" class="headerlink" title="1.2 队列 Queue"></a>1.2 队列 Queue</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RabbitMQ内部对象，用于【存储消息】</p><p>特点：</p><ul><li>RabbitMQ中的消息都只能存储在队列中</li><li>消费者从队列中获取消息并消费</li><li>多个消费者可以订阅同一个队列</li><li>当多个消费者订阅同一个队列的时候消息被<code>平均分摊（轮询）</code>，而不是每个消费者都收到所有消息</li></ul><h4 id="声明一个队列"><a href="#声明一个队列" class="headerlink" title="声明一个队列"></a>声明一个队列</h4><p>C#语言声明一个队列</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span>            queue<span class="token punctuation">:</span> QUEUE_NAME<span class="token punctuation">,</span>            durable<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>            exclusive<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            autoDelete<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            arguments<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-交换机、路由键、绑定"><a href="#1-3-交换机、路由键、绑定" class="headerlink" title="1.3 交换机、路由键、绑定"></a>1.3 交换机、路由键、绑定</h3><h4 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机 Exchange"></a>交换机 Exchange</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="交换机"></p><p>定义：RabbitMQ中一个简单的实体。</p><p>作用：</p><ul><li>生产者将消息发送到Exchange</li><li>Exchange将消息路由到一个或者多个队列中</li></ul><p>类型：</p><p>1.fanout<br>    会把发到该交换机上的所有消息都路由到与该交换机绑定的队列中<br>    说明消息的RoutingKey在这种交换机中并没有什么作用</p><p>2.direct<br>    将发送至该交换机的消息路由到RoutingKey和BindingKey完全匹配的队列中</p><p>3.topic （经常使用）<br>    RoutingKey和BindingKey【模糊匹配】<br>    特点：<br>        单词<br>            被”.”隔开的独立字符串称为单词<br>            com.rabbiq.client（三个单词）<br>        分隔符 【 . 】<br>            分割字符串<br>        通配符【 # 】<br>            匹配任意多个单词（可以是0个）<br>            例如 com.hidden.client会被路由到 com.#<br>        通配符【 * 】<br>            匹配一个单词<br>            例如 <code>test.rabbitmq.client</code>会被路由到 <code>*.rabbitmq.client</code>上</p><p>4.headers<br>    不依赖路由键匹配，而是依赖消息的headers<br>    性能很差，不实用</p><p>声明一个交换机：</p><p>声明一个<code>Direct</code>类型的交换机</p><pre class="line-numbers language-csharp"><code class="language-csharp">channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>            exchange<span class="token punctuation">:</span> EXCHANGE_NAME<span class="token punctuation">,</span>            type<span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">,</span>            durable<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>            autoDelete<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            arguments<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="路由键-RoutingKey"><a href="#路由键-RoutingKey" class="headerlink" title="路由键 RoutingKey"></a>路由键 RoutingKey</h4><p>作用：指定消息路由规则</p><p>消息发送给交换机的时候，一般会指定一个<code>RoutingKey</code>（相当于邮件上的地址），<code>RoutingKey</code>需要与<code>交换机类型</code>和<code>BindingKey</code>联合使用才能最终生效。</p><h4 id="绑定-BindingKey"><a href="#绑定-BindingKey" class="headerlink" title="绑定 BindingKey"></a>绑定 BindingKey</h4><p>作用：RabbitMQ通过<code>绑定(Bind)</code>将<strong>交换机</strong>和<strong>队列</strong>关联起来，在绑定的时候一般指定一个<code>BindingKey</code></p><p><code>BindingKey</code>可以和<code>RoutingKey</code>相同。</p><h3 id="1-4-生产者完整代码"><a href="#1-4-生产者完整代码" class="headerlink" title="1.4 生产者完整代码"></a>1.4 生产者完整代码</h3><p>下例使用C#作为代码演示，这个例子中我们申明了一个<code>Direct</code>类型的交换机，并且用于队列和交换机绑定的<code>BindingKey</code>与<code>RoutingKey</code>相同，这样做的潜台词是：这里的 <code>RoutingKey</code>和<code>BindingKey</code> 是同个东西。在<code>direct</code>交换器类型下，<code>RoutingKey</code>和 <code>BindingKey</code> 需要完全匹配才能使用，所以上面代码中采用了此种写法会显得方便许多。</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//定义交换机名称、队列名称、路由键</span>        <span class="token keyword">const</span> <span class="token keyword">string</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"exchange_name"</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">string</span> QUEUE_NAME <span class="token operator">=</span> <span class="token string">"QUEUE_NAME"</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">string</span> ROUTING_KEY <span class="token operator">=</span> <span class="token string">"ROUTING_KEY"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明一个Direct类型交换机</span>        channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span>            exchange<span class="token punctuation">:</span> EXCHANGE_NAME<span class="token punctuation">,</span>            type<span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Direct<span class="token punctuation">,</span>            durable<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>            autoDelete<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            arguments<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span>            queue<span class="token punctuation">:</span> QUEUE_NAME<span class="token punctuation">,</span>            durable<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>            exclusive<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            autoDelete<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>            arguments<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过交换机名称、队列名称和绑定键 绑定交换机和队列 （可以看到这里绑定键就是路由键）</span>        channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> QUEUE_NAME<span class="token punctuation">,</span> exchange<span class="token punctuation">:</span> EXCHANGE_NAME<span class="token punctuation">,</span> ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发布消息至指定交换机，通过路由键路由消息至匹配的队列</span>        <span class="token keyword">string</span> message <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">BasicPublish</span><span class="token punctuation">(</span>            exchange<span class="token punctuation">:</span> EXCHANGE_NAME<span class="token punctuation">,</span>            routingKey<span class="token punctuation">:</span> ROUTING_KEY<span class="token punctuation">,</span>            basicProperties<span class="token punctuation">:</span> channel<span class="token punctuation">.</span><span class="token function">CreateBasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-Connection和Channel"><a href="#1-5-Connection和Channel" class="headerlink" title="1.5 Connection和Channel"></a>1.5 Connection和Channel</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_Connection.png" alt="Connection和Channel"></p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><ul><li>消费者和生产者通过Connection连接Broker</li><li>是一条TCP连接</li><li>多个Channel复用一个Connection</li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><ul><li>客户端可以创建AMQP信道（Channel）</li><li>信道被指派一个唯一的ID</li><li>建立在Connection之上的虚拟连接</li><li>RabbitMQ通过Channel处理AMQP指令</li></ul><p>引入信道的意义：</p><p>因为建立和关闭一个<code>Connection</code>开销很大，如果遇到使用高峰，性能瓶颈也随之显现，RabbitMQ采用类似<code>NIO</code>的做法，选择TCP复用，减少性能开销，也便于管理。</p><p>每个线程把持一个信道，如果当信道的流量本身就很大时，就需要开辟多个<code>Connection</code>，将信道均摊到这些<code>Connection</code>中。</p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>下面的代码演示了使用C#语言创建一个Connection和Channel</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">//创建连接工厂，提供用户名等信息</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>UserName <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>Password <span class="token operator">=</span> <span class="token string">"123465"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>VirtualHost <span class="token operator">=</span> <span class="token string">"virtual"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>HostName <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span>Port <span class="token operator">=</span> <span class="token number">2020</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建连接</span>        IConnection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">CreateConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建信道</span>        <span class="token keyword">var</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">CreateModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭Channel和Connection</span>        connection<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-RabbitMQ的运转流程"><a href="#1-6-RabbitMQ的运转流程" class="headerlink" title="1.6 RabbitMQ的运转流程"></a>1.6 RabbitMQ的运转流程</h3><h4 id="生产者发送消息过程"><a href="#生产者发送消息过程" class="headerlink" title="生产者发送消息过程"></a>生产者发送消息过程</h4><ol><li>生产者连接到<code>Broker</code>，建立一个连接<code>（Connection）</code>，开启一个信道<code>（Channel）</code></li><li>生产者声明一个<code>Exchange</code>，设置交换机属性，例如交换机类型，是否持久化等</li><li>生产者声明一个<code>Queue</code>，设置队列属性，例如是否排他，是否持久化等</li><li>生产者通过路由键将交换机和队列进行<code>绑定（Bind）</code></li><li>生产者发送消息至 <code>Broker</code>，消息的Label中包含路由键、交换机等信息</li><li>相应交换机根据消息的路由键来查找匹配对应的队列</li><li>如果找到，就将消息存入相应队列</li><li>没有找到，则根据生产者配置的属性选择<strong>丢弃</strong>或者<strong>回退</strong>消息给生产者</li><li>关闭信道</li><li>关闭连接</li></ol><h4 id="消费者接受消息过程"><a href="#消费者接受消息过程" class="headerlink" title="消费者接受消息过程"></a>消费者接受消息过程</h4><ol><li>消费者连接到<code>Broker</code>，并且建立一个连接，开启一个信道</li><li>消费者向<code>Broker</code>请求消费队列中的消息，可能会设置相应的回调函数，并且做一些准备工作</li><li>等待<code>Broker</code>回应并投递订阅的队列消息，消费者接收消息</li><li>消费者处理消息后确认<code>（ack）</code>消息。</li><li>RabbitMQ从队列重删除相应的已经被确认的消息</li><li>关闭信道</li><li>关闭连接</li></ol><h2 id="2-AMQP协议"><a href="#2-AMQP协议" class="headerlink" title="2.AMQP协议"></a>2.AMQP协议</h2><p>RabbitMQ是遵从<code>AMQP</code>协议的，换句话说，RabbitMQ就是<code>AMQP</code>协议的<code>Erlang</code>语言的实现，（当然RabbitMQ也支持STOMP、MQTT等协议），<code>AMQP</code>的模型架构和RabbitMQ的模型架构是一样的。</p><h3 id="2-1-AMQP的三层"><a href="#2-1-AMQP的三层" class="headerlink" title="2.1 AMQP的三层"></a>2.1 AMQP的三层</h3><h4 id="Module-Layer"><a href="#Module-Layer" class="headerlink" title="Module Layer"></a>Module Layer</h4><p>​    协议最高层<br>​    定义了一些供客户调用的命令，实现业务逻辑</p><h4 id="Session-Layer"><a href="#Session-Layer" class="headerlink" title="Session Layer"></a>Session Layer</h4><p>​    中间层<br>​    接受转发响应命令<br>​    为客户端与服务器之间提供可靠性同步机制和错误处理</p><h4 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h4><p>​    最底层<br>​    传输二进制数据流，提供帧处理、信道复用、错误检测和数据表示</p><h3 id="2-2-生产者AMQP详细流转过程"><a href="#2-2-生产者AMQP详细流转过程" class="headerlink" title="2.2 生产者AMQP详细流转过程"></a>2.2 生产者AMQP详细流转过程</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_AMQP1.png" alt="生产者流转过程"></p><h3 id="2-3-消费者AMQP详细流转过程"><a href="#2-3-消费者AMQP详细流转过程" class="headerlink" title="2.3 消费者AMQP详细流转过程"></a>2.3 消费者AMQP详细流转过程</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_AMQP2.png" alt="消费者流转过程"></p><h3 id="2-4-一些AMQP命令"><a href="#2-4-一些AMQP命令" class="headerlink" title="2.4 一些AMQP命令"></a>2.4 一些AMQP命令</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_AMQPCMD1.png" alt="cmd1"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_AMQPCMD2.png" alt="cmd2"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/RabbitMQ/RabbitMQ_AMQPCMD3.png" alt="cmd3"></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务完成时进行处理</title>
      <link href="/task2.html"/>
      <url>/task2.html</url>
      
        <content type="html"><![CDATA[<h2 id="任务完成时的处理"><a href="#任务完成时的处理" class="headerlink" title="任务完成时的处理"></a>任务完成时的处理</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>正在await一批任务，我们希望每个任务完成时对它做一些处理，另外，希望在任务一完成就<strong>立即</strong>进行处理，而不需要等待其它任务。</p><p>以下例子启动了三个延时任务，然后对每个任务进行<code>await</code></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span>TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">static</span> <span class="token keyword">async</span> Task <span class="token function">ProcessTaskAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//异步任务已经开始执行</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskA <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskB <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskC <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> tasks <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> taskA<span class="token punctuation">,</span>taskB<span class="token punctuation">,</span>taskC<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> task<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//调用流阻塞</span>                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最后输出3 1 5</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然<code>taskB</code>是最先完成的，但是当前这段代码仍是按照列表的顺序对任务进行打印 ，因为await是<code>调用流阻塞点</code>，await时发生<code>调用流阻塞</code>，foreach会等待当前task结束再继续运行。</p><p>我们希望按照任务完成的先后次序进行处理，不必等待其它任务。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们将处理结果抽离出来，重构后的代码并发地执行处理过程，而原始代码是一个接着一个地处理。</p><pre class="line-numbers language-csharp"><code class="language-csharp">       <span class="token comment" spellcheck="true">// 此时输出的是1 、 3、 5</span>        <span class="token keyword">static</span> <span class="token keyword">async</span> Task <span class="token function">ProcessTaskAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskA <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskB <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskC <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> tasks <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> taskA<span class="token punctuation">,</span> taskB<span class="token punctuation">,</span> taskC <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将每一个任务交与其它异步方法完成,也就是说三个任务并行处理</span>            <span class="token keyword">var</span> processingTasks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">from</span> t <span class="token keyword">in</span> tasks <span class="token keyword">select</span> <span class="token function">AwaitAndProcessAsync</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等待全部处理过程完成</span>            <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">WhenAll</span><span class="token punctuation">(</span>processingTasks<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 将处理过程提取出来</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;param name="task">&lt;/param></span>        <span class="token comment" spellcheck="true">/// &lt;returns>&lt;/returns></span>        <span class="token keyword">static</span> <span class="token keyword">async</span> Task <span class="token function">AwaitAndProcessAsync</span><span class="token punctuation">(</span>Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> task<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> task<span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以换一种写法</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">static</span> <span class="token keyword">async</span> Task <span class="token function">ProcessTaskAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskA <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskB <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> taskC <span class="token operator">=</span> <span class="token function">DelayAndReturnAsync</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//三个Task已经执行</span>        <span class="token keyword">var</span> tasks <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> taskA<span class="token punctuation">,</span> taskB<span class="token punctuation">,</span> taskC <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> processingTasks <span class="token operator">=</span> tasks<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token keyword">async</span> t <span class="token operator">=</span><span class="token operator">></span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//对每一个序列中的任务执行以下异步方法（这里序列还没有求值）</span>            <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> t<span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ToArray 显式“具体化”序列，即对序列求值，创建集合。三个任务是并行的</span>        <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">WhenAll</span><span class="token punctuation">(</span>processingTasks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法其实就是把之前<code>AwaitAndProcessAsync</code>中的结果处理流程写到了 <code>Select</code>中，和上一种写法结果一样。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async/await </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去哪儿项目开发</title>
      <link href="/qu-na-er-xiang-mu-kai-fa.html"/>
      <url>/qu-na-er-xiang-mu-kai-fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目是基于Vue.js开发的仿照去哪儿网移动端的前端项目。</p><p>样式使用的是stylus</p><p><strong>GitHub地址↓↓↓</strong></p><p><strong><a href="https://github.com/wukai319958/Vue_QunarProject" target="_blank" rel="noopener">https://github.com/wukai319958/Vue_QunarProject</a></strong></p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qunar1.jpg" alt="首页"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qunar3.jpg" alt="首页"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qunar2.jpg" alt="城市列表页"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qunar4.jpg" alt="详情页"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qunar5.jpg" alt="画廊"></p><h2 id="项目开发流程记录"><a href="#项目开发流程记录" class="headerlink" title="项目开发流程记录"></a>项目开发流程记录</h2><p><strong>开发流程放置在有道云笔记中：</strong></p><p><strong>文档：QunarProject</strong><br><strong>链接：<a href="http://note.youdao.com/noteshare?id=5a292db006f16499205b4e960a8f742a" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=5a292db006f16499205b4e960a8f742a</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> 去哪儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹性盒模型</title>
      <link href="/dan-xing-he-mo-xing.html"/>
      <url>/dan-xing-he-mo-xing.html</url>
      
        <content type="html"><![CDATA[<h1 id="弹性盒模型"><a href="#弹性盒模型" class="headerlink" title="弹性盒模型"></a>弹性盒模型</h1><p>本文参考至<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰老师的博客</a>，并加入了一些自己的理解</p><h2 id="一、创建flex布局"><a href="#一、创建flex布局" class="headerlink" title="一、创建flex布局"></a>一、创建flex布局</h2><p>任何一个容器都可以指定为 Flex 布局：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>行内元素也可以使用 Flex 布局。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> -webkit-flex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Safari */</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%80%BB%E4%BD%93%E5%9B%BE.png" alt="Flex项目"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、设置在容器上的属性"><a href="#三、设置在容器上的属性" class="headerlink" title="三、设置在容器上的属性"></a>三、设置在容器上的属性</h2><p>以下6个属性设置在容器上。</p><ul><li>flex-direction //项目的排列方向</li><li>flex-wrap // 轴线是否换行</li><li>flex-flow // 以上两个属性的简写形式</li><li>justify-content // 项目在main axis的对齐方式</li><li>align-items // 项目在交叉轴上的对齐方式</li><li>align-content // 多根轴线的对齐方式</li></ul><h3 id="3-1-flex-direction-项目排列方向"><a href="#3-1-flex-direction-项目排列方向" class="headerlink" title="3.1 flex-direction(项目排列方向)"></a>3.1 flex-direction(项目排列方向)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//决定主轴的方向（即项目的排列方向）。</span><span class="token punctuation">.</span>box <span class="token punctuation">{</span>  flex<span class="token operator">-</span>direction<span class="token operator">:</span> row <span class="token operator">|</span> row<span class="token operator">-</span>reverse <span class="token operator">|</span> column <span class="token operator">|</span> column<span class="token operator">-</span>reverse<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_direction2.jpg" alt="flex-direction"></p><h4 id="1-row-默认值"><a href="#1-row-默认值" class="headerlink" title="(1)row 默认值"></a>(1)row 默认值</h4><p>（默认值）主轴为水平方向，起点在左端。</p><h4 id="2-row-reverse"><a href="#2-row-reverse" class="headerlink" title="(2)row-reverse"></a>(2)row-reverse</h4><p>主轴为水平方向，起点在右端。</p><h4 id="3-column"><a href="#3-column" class="headerlink" title="(3)column"></a>(3)column</h4><p>主轴为垂直方向，起点在上沿。</p><h4 id="4-column-reverse"><a href="#4-column-reverse" class="headerlink" title="(4)column-reverse"></a>(4)column-reverse</h4><p>主轴为垂直方向，起点在下沿。</p><h3 id="3-2-flex-wrap-轴线如何换行"><a href="#3-2-flex-wrap-轴线如何换行" class="headerlink" title="3.2 flex-wrap(轴线如何换行)"></a>3.2 flex-wrap(轴线如何换行)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认情况下，项目都排在一条线（又称"轴线"）上。</span><span class="token comment" spellcheck="true">//flex-wrap属性定义，如果一条轴线排不下，如何换行。</span><span class="token punctuation">.</span>box<span class="token punctuation">{</span>  flex<span class="token operator">-</span>wrap<span class="token operator">:</span> nowrap <span class="token operator">|</span> wrap <span class="token operator">|</span> wrap<span class="token operator">-</span>reverse<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-nowrap-默认值"><a href="#1-nowrap-默认值" class="headerlink" title="(1) nowrap 默认值"></a>(1) nowrap 默认值</h4><p>(默认) 不换行</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_wrap1.png" alt="nowrap"></p><h4 id="2-wrap"><a href="#2-wrap" class="headerlink" title="(2) wrap"></a>(2) wrap</h4><p>换行，第一行在上方</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_wrap2.png" alt="wrap"></p><h4 id="3-wrap-reverse"><a href="#3-wrap-reverse" class="headerlink" title="(3)wrap-reverse"></a>(3)wrap-reverse</h4><p>换行，第一行在下方。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_wrap3.png" alt="wrap"></p><h3 id="3-3-flex-flow-简写形式"><a href="#3-3-flex-flow-简写形式" class="headerlink" title="3.3 flex-flow(简写形式)"></a>3.3 flex-flow(简写形式)</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;flex-direction> || &lt;flex-wrap><span class="token punctuation">;</span> // 默认是 row || nowrap<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-4-justify-content-主轴对齐方式"><a href="#3-4-justify-content-主轴对齐方式" class="headerlink" title="3.4  justify-content(主轴对齐方式)"></a>3.4  justify-content(主轴对齐方式)</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example4.png" alt="example4"></p><p>它可能有五个值，因为可能主轴的方向不同，具体的对其方式也不一样，以下假设主轴为从左到右→👉</p><h4 id="1-flex-start-默认值"><a href="#1-flex-start-默认值" class="headerlink" title="(1)flex-start 默认值"></a>(1)flex-start 默认值</h4><p>左对齐</p><h4 id="2-flex-end"><a href="#2-flex-end" class="headerlink" title="(2)flex-end"></a>(2)flex-end</h4><p>右对齐</p><h4 id="3-center"><a href="#3-center" class="headerlink" title="(3)center"></a>(3)center</h4><p>居中</p><h4 id="4-space-between"><a href="#4-space-between" class="headerlink" title="(4)space-between"></a>(4)space-between</h4><p>两端对齐，项目之间的间隔都相等。</p><h4 id="5-space-around"><a href="#5-space-around" class="headerlink" title="(5)space-around"></a>(5)space-around</h4><p>每个项目<strong>两侧的间隔</strong>相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><h3 id="3-5-align-items-交叉轴上如何对齐"><a href="#3-5-align-items-交叉轴上如何对齐" class="headerlink" title="3.5 align-items(交叉轴上如何对齐)"></a>3.5 align-items(交叉轴上如何对齐)</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_items.png" alt="align-items"></p><p>它可以有五个值，假设交叉轴的方向是从上到下：</p><h4 id="1-flex-start"><a href="#1-flex-start" class="headerlink" title="(1)flex-start"></a>(1)flex-start</h4><p>交叉轴的起点对齐。</p><h4 id="2-flex-end-1"><a href="#2-flex-end-1" class="headerlink" title="(2)flex-end"></a>(2)flex-end</h4><p>交叉轴重点对齐。</p><h4 id="3-center-1"><a href="#3-center-1" class="headerlink" title="(3)center"></a>(3)center</h4><p>交叉轴的中点对齐。</p><h4 id="4-baseline"><a href="#4-baseline" class="headerlink" title="(4)baseline"></a>(4)baseline</h4><p>项目的第一行文字的基线对齐。</p><h4 id="5-stretch-默认值"><a href="#5-stretch-默认值" class="headerlink" title="(5)stretch 默认值"></a>(5)stretch 默认值</h4><p>如果项目<strong>未设置高度或设为auto</strong>，将占满整个容器的高度。</p><h3 id="3-6-align-content（多根轴线对齐方式）"><a href="#3-6-align-content（多根轴线对齐方式）" class="headerlink" title="3.6 align-content（多根轴线对齐方式）"></a>3.6 align-content（多根轴线对齐方式）</h3><p>align-content属性只适用于<strong>多行</strong>的flex容器，并且当侧轴上有多余空间使flex容器内的flex线对齐。</p><p>align-items和align-content有相同的功能，不过不同点是它是用来让每一个单行的容器居中而不是让整个容器居中。</p><p>对于只有一行的flex元素，align-content是没有效果的，</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以下都在给子盒子设置了固定宽高的情况下：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example1.png" alt="example1"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example2.png" alt="example2"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example3.png" alt="example3"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_align-content.png" alt="align-content"></p><h4 id="1-flex-start-1"><a href="#1-flex-start-1" class="headerlink" title="(1)flex-start"></a>(1)flex-start</h4><p>与交叉轴的起点对齐。</p><h4 id="2-flex-end-2"><a href="#2-flex-end-2" class="headerlink" title="(2)flex-end"></a>(2)flex-end</h4><p>与交叉轴的终点对齐。</p><h4 id="3-center-2"><a href="#3-center-2" class="headerlink" title="(3)center"></a>(3)center</h4><p>与交叉轴的中点对齐。</p><h4 id="4-space-between-1"><a href="#4-space-between-1" class="headerlink" title="(4)space-between"></a>(4)space-between</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example6.png" alt="space-between"></p><p>与交叉轴两端对齐（上下），轴线之间的<strong>间隔平均</strong>分布。</p><h4 id="5-space-around-1"><a href="#5-space-around-1" class="headerlink" title="(5)space-around"></a>(5)space-around</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_example5.png" alt="space-around"></p><p>每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p><h4 id="6-stretch-默认值"><a href="#6-stretch-默认值" class="headerlink" title="(6)stretch 默认值"></a>(6)stretch 默认值</h4><p>轴线占满整个交叉轴。</p><h2 id="四、设置在项目中的属性"><a href="#四、设置在项目中的属性" class="headerlink" title="四、设置在项目中的属性"></a>四、设置在项目中的属性</h2><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order（项目的排列顺序）"><a href="#4-1-order（项目的排列顺序）" class="headerlink" title="4.1 order（项目的排列顺序）"></a>4.1 order（项目的排列顺序）</h3><p><code>order</code>属性定义项目的排列顺序。<strong>数值越小，排列越靠前</strong>，默认为0。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">order</span><span class="token punctuation">:</span> &lt;integer><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_order.png" alt="order"></p><h3 id="4-2-flex-grow-项目放大比例"><a href="#4-2-flex-grow-项目放大比例" class="headerlink" title="4.2 flex-grow(项目放大比例)"></a>4.2 flex-grow(项目放大比例)</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default 0 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_gorw.png" alt="flex-grow"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink-项目的缩小比例"><a href="#4-3-flex-shrink-项目的缩小比例" class="headerlink" title="4.3 flex-shrink(项目的缩小比例)"></a>4.3 flex-shrink(项目的缩小比例)</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default 1 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_shrink.jpg" alt="flex-grow"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p><strong>负值对该属性无效。</strong></p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-basis</span><span class="token punctuation">:</span> &lt;length> | auto<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default auto */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex-简写"><a href="#4-5-flex-简写" class="headerlink" title="4.5 flex 简写"></a>4.5 flex 简写</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> none | [ &lt;<span class="token string">'flex-grow'</span>> &lt;<span class="token string">'flex-shrink'</span>>? || &lt;<span class="token string">'flex-basis'</span>> ]<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/flex_start.png" alt="align-self"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 弹性盒模型 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《领域驱动设计》摘抄（三）</title>
      <link href="/ling-yu-qu-dong-she-ji-zhai-chao-san.html"/>
      <url>/ling-yu-qu-dong-she-ji-zhai-chao-san.html</url>
      
        <content type="html"><![CDATA[<h1 id="通过重构来加深了解"><a href="#通过重构来加深了解" class="headerlink" title="通过重构来加深了解"></a>通过重构来加深了解</h1><p>重构就是在不改变软件功能的前提下重新设计它。</p><p>我们面临的真正挑战是找到<strong>深层次</strong>的模型，这个模型不但能够捕捉到领域专家的微妙的关注点，还可驱动切实可行的设计。</p><p>要想成功地开发出实用的模型，需要注意以下3点。</p><ol><li>复杂巧妙的领域模型是可以实现的，也是值得我们去花费力气实现的。</li><li>这样的模型离开不断的重构是很难开发出来的，重构需要领域专家和热爱学习领域知识的开发人员密切参与进来。</li><li>要实现并有效地运用模型需要精通设计技巧。</li></ol><h2 id="柔性设计"><a href="#柔性设计" class="headerlink" title="柔性设计"></a>柔性设计</h2><p>软件的最终目的是为用户服务。但首先它必须为开发人员服务。</p><p>为了使项目能够随着开发工作的进行加速前进，而不会由于它自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改。这就是柔性设计<code>（supple design）</code>。</p><p>由于项目的时间期限和预算的缘故，很多设计一直就是僵化的。我也从未见过有哪个大型程序自始至终都是柔性的。但是，<strong>当复杂性阻碍了项目的前进时，就需要仔细修改最关键、最复杂的地方，使之变成一个柔性设计</strong>，这样才能突破复杂性带给我们的限制，而不会陷入遗留代码维护的麻烦中。</p><h3 id="1-1-Intention-Revealing-Interfaces"><a href="#1-1-Intention-Revealing-Interfaces" class="headerlink" title="1.1 Intention-Revealing Interfaces"></a>1.1 Intention-Revealing Interfaces</h3><p><code>Intention-Revealing Interfaces</code>的意思是<strong>释意接口</strong>，通俗讲就是接口的名字和里面的方法和属性必须能够完整表达出它所要达到的目的和意义。</p><p>当我们把概念显式地建模为类或方法时，为了真正从中获取价值，必须为这些程序元素<strong>赋予一个能够反映出其概念的名字</strong></p><p>类型名称、方法名称和参数名称组合在一起，共同形成了一个<code>Intention-Revealing Interfaces</code><strong>释意接口</strong></p>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《领域驱动设计》摘抄（二）</title>
      <link href="/ling-yu-qu-dong-she-ji-zhai-chao-er.html"/>
      <url>/ling-yu-qu-dong-she-ji-zhai-chao-er.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个扩展的示例"><a href="#一个扩展的示例" class="headerlink" title="一个扩展的示例"></a>一个扩展的示例</h1><p>这个示例将通过一个假想团队处理需求和实现问题，并且开发出一个<code>Model-Driven Design</code>来一步步介绍模型和设计的精化过程，期间会展示所遇到的阻力，以及如何运动DDD模式来解决它们。</p><h2 id="1-货物运输系统简介"><a href="#1-货物运输系统简介" class="headerlink" title="1. 货物运输系统简介"></a>1. 货物运输系统简介</h2><p>假设我们正在为一家货运公司开发新软件。最初的需求包括3项基本功能：</p><ol><li>跟踪客户货物的主要处理。</li><li>事先预约货物。</li><li>当货物达到其处理过程中的某个位置时，自动向客户寄送发票。</li></ol><p>这里，我们先从一个已包含所需概念并且形式合理的<strong>模型</strong>开始，我们将调整模型的细节来支持设计。</p><p><strong><em>使用通用语言：</em></strong></p><p>这个模型将领域只是组织起来，并未团队提供了<strong>一种语言（通用语言）</strong>，我们可以做出像下面这样的陈述：</p><pre class="line-numbers language-java"><code class="language-java">“一个Cargo（货物）涉及多个Customer（客户），每个Customer承担不同的角色。”“Cargo的运送目标已指定。”“由一系列满足Specification（规格）的Carrier Movement（运输动作）来完成运送目标。”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_1.png" alt="图1 表示货物领域模型的类图"></p><p>图1显示的模型中，每个对象都有明确的意义：</p><ul><li><code>Handling Event</code>(处理事件)，是对<code>Cargo</code>采取的不同操作，例如装上船或清关。这个类可以被细化为一个由<strong>不同种类的事件</strong>（如装货、卸货或由收货人提货）<strong>构成的</strong>层次结构。（XXX把XX货物装上了XXX运输工具等事件）</li><li><code>Delivery Specification</code>（运送规格）,这定义了运送目标，包括了目的地和到达时间等条件，也可能更复杂。它的职责本来可以由Cargo对象承担，但是将它抽象出来至少有以下三个优点：<ol><li>如果没有<code>Delivery Specification</code>，Cargo对象就要负责提供用于指定运送目标的所有属性和关联。这会把Cargo对象搞乱，使它难以理解或修改。</li><li>将其当作一个整体抽象出来时，这个抽象可以让我们轻松且安全的省略掉细节，如果<code>Delivery Specification</code>中还可能封装了其它的标准，但是我们不必将其展示出来。抽象出来可以很明白的告诉读者Cargo存在运输规格，但其细节并非思考的重点（事实上，过后当要修改细节“增加或者减少”也很容易）。</li><li><strong>这个模型具有更强的表达力</strong>，<code>Delivery Specification</code>清楚地表明：运送<code>Cargo</code>的具体方式没有明确规定，但它必须完成<code>Delivery Specification</code>中规定的目标。</li></ol></li><li><code>Customer</code>在一次运输中所承担的部分是按照<code>Role(角色)</code>来区分的，它可以shipper（托运人）、receiver（收货人）、payer（付款人）等，<code>Customer</code>和<code>Cargo</code>的关系是一对多的关系，一个<code>Customer</code>可能对应多个<code>Cargo</code>，但是一个<code>Cargo</code>只能由一个<code>Customer</code>来承担某个给定的角色。</li><li><code>Carrier Movement</code>表示某种Carrier（运输工具）（例如卡车或者船）执行的从一个<code>Location（地点）</code>到另一个<code>Location</code>的旅程（例如使用卡车将货物从杭州快递点运送到宁波快递中转站），通过Carrier的一个或者多个<code>Carrier Movement</code>就可以在不同地点之间转移。</li><li><code>Delivery History</code>（运送历史）,它与<code>Delivery Specification</code>正好相对，后者描述的是目标，<code>Delivery History</code>对象可以通过分析最后一次装货和卸货以及对应的<code>Carrier Movement</code>的目的地来计算货物的当前位置。成功的运送将会得到一个满足<code>Delivery Specification</code>目标的 <code>Delivery History</code>。</li></ul><p>以下是我通过一个淘宝物流信息对几个对象的解释：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_Explain.png" alt="图2 实际生活中的情形"></p><h2 id="2-隔离领域：引入应用层"><a href="#2-隔离领域：引入应用层" class="headerlink" title="2. 隔离领域：引入应用层"></a>2. 隔离领域：引入应用层</h2><p>为了防止领域的职责与系统的其他部分混杂在一起，我们应用<code>LAYERED ARCHITECTURE</code> (分层体系结构)把领域层划分出来。<br>我们可以将此系统的三个功能分配给三个应用层类：</p><ol><li>第一个类是<code>Tracking Query</code>（跟踪查询），它可以访问某个 Cargo过去和现在的处理情况。</li><li>第二个类是<code>Booking Application</code>（预订应用），它允许注册一个新的Cargo，并使系统准备<br>好处理它。</li><li>第三个类是<code>Incident Logging Application</code>（事件日志应用），它记录对Cargo的每次处理（提<br>供通过Tracking Query查找的信息）。</li></ol><h2 id="3-区分Entity和Value-Object"><a href="#3-区分Entity和Value-Object" class="headerlink" title="3. 区分Entity和Value Object"></a>3. 区分Entity和Value Object</h2><p>依次考虑每个对象，看看这个对象是必须被跟踪的实体还是仅表示一个基本值。</p><p><strong>Customer</strong></p><p>Customer对象表示一个人或一家公司，从一般意义上来讲它是一个实体。Customer对象显然有对用户来说很重要的<strong>标识</strong>，因此它在模型中是一个ENTITY 。</p><p><strong>Cargo</strong></p><p>两个完全相同的货箱必须要区分开，因此Cargo对象是ENTITY 。在实际情况中，所有运输公司会为每件货物分配一个跟踪ID。这个ID是自动生成的、对用户可见，而且在本例中，在预订时可能还要发送给客户。</p><p><strong>Handling Event和Carrier Movement</strong></p><p>我们关心这些独立事件是因为通过它们可以跟踪正在发生的事情。它们反映了真实世界的事件，而这些事件一般是不能互换的，因此它们是ENTITY 。每个Carrier Movement都将通过一个代码来识别，这个代码是从运输调度表得到的，Handling Event有一种唯一的识别方法，那就是使用Cargo ID、完成时间和类型的组合。例如，同一个Cargo不会在同一时间既装货又卸货。</p><p><strong>Location</strong></p><p>名称相同的两个地点并不是同一个位置。Location更可能是某种地理模型的一部分，这个模型根据运输航线和其他特定于领域的关注点将地点关联起来。因此，使用<strong>自动生成的内部任意标识符</strong>就足够了。</p><p><strong>Delivery History</strong></p><p>这是一个比较复杂的对象。Delivery History是不可互换的，因此它是ENTITY 。但Delivery History与Cargo是一对一关系，因此它实际上并没有自己的标识。它的标识来自于拥有它的Cargo。</p><p><strong>Delivery Specification</strong></p><p>如果有两个Cargo去往同一地点，那么它们可以用同一个Delivery Specification，但它们不会共用同一个Delivery History，尽管运送历史都是从同一个状态（空）开始。因此，Delivery Specification是VALUE OBJECT 。</p><p><strong>Role和其他属性</strong></p><p>Role表示了有关它所限定的关联的一些信息，但它没有历史或连续性。因此它是一个VALUE OBJECT ，可以在不同的Cargo/Customer关联中共享它。其他属性（如时间戳或名称）都是VALUE OBJECT 。</p><h2 id="4-设计运输领域中的关联"><a href="#4-设计运输领域中的关联" class="headerlink" title="4. 设计运输领域中的关联"></a>4. 设计运输领域中的关联</h2><p>图1中的所有关联都没有指定遍历方向，但双向关联在设计中容易产生问题。此外，遍历方向还常常反映出对领域的洞悉，使模型得以深化。<br><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_Location.png" alt="图3 类之间的关联"></p><p>这里有四个需要注意的地方：</p><ul><li>Cargo对Customer为多对一单向关联</li><li>Handing Event对Carrier Movement为多对一单向关联</li><li>Cargo对Delivery History为双向关联</li><li>Cargo-&gt;Delivery History-&gt;Handling Event-&gt;Cargo形成了一个循环引用</li></ul><p><strong>问题1：为什么Cargo对Customer为多对一单向关联？</strong></p><p>如果Customer对它所运送的每个Cargo都有直接引用，那么这样对长期、频繁托运货物的客户将会非常不便。此外，Customer这一概念并非只与Cargo相关。在大型系统中，Customer可能具有多种角色，以便与许多对象交互，因此最好不要将它限定为这种具体的职责。如果需要按照Customer来查找Cargo，那么可以通过数据库查询来完成。</p><p><strong>问题2：为什么Handing Event对Carrier Movement为多对一单向关联？</strong></p><p>我们的业务只需跟踪Cargo，因此只需从Handling Event遍历到Carrier Movement就能满足我们的业务需求。</p><p><strong>问题3：循环引用会造成的问题：</strong>※</p><p>模型中存在一个循环引用：Cargo知道它的Delivery History，Delivery History中保存了一系列的Handling Event，而Handling Event又反过来指向Cargo。</p><p>很多领域在逻辑上都存在循环引用，而且循环引用在设计中有时是必要的，但它们维护起来很复杂。</p><p>在选择实现时，应该避免把必须同步的信息保存在两个不同的地方，这样对我们的工作很有帮助。</p><p>对于这个例子，我们可以在初期原型中使用一个简单但不太健壮的实现——在Delivery History中提供一个<code>List</code>对象，并把Handling Event都放到这个<code>List</code>对象中，但是如果查询并不是很多，我们可以通过用Cargo通过键来执行数据库查询。如果这种查询很频繁，那么最好还是直接引用。</p><p>这种设计上的折中其实就是在实现的简单性和性能之间达成一个平衡。</p><h2 id="5-Aggregate边界"><a href="#5-Aggregate边界" class="headerlink" title="5. Aggregate边界"></a>5. Aggregate边界</h2><p>Customer、Location和Carrier Movement都有自己的标识，而且被许多Cargo共享，因此，它们在各自的AGGREGATE 中必须是根，Cargo也是一个明显的AGGREGATE 根，但把它的边界画在哪里还需要仔细思考一下。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_Aggregate.png" alt="图4 模型中的Aggregate边界"></p><p><strong>Cargo Aggregate:</strong></p><p>如上图所示，Cargo AGGREGATE 可以把一切因Cargo而存在的事物包含进来，这当中包括Delivery History、Delivery Specification和Handling Event。</p><p>这很适合Delivery History，因为没人会在不知道Cargo的情况下直接去查询Delivery History。因为Delivery History不需要直接的全局访问，而且它的标识实际上只是由Cargo 派生出的，因此很适合将Delivery History放在Cargo的边界之内，并且它也无需是一个AGGREGATE 根。</p><p>Delivery Specification是一个VALUE OBJECT ，因此将它包含在Cargo AGGREGATE 中也不复杂。</p><p>Handling Event就是另外一回事了，面已经考虑了两种与其有关的数据库查询，<strong>一种</strong>是当不想使用集合时，用查找某个Delivery History的Handling Event作为一种可行的替代方法，这种查询是位于Cargo AGGREGATE 内部的本地查询；<strong>另一种</strong>查询是查找装货和准备某次Carrier Movement时所进行的所有操作。在第二种情况中，处理Cargo的活动看起来是有意义的（即使是与Cargo本身分开来考虑时也是如此），<strong>因此Handling Event应该是它自己的AGGREGATE 的根。</strong></p><h2 id="6-选择REPOSITORY"><a href="#6-选择REPOSITORY" class="headerlink" title="6. 选择REPOSITORY"></a>6. 选择REPOSITORY</h2><p>在我们的设计中，有5个ENTITY 是AGGREGATE的根，因此在选择存储库时只需考虑这5个实体，因为其他对象都不能有REPOSITORY 。（只有Aggregate Root才能拥有Repository）</p><p><strong>我们必须根据确定这5个实体当中哪些确实需要REPOSITORY。</strong></p><p>要想通过<code>Booking Application</code>进行预订，用户最开始需要选择承担的角色（托运人、收货人等）的Customer,因此我们需要一个<code>Customer Repository</code>，我们还需要指定货物的目的地也就是Location,因此还要创建一个<code>Location Repository</code>.</p><p>用户需要通过<code>Activity Logging Application</code>来查找装货的Carrier Movement，因此需要一个<code>Carrier Movement Repository</code>，用户还必须告诉系统哪个Cargo已经完成了装货，因此还需要一个<code>Cargo Repository</code></p><h2 id="7-对象的创建"><a href="#7-对象的创建" class="headerlink" title="7. 对象的创建"></a>7. 对象的创建</h2><h4 id="7-1-Cargo的Factory和构造函数"><a href="#7-1-Cargo的Factory和构造函数" class="headerlink" title="7.1 Cargo的Factory和构造函数"></a>7.1 Cargo的Factory和构造函数</h4><p>即使为Cargo创建了复杂而精致的FACTORY，我们仍然需要有一个基本的构造函数。我们希望用构造函数来生成一个满足固定规则的对象，或者，就ENTITY 而言，至少保持其标识不变。</p><p>考虑到这些因素，我们可以在Cargo上创建一个Factory方法，如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Cargo <span class="token function">CopyPrototype</span><span class="token punctuation">(</span>string newTrackingID<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者可以为一个独立的Factory添加以下方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Cargo <span class="token function">NewCargo</span><span class="token punctuation">(</span>Cargo prototype<span class="token punctuation">,</span>string newTrackingID<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者我们还可以在独立的Factory的方法中把为新Cargo获取新（自动生成的）ID的过程封装起来，这样它就只需<br>要一个参数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Cargo <span class="token function">NewCargo</span><span class="token punctuation">(</span>Cargo prototype<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些Factory返回的结果是完全相同的，都是一个Cargo，其Delivery History为空，且Delivery Specification为null。<br>Cargo与Delivery History之间的双向关联意味着它们必须要<strong>互相指向对方</strong>才算是完整的，因此它们<strong>必须被一起</strong>创建出来。记住，Cargo是AGGREGATE 的根，而这个AGGREGATE 包含Delivery History。因此，我们可以用Cargo的构造函数或者Factory来创建Delivery History。<strong>Delivery History的构造函数将Cargo作为参数</strong>，这样就可以编写以下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Cargo</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span><span class="token punctuation">{</span>    trackingID<span class="token operator">=</span>id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//传入Cargo获得一个带有指向它自己的新的Delivery History的Cargo</span>    deliveryHistory<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DeliveryHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    customerRoles<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-添加Handling-Event"><a href="#7-2-添加Handling-Event" class="headerlink" title="7.2 添加Handling Event"></a>7.2 添加Handling Event</h4><p>货物在真实世界中的每次处理，都会有人使用<code>Incident Logging Application</code>来输入一条<code>Handling Event</code>记录。</p><p>每个类都必须有一个基本的构造函数。由于Handling Event是一个Entity，所以它具有唯一标识，<strong>所以必须把定义了其标识的所有属性传递给构造函数。</strong></p><p>Handling Event的唯一标识是通过<strong>Cargo的ID</strong>、<strong>完成时间</strong>和<strong>事件类型</strong>来组合成的。</p><p>综上，创建一个有效的Handling Event的基本构造函数是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HanlingEvent</span><span class="token punctuation">(</span>Cargo c<span class="token punctuation">,</span> String eventType<span class="token punctuation">,</span> Date timeStamp<span class="token punctuation">)</span><span class="token punctuation">{</span>    handled<span class="token operator">=</span>c<span class="token punctuation">;</span>    type<span class="token operator">=</span>eventType<span class="token punctuation">;</span>    completionTime<span class="token operator">=</span>timeStamp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就ENTITY 而言，那些<strong>非标识作用</strong>的属性通常可以<strong>过后再添加</strong>。</p><p>在本例中，Handling Event的所有属性都是在初始事务中设臵的，而且过后不再改变（纠正数据录入错误除外），因此针对每种事件类型，为Handling Event<strong>添加一个简单的FACTORY METHOD</strong> （并带有所有必要的参数）是很方便的做法，这还使得客户代码具有更强的表达力。</p><p>例如，loading event（装货事件）确实涉及一个Carrier Movement。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> HandlingEvent <span class="token function">newLoading</span> <span class="token punctuation">(</span>    Cargo c，CarrierMovement loadedonto<span class="token punctuation">,</span> Date timeStamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HandlingEvent result <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HandlingEvent</span> <span class="token punctuation">(</span>c，LOADING_EVENT<span class="token punctuation">,</span> timeStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token punctuation">.</span> <span class="token function">setCarrierMovement</span> <span class="token punctuation">(</span>loaded0nto<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模型中的Handling Event是一个抽象，它可以把各种具体的Handling Event类<strong>封装</strong>起来，包括<strong>装货、卸货、密封、存放</strong>以及其他与Carrier无关的活动，</p><p>它们可以被实现为多个子类，或者通过复杂的初始化过程来实现，也可以将这两种方法结合起来使用。</p><p><strong>通过在基类（Handling Event）中为每个类型添加FACTORY METHOD ，可以将实例创建的工作抽象出来，这样客户就不必了解实现的知识。FACTORY 会知道哪个类需要被实例化，以及应该如何对它初始化。</strong></p><p>遗憾的是，事情并不是这么简单。<strong>Cargo→Delivery History→History Event→Cargo</strong>这个引用循环使实例创建变得很复杂。如果没有创建这个反向指针，<strong>对象间将发生不一致</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_C.png" alt="图5 循环引用导致的问题"></p><h2 id="8-重构：Cargo-Aggregate的另一种设计"><a href="#8-重构：Cargo-Aggregate的另一种设计" class="headerlink" title="8. 重构：Cargo Aggregate的另一种设计"></a>8. 重构：Cargo Aggregate的另一种设计</h2><p><strong>建模和设计并不总是一个不断向前的过程</strong>，如果不经常进行重构，以便利用新的知识来改进模型和设计，那么建模和设计将会停滞不前。</p><p>由于添加Handling Event时需要更新Delivery History，而Delivery History又是Cargo Aggregate边界内的，更新Delivery History会在事务中牵涉Cargo Aggregate，因此，如果同一时间其他用户正在修改Cargo，那么Handling Event事务将会失败或者延迟，输入Handling Event是需要迅速完成的简单操作，因此能够在<strong>不发生争用的情况下</strong><br>输入Handling Event是一项重要的应用程序需求。这促使我们考虑另一种不同的设计。</p><p><strong>另一种设计：</strong></p><p>我们在Delivery History中可以不使用Handling Event的集合，而是用一个<strong>查询</strong>来代替它，这样在添加Handling Event时就不会在其自己的A GGREGATE 之外引起任何完整性问题。如此修改之后，这些事务就不再受到干扰。<br>如果有很多Handling Event<strong>同时</strong>被录入，而相对只有很少的查询，那么这种设计更加高效。使用查询来代替集合还可以减小维护Cargo和Handling Event之间循环引用一致性的难度。</p><p>为了使用查询，我们为Handling Event增加一个REPOSITORY 。Handling Event Repository将用来查询与特定Cargo有关的Event。(SELECT * FROM dbo.HandlingEvent,dbo.Cargo WHERE Cargo.xx=xx…)</p><p>此外，REPOSITORY 还可以提供优化的查询，以便更高效地回答特定的问题。例如，为了推断Cargo的当前状态，常常需要在Delivery History中查找最后一次报告的装货或卸货操作，如果这个查找操作被频繁地使用，那么就可以设计一个查询直接返回相关的Handling Event。</p><p>这样一来，Delivery History就不再有持久状态了，因此实际上无需再保留它。无论何时需要用Delivery History回答某个问题时，都可以将其生成出来。尽管在不断地重建这个Entity，是因为这些对象关联了相同的Cargo对象，而这个Cargo对象在Delivery History的各个化身间维护了连续性。</p><p><strong>但是</strong>，如果用户在使用系统时需要频繁地列出货物处理的全部历史，而不是偶尔查询最后一次处理，那么<strong>出于性能上的考虑，使用显式的集合比较有利。</strong></p><p>这些类型的修改和设计折中随处可见。但重要的一点是，这些修改和折中仅限于<strong>同一个模型内部</strong>。通过对VALUE 、ENTITY 以及它们的AGGREGATE 进行建模。</p><p><strong>将Delivery History中的Handling Event集合实现为一个查询，这样可以使Handling Event的插入变得简单，而且不会与Cargo AGGREGATE 发生争用</strong></p><h2 id="9-引入新需求：配额检查"><a href="#9-引入新需求：配额检查" class="headerlink" title="9. 引入新需求：配额检查"></a>9. 引入新需求：配额检查</h2><p>现在要添加第一批重要的新功能。</p><p>在这个假想的运输公司中，销售部门使用其他软件来管理客户关系、销售计划等。其中有一项功能是<strong>效益管理</strong>（yield management），利用此功能，公司可以根据货物类型、出发地和目的地或者任何可作为分类名输入的其他因素来制定不同类型货物的运输配额。这些配额构成了各类货物的运输量目标，这样利润较低的货物就不会占满货舱而导致无法运输利润较高的货物，同时避免预订量不足（没有充分利用运输能力）或过量预订（导致频繁地发生货物碰撞，最终损害客户关系）。</p><p>现在，他们希望把这个功能集成到预订系统中。这样，<strong>当客户进行预订时，可以根据这些配额来检查是否应该接受预订。配额检查所需的信息保存在两个地方，Booking Application必须通过查询这些信息才能确定接受或拒绝预订。</strong></p><p>下图给出了一个大体的信息流草图。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_another1.png" alt="图6"></p><p>由上图可知，Booking Application要通过<code>Cargo Repository</code>和<code>Sales Management System</code>这两个地方才能确定是否要接受预定。</p><h4 id="9-1-连接两个系统"><a href="#9-1-连接两个系统" class="headerlink" title="9.1 连接两个系统"></a>9.1 连接两个系统</h4><p>销售管理系统（Sales Management System）并不是根据这里所使用的模型编写的。如果我们的Booking Application直接与其交互，那么我们的应用程序必须要适应另一个系统的设计，如果另一个系统发生更改，我们必须修改Booking Application来应对其更改，这将很难保持一个清晰的<code>MODEL -DRIVEN DESIGN</code>，而且会混淆<code>UBIQUITOUS LANGUAGE</code>。</p><p>这时候，我们向这两个系统之间添加一个<code>Anticorruption Layer</code>(大概就是隔离层的意思..)，创建一个类，这个类充当我们的模型和销售管理之间的翻译（利用外观模式或者适配器模式可以做到），并根据我们领域模型重新对这些特性进行抽象。</p><p>让我们为每个需要从其他系统获得的配额功能定义一个<strong>SERVICE</strong> 。我们用一个名为<code>Allocation Checker</code>（配额检查器）的类来实现这些<strong>SERVICE</strong> ，这个类名反映了它在系统中的职责。</p><h4 id="9-2-进一步完善模型：划分业务"><a href="#9-2-进一步完善模型：划分业务" class="headerlink" title="9.2 进一步完善模型：划分业务"></a>9.2 进一步完善模型：划分业务</h4><p>那么提供什么样的接口才能回答“这种类型的货物可以接受多少预订”这个问题呢？问题的复杂之处在于<strong>定义Cargo的“类型”</strong>是什么，因为我们的领域模型尚未对Cargo进行分类。<br>《分析模式》[Fowler 1996]一书介绍了一种用于解决这类问题的模式：<code>ENTERPRISE SEGMENT</code> （企业部门单元）</p><p><a href="http://www.uml.org.cn/sjms/2004092403.htm#_ftn1" target="_blank" rel="noopener">更多关于Enterprise Segment的知识请点击(￣▽￣)</a></p><p>ENTERPRISE  EGMENT 是一组维度，它们定义了一种对业务进行划分的方式（例如地区维度、销售类型维度等）。这些维度可能包括我们在运输业务中已经提到的所有划分方法，也包括时间维度，如月初至今（month to date）在我们的配额模型中使用这个概念，可以增强模型的表达力，并简化接口。</p><p>这样，我们的领域模型和设计中就增加了一个名为Enterprise Segment的类，它是一个VALUE OBJECT ，每个Cargo都必须获得一个Enterprise Segment类。<br>于是我们可以得到以下草图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_2.png" alt="图7 引入Enterprise Segment"></p><p>其中<code>Allocation Checker</code>充当了一个<code>ANTICORRUPTION LAYER</code> ，它在我们的领域模型中展现了一个到销售管理系统的可选接口<br><code>Allocation Checker</code>将充当<code>Enterprise Segment</code>与外部系统的类别名称之间的<strong>翻译</strong>，<code>Cargo Repository</code>还必须提供一种基于<code>Enterprise Segment</code>的查询。</p><p>但是这种设计还存在几个问题：</p><ol><li>我们给Booking Application分配了一个<strong>不该由它来执行的工作</strong>，那就是对如下规则的应用：“如果Enterprise Segment的配额大于已预订的数量与新 Cargo数量的和，则接受该Cargo。”<strong>执行业务规则是领域层的职责，而不应在应用层中执行。</strong></li><li>没有清楚地表明Booking Application是如何得出Enterprise Segment的</li></ol><p><strong>这两个职责看起来都属于Allocation Checker</strong>。通过修改接口就可以将这两个服务分离出来，这样交互就更整洁和明显了。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Example_4.png" alt="图8 转移职责"></p><p>由上图可知，领域职责从Booking Application转移到了Allocation Checker中。</p><p>这种集成只有一条严格的约束，那就是有些维度是不能被Sales Management System使用的。</p><p>在我们这个设计中，Cargo Repository只需处理Enterprise Segment，而且销售系统中的更改只影响到Allocation Checker，而Allocation Checker可以被看作是一个FACADE &lt;外观模式&gt;）。</p><h4 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h4><p>我们通过使用<code>Anticorruption Layer</code>、<code>Service</code>、<code>Enterprise Segment</code>之后，我们已经干净利落地把Sales Management System的功能集成到我们的预定系统中，从而使领域更加丰富。</p><p><strong>还有最后一个设计问题：为什么不把获取<code>Enterprise Segment</code>的职责交给<code>Cargo</code>呢？</strong></p><p>为了用有利于业务策略的维度进行划分，我们需要<strong>任意</strong>定义Enterprise Segment.</p><p>出于不同的目的，可能需要对相同的ENTITY 进行不同的划分。出于<strong>预订配额</strong>的目的，我们需要根据特定的Cargo进行划分；但如果是出于<strong>税务会计</strong>的目的时，可能会采取一种完全不同的Enterprise Segment划分方式。甚至当执行<strong>新的销售策略</strong>而对Sales Management System进行重新配置时，配额的Enterprise Segment划分也可能会发生变化。</p><p>如此，Cargo就必须了解Allocation Checker，而这完全不在其概念职责范围之内。</p><p>而且得出特定类型Enterprise Segment所需使用的方法会<strong>加重Cargo的负担</strong>。</p><p>因此，正确的做法是让那些知道划分规则的对象来承担获取这个值的职责，<strong>而不是把这个职责施加给包含具体数据（那些规则就作用于这些数据上）的对象</strong>。另一方面，这些规则可以被分离到一个独立的Strategy（策略类）对象中，然后将这个对象传递给Cargo，以便它能够得出一个Enterprise Segment。这种解决方案似乎超出了这里的需求，但它可能是之后设计的一个选择，而且应该不会对设计造成很大的破坏。</p>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《领域驱动设计》摘抄（一）</title>
      <link href="/ling-yu-qu-dong-she-ji-zhai-chao.html"/>
      <url>/ling-yu-qu-dong-she-ji-zhai-chao.html</url>
      
        <content type="html"><![CDATA[<h2 id="分离领域"><a href="#分离领域" class="headerlink" title="分离领域"></a>分离领域</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="分层模型"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_%E8%81%8C%E8%B4%A3.png" alt="各层职责"></p><h3 id="将各层关联起来"><a href="#将各层关联起来" class="headerlink" title="将各层关联起来"></a>将各层关联起来</h3><p><em><code>摘抄 P:46</code></em></p><p>各层之间是松散连接的，层与层的依赖关系只能是单向的。<strong>上层可以直接使用或操作下层元素</strong>，方法是通过调用下层元素的<strong>公共接口</strong>，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素进行通信（不只是回应直接查询），则需要采用另一种通信机制，使用架构模式来连接上下层，如<strong>回调模式或者Observers模式</strong>。</p><p style="color:red;font-weight:800">需要解决：如何实现使用回调模式或者Observers模式使下层结构调用上层结构？</p>*`摘抄 P:48`*<p>领域模型是一系列的集合。“领域层”则是领域模型以及所有与其直接相关的设计元素的表现，它由业务逻辑的设计和实现组成。<strong>将领域实现独立出来是领域驱动设计的前提</strong>。</p><p style="color:blue;font-weight:800">思考：把领域隔离出来的最大好处就是可以真正专注于领域设计，而不用考虑其它方面。</p>*`摘抄 P:49`*<p>领域驱动设计只有应用在大型项目上才能产生最大的收益，不是所有的项目都是大型项目，也不是所有的团队都能掌握那些技巧。</p><p><code>SMART UI</code>是DDD的反模式，它会在用户界面中实现所有的逻辑规则，并在其中嵌入业务规则…这种模式适合只需要提供简单的功能，以数据输入和显示为主，设计业务规则很少，团队中没有高级对象建模师。</p><p style="color:blue;font-weight:800">思考：要根据实际情况选择是否使用DDD,简单的项目引入DDD只会使项目变得复杂。</p><h2 id="软件中所表示的模型"><a href="#软件中所表示的模型" class="headerlink" title="软件中所表示的模型"></a>软件中所表示的模型</h2><p><em><code>摘抄 P:51</code></em></p><p>模型表示的三种模式：<code>Entity</code>、<code>Value Object</code>和<code>Service</code></p><p><code>Entity</code>与<code>Value Object</code>之间的根本区别在于：<code>Entity</code>中的对象是用来表示某种具有<strong>连续性</strong>和<strong>标识</strong>的事物的（可以跟踪它所经历的不同状态、甚至可以跨不同的实现跟踪它）而<code>Value Object</code>是用于描述某个事物的某种<strong>状态属性</strong>的。</p><p>领域中还有一些方面<strong>适合用动作或操作</strong>来表示，这比用对象表示更加清楚。这些方面最好用<code>Service</code>来表示，而不应把操作的责任强加到<code>Entity</code>或者<code>Value Object</code>上，尽管这样做稍微违背了面向对象的建模传统。<strong><code>Service</code>是应客户端请求来完成某事</strong>，在软件的技术层中有很多<code>Service</code>。在领域中也可以使用<code>Service</code>，<strong>当软件必须实现的某项无状态的活动进行建模时</strong>，就可以将活动作为一项<code>Service</code>。</p><p style="color:blue;font-weight:800">思考：明确地选择这两种模式中的一个来定义对象，有利于减少歧义，并帮我们做出特定的选择，这样才能得到健壮的设计。</p>*`摘抄 P:53`*<p>限定多对多关联的遍历方向可以有效地将其实现简化为一对多关联，从而得到一个简单得多的设计，</p><p style="color:red;font-weight:800">需要解决：如何限定？？</p><h3 id="模式：Entity（又称为Reference-Object引用对象）"><a href="#模式：Entity（又称为Reference-Object引用对象）" class="headerlink" title="模式：Entity（又称为Reference Object引用对象）"></a>模式：Entity（又称为Reference Object引用对象）</h3><p><em><code>摘抄 P:57、58</code></em></p><p>很多对象不是通过它们的属性定义的，而是通过<strong>连续性和标识</strong>定义的。</p><p>一个人（继续使用非技术示例）有一个标识，这个标识会陪伴他走完一生（甚至死后）。这个人的物理属性会发生变化，最后消失。他的名字可能改变，财务关系也会发生变化，<strong>没有哪个属性是一生不变的，但标识却是永久的</strong>。我跟我5岁时是同一个人吗？ 这种听上去像是纯哲学的问题在探索有效的领域模型时非常重要。稍微变换一下问题的角度：<strong>应用程序的用户是否关心现在的我和5岁时的我是不是同一个人？</strong></p><p>一些对象主要不是由它们的属性定义的。它们实际上表示了一条“标识线”（A Thread of Identity），<strong>这条线跨越时间，而且常常经历多种不同的表示</strong>。有时，这样的对象必须与另一个具有不同属性的对象相匹配。而有时一个对象必须与具有相同属性的另一个对象区分开。错误的标识可能会破坏数据。</p><p>主要由标识定义的对象被称作<code>ENTITY</code>。<code>ENTITY</code>（实体）有特殊的建模和设计思路。它们具有生命周期，<strong>这期间它们的形式和内容可能发生根本改变，但必须保持一种内在的连续性</strong>。</p><p>为了有效地跟踪这些对象，<strong>必须定义它们的标识</strong>。它们的类定义、职责、属性和关联必须由其标识来决定，而不依赖于其所具有的属性。</p><p style="color:blue;font-weight:800">    思考：ENTITY 可以是任何事物，只要满足两个条件即可：</p><ol><li>它在整个生命周期中具有连续性</li><li>它的区别并不是由那些对用户非常重要的属性决定的</li></ol><p><em><code>摘抄 P:59</code></em></p><p>现实世界中的同一个事物在领域模型中可能需要表示为ENTITY ，也可能不需要表示为ENTITY 。</p><p style="color:blue;font-weight:800">思考：一个事物是否为Entity应该是由上下文来决定的。</p>*`摘抄 P:61`*<p>当对象属性没办法形成真正唯一键时，另一种经常用到的解决方案是为每个实例附加一个在类中唯一的符号（如一个数字或字符串）。一旦这个ID符号被创建并存储为E NTITY 的一个属性，必须将它指定为不可变的。</p><p>ID通常是由系统自动生成的。生成算法必须确保ID在系统中是唯一的。</p><p style="color:blue;font-weight:800">思考：将GUID作为Entity的唯一标识。</p><h3 id="模式：Value-Object"><a href="#模式：Value-Object" class="headerlink" title="模式：Value Object"></a>模式：Value Object</h3><p><em><code>摘抄 P:62</code></em></p><p>很多对象没有概念上的标识，它们描述了一个事务的<strong>某种特征</strong>。</p><p>用于描述领域的某个方面而本身没有概念标识的对象称为<code>VALUE OBJECT</code> （值对象）。</p><p><code>VALUE OBJECT</code> 被实例化之后用来表示一些设计元素，对于这些设计元素，<strong>我们只关心它们是什么，而不</strong><br><strong>关心它们是谁。</strong></p><p><em><code>摘抄 P:63</code></em></p><p>如何判定一个对象是Value Object还是Entity：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_ValueObject.png" alt="Value Object"></p><p><em><code>摘抄 P:63</code></em></p><p>VALUE OBJECT 可以是其他对象的集合。</p><p>VALUE OBJECT 甚至可以引用ENTITY。</p><p>VALUE OBJECT 经常作为参数在对象之间传递消息。它们常常是临时对象，在一次操作中被创建，然后丢弃。</p><p>VALUE OBJECT 可以用作 NTITY （以及其他VALUE ）的属性。我们可以把一个人建模为一个具有标识的ENTITY ，但这个人的名字是一个VALUE 。</p><p><em><code>摘抄 P:64</code></em></p><p>当我们<strong>只关心一个模型元素的属性时</strong>，应把它归类为VALUE OBJECT 。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。<strong>VALUE OBJECT 应该是不可变的</strong>。不要为它分配任何标识，而且不要把它设计成像ENTITY 那么复杂。</p><p style="color:blue;font-weight:800">思考：Value Object应该是不可变的，如果属性的值发生改变，我们应该使用一个不同的VALUE OBJECT ，而不是修改现有的VALUE OBJECT 。</p><p style="color:blue;font-weight:800">通过复制和共享值对象可以优化系统性能。</p><p><em><code>摘抄 P:66</code></em></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_ValueObject%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7.png" alt="何时允许可变"></p><p style="color:blue;font-weight:800">思考：定义VALUE OBJECT 并将其指定为不可变的是一条一般规则，这样做是为了避免在模型中产生不必要的约束，从而让开发人员可以单纯地从技术上优化性能。</p><h3 id="模式：Service"><a href="#模式：Service" class="headerlink" title="模式：Service"></a>模式：Service</h3><p><em><code>摘抄 P:67</code></em></p><p>有时，对象不是一个事物。在某些情况下，最清楚、最实用的设计会包含一些<strong>特殊的操作</strong>，这些操作从概念上讲不属于任何对象。与其把它们强制地归于哪一类，不如顺其自然地在模型中引入一种新的元素，这就是<strong>SERVICE</strong> （服务）。</p><p><em><code>摘抄 P:68</code></em></p><p>SERVICE 是作为接口提供的一种操作，它在模型中是独立的，它不像ENTITY 和VALUE OBJECT那样具有封装的状态。<br>所谓SERVICE ，它强调的是与其他对象的关系。与ENTITY 和VALUE OBJECT 不同，它只是定义了<strong>能够为客户做什么。</strong></p><p>好的S ERVICE 有以下<strong>3个</strong>特征。<br>(1) 与领域概念相关的操作不是ENTITY 或V ALUE OBJECT 的一个自然组成部分。<br>(2) 接口是根据领域模型的其他元素定义的。<br>(3) 操作是<strong>无状态</strong>的。</p><p>这里所说的无状态是指<strong>任何客户都可以使用某个SERVICE 的任何实例</strong>，而不必关心该实例的历史状态。</p><p style="color:blue;font-weight:800">思考：当领域中的某个重要的过程或转换操作不是ENTITY或VALUE OBJECT的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其声明为SERVICE。</p>*`摘抄 P:69`*<p>很多领域或应用层SERVICE 是在ENTITY 和V ALUE OBJECT 的基础上建立起来的，它们的行为类似于<strong>将领域的一些潜在功能组织起来以执行某种任务的脚本。</strong></p><p><em><code>摘抄 P:70</code></em></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_%E5%88%92%E5%88%86Service.png" alt="划分Service"></p><p style="color:blue;font-weight:800">思考：领域层的Service涉及业务规则，并且是无状态的</p>明智地引入领域层服务有助于在应用层和领域层之间保持一条明确的界限。防止领域知识和业务逻辑蔓延到应用程或者用户层界面代码当中。<h3 id="模式：Module（也称为Package）"><a href="#模式：Module（也称为Package）" class="headerlink" title="模式：Module（也称为Package）"></a>模式：Module（也称为Package）</h3><p><em><code>摘抄 P:72</code></em></p><p>像领域驱动设计中的其他元素一样，MODULE 是一种表达机制。MODULE 的选择应该取决于被划分到模块中的对象的意义。<br>你将一些类放到MODULE 中时，相当于告诉下一位看到你的设计的开发人员要把这些类放在一起考虑。如果说模型讲述了一个故事，那么MODULE 就是这个故事的各个章节。</p><h2 id="领域对象的生命周期"><a href="#领域对象的生命周期" class="headerlink" title="领域对象的生命周期"></a>领域对象的生命周期</h2><p><em><code>摘抄 P:80</code></em></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="领域对象的生命周期"></p><p>管理领域对象时面临诸多的挑战，稍有不慎就会偏离<code>MODEL -DRIVEN DESIGN</code>的轨道。</p><p>主要的挑战有以下两类。<br>(1) 在整个生命周期中维护完整性。<br>(2) 防止模型陷入管理生命周期复杂性造成的困境当中。</p><h3 id="模式-：Aggregate"><a href="#模式-：Aggregate" class="headerlink" title="模式 ：Aggregate"></a>模式 ：Aggregate</h3><p><em><code>摘抄 P:82</code></em></p><p>首先，我们需要用一个<strong>抽象</strong>来封装模型中的引用。<code>AGGREGATE</code>就是一组相关对象的<strong>集合</strong>，我们把它作为数据修改的<strong>单元</strong>。每个<code>AGGREGATE</code>都有一个<code>根（root）</code>和一个<code>边界（boundary）</code>。 </p><p>边界定义了<code>AGGREGATE</code>的内部都有什么。</p><p>根则是<code>AGGREGATE</code>所包含的一个<strong>特定</strong><code>ENTITY。</code></p><p>对<code>AGGREGATE</code>而言，<strong>外部对象只可以引用根</strong>，而边界内部的对象之间则可以互相引用。除根以外的其他<code>ENTITY</code>都有本地标识，但这些标识只在<code>AGGREGATE</code>内部才需要加以区别，<strong>因为外部对象除了根<code>ENTITY</code>之外看不到其他对象。</strong></p><p style="color:blue;font-weight:800">思考：解释开发的时候该如何定义Aggregate。</p><p><em><code>摘抄 P:83-84</code></em></p><h3 id="※Aggregate的一组固定规则："><a href="#※Aggregate的一组固定规则：" class="headerlink" title="※Aggregate的一组固定规则："></a><strong>※Aggregate的一组固定规则：</strong></h3><ul><li>根<code>ENTITY</code> 具有全局标识，它最终负责检查固定规则。</li><li>边界内的<code>ENTITY</code> 具有本地标识，这些标识只在<code>AGGREGATE</code> 内部才是唯一的。</li><li><code>AGGREGATE</code> 外部的对象不能引用除根<code>ENTITY</code>之外的任何内部对象。根<code>ENTITY</code>可以把对内部<code>ENTITY</code> 的引用传递给它们，但这些对象只能临时使用这些引用，而不能保持引用。</li><li>根可以把一个<code>VALUE OBJECT</code>的副本传递给另一个对象，而不必关心它发生什么变化，因为它只是一个<code>VALUE</code> ，不再与<code>AGGREGATE</code> 有任何关联。 </li><li>只有<code>AGGREGATE</code>的根才能直接通过数据库查询获取。所有其他对象必须通过<strong>遍历关联</strong>来发现。</li><li><code>AGGREGATE</code> 内部的对象可以保持对其他<code>AGGREGATE</code> 根的引用。</li><li>删除操作必须一次删除<code>AGGREGATE</code>边界之内的所有对象。（利用垃圾收集机制，这很容易做到。由于除根以外的其他对象都没有外部引用，因此删除了根以后，其他对象均会被回收）</li><li>当提交对<code>AGGREGATE</code>边界内部的任何对象的修改时，整个<code>AGGREGATE</code> 的所有固定规则都必须被满足</li></ul><p style="color:red;font-weight:800">问题：在代码中该如何体现？</p><h3 id="模式-：Factory"><a href="#模式-：Factory" class="headerlink" title="模式 ：Factory"></a>模式 ：Factory</h3><p><em><code>摘抄 P:89</code></em></p><p>当创建一个对象或创建整个<code>AGGREGATE</code> 时，如果创建工作很复杂，或者暴露了过多的内部结构，则可以使用<code>FACTORY</code>进行封装。 </p><h3 id="Factory的两种情况"><a href="#Factory的两种情况" class="headerlink" title="Factory的两种情况"></a>Factory的两种情况</h3><p><em><code>摘抄 P:90</code></em></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Factory.png" alt="与Factory的基本交互"></p><p><em><code>摘抄 P:91</code></em></p><p>应该将创建复杂对象的实例和<code>AGGREGATE</code>的职责转移给<strong>单独的对象</strong>，这个对象本身可能没有承担领域模型中的职责，但它仍是领域设计的一部分。提供一个封装所有复杂装配操作的接口，而且这个接口<strong>不需要客户引用</strong>要被实例化的对象的具体类。在创建<code>AGGREGATE</code>时要把它作为一个整体，并确保它满足固定规则。</p><p><em><code>摘抄 P:92</code></em></p><p>如果需要向一个已存在的AGGREGATE 添加元素，可以在AGGREGATE 的根上创建一个<strong>FACTORY METHOD</strong></p><p>如下图所示：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Factory_FactoryMethod.png" alt></p><p>另一个示例是在一个对象上使用<code>FACTORY METHOD</code>，这个对象与生成另一个对象密切相关，但它<strong>并不拥有</strong>所生成的对象。<br>如下图所示：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Factory_NotContainEntity.png" alt="创建不属于自己的Entity"></p><p><code>FACTORY METHOD</code> 生成一个<code>ENTITY</code> ，但这个<code>ENTITY</code> 并不属于<code>FACTORY</code>所在的<code>AGGREGATE</code>，<code>Trade Order</code>不属于<code>Brokerage Account</code>所在的<code>AGGREGATE</code> ，因为它从一开始就与交易执行应用程序进行交互，所以把它放在<code>Brokerage Account</code>中只会碍事。尽管如此，让<code>Brokerage Account</code>负责控制<code>Trade Order</code>的创建却是很自然的事情。</p><p style="color:blue;font-weight:800">思考：Factory的两种模式，一种是在根上添加创建Aggregate内部对象的Create方法，另一种是创建另一个密切对象，但是创建出的对象并不包含在根内部。这样的好处可以避免客户和具体类之间的耦合。</p><p><em><code>摘抄 P:93</code></em></p><p>当有些细节需要隐藏（无论要隐藏的是具体实现还是构造的复杂性）而又找不到合适的地方来隐藏它们时，必须创建一个<strong>专用的</strong><code>FACTORY</code>对象或<code>SERVICE</code></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Factory_Duli.png" alt="independent factory"></p><p style="color:blue;font-weight:800">思考：如果AGGREGATE 内部的某个对象需要一个FACTORY ，而这个FACTORY 又不适合在AGGREGATE 根上创建，那么应该构建一个独立的FACTORY 。</p><p><em><code>摘抄 P:93</code></em></p><h3 id="有些情况下只需要使用构造函数"><a href="#有些情况下只需要使用构造函数" class="headerlink" title="有些情况下只需要使用构造函数"></a>有些情况下只需要使用构造函数</h3><ul><li>该类没有通过接口实现多态性</li><li>构造并不复杂</li><li>客户可以访问对象的所有属性，因此向客户公开的构造函数中没有嵌套的对象创建</li><li>公共构造函数必须遵守与FACTORY 相同的规则：它必须是原子操作，而且要满足被创建对象的所有固定规则。</li></ul><h3 id="接口的设计"><a href="#接口的设计" class="headerlink" title="接口的设计"></a>接口的设计</h3><ul><li>每个操作都必须是原子的（必须在一次与Factory的交互中把创建对象所需的信息传递给Factory，同时需要确定创建失败时应该执行什么操作）</li><li>Factory将与其参数发生耦合（耦合程度取决于对参数的处理）</li></ul><h3 id="重建已存储对象的Factory"><a href="#重建已存储对象的Factory" class="headerlink" title="重建已存储对象的Factory"></a>重建已存储对象的Factory</h3><p><em><code>摘抄 P:95</code></em></p><p>重建对象的FACTORY 与用于创建对象的FACTORY 很类似，主要有以下两点不同：</p><ol><li><strong>用于重建对象的ENTITY  FACTORY 不分配新的跟踪ID</strong>。如果重新分配ID，将丢失与先前对象的连续性。因此，在重建对象的FACTORY 中，<strong>标识属性必须是输入参数的一部分。</strong></li><li><strong>当固定规则未被满足时，重建对象的FACTORY 采用不同的方式进行处理</strong><ul><li>使用ORM技术重建对象</li></ul></li></ol><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Factory_OrmFactory.png" alt="对象映射技术重建对象"></p><p style="color:blue;font-weight:800">思考：FACTORY 通常不表示模型的任何部分，但它们是领域设计的一部分，能够使对象更明确地表示出模型,FACTORY 封装了对象创建和重建时的生命周期转换</p><h3 id="模式：REPOSITOR"><a href="#模式：REPOSITOR" class="headerlink" title="模式：REPOSITOR"></a>模式：REPOSITOR</h3><p><em><code>摘抄 P:99</code></em></p><h3 id="为什么需要Repository？"><a href="#为什么需要Repository？" class="headerlink" title="为什么需要Repository？"></a>为什么需要Repository？</h3><p><strong>客户需要一种有效的方式来获取对已存在的领域对象的引用</strong>。如果基础设施提供了这方面的便利，那么开发人员可能会增加很多可遍历的关联，这会使模型变得非常混乱。另一方面，开发人员可能使用查询从数据库中提取他们所需的数据，或是直接提取具体的对象，而不是通过<code>AGGREGATE</code> 的根来得到这些对象。这样就导致领域逻辑进入查询和客户代码中，而<code>ENTITY</code> 和<code>VALUE OBJECT</code> 则变成单纯的数据容器。采用大多数处理数据库访问的技术复杂性很快就会使客户代码变得混乱，这将导致开发人员简化领域层，最终使模型变得无关紧要。<br><strong>除了通过根来遍历查找对象这种方法以外，禁止用其他方法对AGGREGATE内部的任何对象进行访问</strong></p><p style="color:blue;font-weight:800">思考：如果完全按照领域模型的角度，完全通过遍历对象的方法来获取所有关联的对象。这种模型会过于错综复杂。对象嵌套的层级或者关联的层级非常深。例如通过 Customer.order.product.price 层层遍历来获取当时客户订单的商品的价格。那如果完全按照数据库模型的角度，模型中的对象不需要完全连接起来，对象关系网就能保持在一个可控范围。但是这又会回到之前传统开发模式中，零散的使用各个 DAO 从各个表抽取数据自行拼凑出我们想要的模型。这里就会出现一个问题，Customer 类需要保持客户所有已订的 Order，还是通过 CustomerID 在数据库中查找 Order 列表呢？</p><p><em><code>摘抄 P:100</code></em></p><p><code>REPOSITORY</code> 将某种类型的所有对象表示为一个概念集合（通常是模拟的）。它的行为类似于集合<code>collection</code>，只是具有更复杂的<strong>查询功能</strong>。</p><p>在添加或删除相应类型的对象时，<code>REPOSITORY</code>的后台机制<strong>负责将对象添加到数据库中，或从数据库中删除对象</strong>。这个定义将一组紧密相关的职责集中在一起，这些职责提供了对<code>AGGREGATE</code> 根的整个生命周期的全程访问。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Repository_01.png" alt="使用Repository为客户执行删除"></p><h3 id="如何实现Repository？"><a href="#如何实现Repository？" class="headerlink" title="如何实现Repository？"></a>如何实现Repository？</h3><p><em><code>摘抄 P:100</code></em></p><ul><li>通过一个众所周知的<strong>全局接口</strong>来提供访问。</li><li>为<strong>每种</strong>需要全局访问的对象类型<strong>创建一个对象</strong>，这个对象相当于该类型的所有对象在内存中的一个集合的“替身”</li><li>提供添加和删除对象的方法，用这些方法来封装在数据存储中实际插入或删除数据的操作</li><li>提供根据具体条件来挑选对象的方法，并返回属性值满足查询条件的对象或对象集合（所返回的对象是完全实例化的），从而将实际的存储和查询技术封装起来。</li><li>只为那些确实需要直接访问的<code>AGGREGATE根</code>提供<code>REPOSITORY</code></li><li>让客户始终聚焦于模型，而将<strong>所有对象的存储和访问</strong>操作交给<code>REPOSITORY</code> 来完成</li></ul><p><em><code>摘抄 P:102</code></em></p><p>基于SPECIFICATION （规格）的查询是将REPOSITORY 通用化的好办法。客户可以使用规格来描<br>述（也就是指定）它需要什么，而不必关心如何获得结果。在这个过程中，可以创建一个对象来<br>实际执行筛选操作。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Repository_02.png" alt="基于SPECIFICATION的Repository框架"></p><p style="color:red;font-weight:800">问题：基于Specification的Repository框架如何实现？</p><p><em><code>摘抄 P:103</code></em></p><p>根据所使用的持久化技术和基础设施不同，REPOSITORY 的实现也将有很大的变化。将存储、检索和查询机制<strong>封装起来</strong>是REPOSITORY 实现的最基本的特性：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Repository_03.png" alt="Repository将底层数据存储封装起来"></p><p style="color:blue;font-weight:800">思考：通过Repository我们将底层数据存储封装起来，这样可以很容易的更换数据框架，而不影响现有实现。</p><h3 id="实现Repository的注意事项"><a href="#实现Repository的注意事项" class="headerlink" title="实现Repository的注意事项"></a>实现Repository的注意事项</h3><ul><li><strong>对类型进行抽象</strong>。并不是每个类都需要有一个Repository，类型可以是一个结构层次的父类，（例如TradeOrder可以是Order）。类型也可以是个接口，也可以是个具体类。</li><li><strong>充分利用与客户解耦的优点</strong>。我们可以很容易地更改R EPOSITORY 的实现，但如果客户直接调用底层机制，我们就很难修改其实现。也可以利用<strong>解耦</strong>来优化性能，因为这样就可以使用<strong>不同的</strong>查询技术，或在内存中缓存对象，可以<strong>随时自由地切换持久化策略</strong>。</li><li><strong>将事务的控制权留给客户</strong>。如果REPOSITORY 不插手事务控制，那么事务管理就会简单得多。</li></ul><h3 id="REPOSITORY-与FACTORY-的关系"><a href="#REPOSITORY-与FACTORY-的关系" class="headerlink" title="REPOSITORY 与FACTORY 的关系"></a>REPOSITORY 与FACTORY 的关系</h3><p><em><code>摘抄 P:105</code></em></p><p><code>FACTORY</code> 负责处理对象生命周期的<strong>开始</strong>，而<code>REPOSITORY</code>帮助管理生命周期的<strong>中间和结束。</strong></p><p><code>FACTORY</code> 负责制造新对象，而<code>REPOSITORY</code>负责查找已有对象。</p><p><code>Factory</code>和<code>Repository</code>职责分离：<code>Factory</code>创建新对象之后把它添加到<code>Repository</code>中</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DDD_Repository_04.png" alt="职责分离"></p>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 入门(五)</title>
      <link href="/asp.net-core-wu.html"/>
      <url>/asp.net-core-wu.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP-NET-Core-从入门到实战总结"><a href="#ASP-NET-Core-从入门到实战总结" class="headerlink" title="ASP.NET Core 从入门到实战总结"></a>ASP.NET Core 从入门到实战总结</h2><p>看完《ASP.NET Core跨平台开发从入门到实战》后的总结摘抄(写给自己看)。</p><h2 id="日志（Logging）"><a href="#日志（Logging）" class="headerlink" title="日志（Logging）"></a>日志（Logging）</h2><p>ASP.NET Core内建支持日志，允许开发人寰轻松切换为他们想用的其它日志框架。</p><p>注意：<code>loggerFactory.AddConsole()</code>方法已过时，推荐使用以下<code>Hosting</code>方式：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">CreateWebHostBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IWebHostBuilder <span class="token function">CreateWebHostBuilder</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>        WebHost<span class="token punctuation">.</span><span class="token function">CreateDefaultBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token generic-method function">UseStartup<span class="token punctuation">&lt;</span>Startup<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">ConfigureLogging</span><span class="token punctuation">(</span><span class="token punctuation">(</span>hostingContext<span class="token punctuation">,</span> logging<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>               logging<span class="token punctuation">.</span><span class="token function">AddConfiguration</span><span class="token punctuation">(</span>hostingContext<span class="token punctuation">.</span>Configuration<span class="token punctuation">.</span><span class="token function">GetSection</span><span class="token punctuation">(</span><span class="token string">"Logging"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                logging<span class="token punctuation">.</span><span class="token function">AddConsole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                logging<span class="token punctuation">.</span><span class="token function">AddDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-使用ILogger-lt-T-gt"><a href="#1-使用ILogger-lt-T-gt" class="headerlink" title="1. 使用ILogger&lt;T&gt;"></a>1. 使用<code>ILogger&lt;T&gt;</code></h3><p>理想情况下应当使用构造函数来显式定义他们的依赖项，并且使其作为参数传入，而不是请求<code>ILoggerFactory</code>显式创建<code>ILogger</code>实例。</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">private</span> <span class="token keyword">readonly</span> ILogger<span class="token operator">&lt;</span>TodoController<span class="token operator">></span> _logger<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">TodoController</span><span class="token punctuation">(</span>ILogger<span class="token operator">&lt;</span>TodoController<span class="token operator">></span> logger<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            _logger <span class="token operator">=</span> logger<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">[</span>HttpGet<span class="token punctuation">]</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">GetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            _logger<span class="token punctuation">.</span><span class="token function">LogInformation</span><span class="token punctuation">(</span><span class="token string">"XXX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-日志记录级别"><a href="#2-日志记录级别" class="headerlink" title="2. 日志记录级别"></a>2. 日志记录级别</h3><ol><li><strong>Trace</strong>：仅用于开发调试阶段，这些消息可能包含敏感信息，不建议用于生产环境，默认禁用。例如：<code>Credentials:{&quot;User&quot;:&quot;someuser&quot;,&quot;Password&quot;:&quot;XXXXX&quot;}</code></li><li><strong>Debug</strong>：这种消息在开发阶段短期内比较有用，包含一些对调试有益的消息。</li><li><strong>Information</strong>：这种消息被用于跟踪应用程序一般流程，这些消息应该有一定的长期价值。例如：<code>Request received for path/foo</code></li><li><strong>Warning</strong>：应用程序出现错误，但是不会导致程序停止，建议在一个通用的地方处理警⚠级别的消息。例如：<code>Login failed for IP 127.0.0.1</code></li><li><strong>Error：</strong>程序出现故障导致停止，这些消息应该知名当前活动或者具体操作便于定位故障（比如当前的HTTP请求），而不是范围性的故障。例如：<code>Cannot insert record due to duplicate key violation(由于密钥冲突无法插入记录)</code></li><li><strong>Critical：</strong>应用程序崩溃后者系统崩溃、灾难性故障，需要立即被关注时，应当记录关键级别的日志。例如：数据丢失，磁盘空间不足等。</li></ol><p><code>LogInformation()</code>等扩展方法的参数有：</p><ul><li><strong>EventId：</strong>使用数字类型的ID来标记日志，这样可以将一系列的事件彼此互相关联。被记录的事件ID应该是静态的、特定于指定类型时间的。比如，我们可能会把添加到购物车时间的事件ID标记为1000，然后把结单事件ID标记为1001.以便能智能过滤并且处理这些日志记录。</li><li><strong>string format：</strong>日志消息字符串</li><li><strong>object[] args：</strong>格式化的一组对象</li><li><strong>Exception error：</strong>异常实例</li></ul><h3 id="3-在程序中配置使用Logging"><a href="#3-在程序中配置使用Logging" class="headerlink" title="3. 在程序中配置使用Logging"></a>3. 在程序中配置使用Logging</h3><p>我们需要在Startup类中的Configure方法中解析ILoggerFactory。通过DI以参数的形式自动为Configure方法注入一个ILoggerFactory实例。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span>IApplicationBuilder app<span class="token punctuation">,</span> ILoggerFactory loggerFactory<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以在Hosting时选择配置日志记录，而不是在Startup.</p><p>一个LoggerFactory实例可以选择性的使用自定义<code>FilterLoggerSettings</code>配置。</p><p>下面的这个示例演示了：</p><ul><li>配置自定义日志级别不同的范围</li><li>限制系统和微软的内置日志记录警告</li><li>允许应用程序在默认的情况下记录调试级别</li></ul><p><code>WithFilter</code>方法返回一个新的<code>ILoggerFactory</code>，将过滤传递的所有注册的记录器日志信息，他不会影响其它的<code>ILoggerFactory</code>实例。</p><pre class="line-numbers language-csharp"><code class="language-csharp">        loggerFactory<span class="token punctuation">.</span><span class="token function">WithFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FilterLoggerSettings</span>        <span class="token punctuation">{</span>            <span class="token punctuation">{</span><span class="token string">"Microsoft"</span><span class="token punctuation">,</span>LogLevel<span class="token punctuation">.</span>Warning <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token string">"System"</span><span class="token punctuation">,</span>LogLevel<span class="token punctuation">.</span>Warning <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token string">"ToDoApi"</span><span class="token punctuation">,</span>LogLevel<span class="token punctuation">.</span>Debug <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddConsole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Core入门 </tag>
            
            <tag> Logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 入门(四)</title>
      <link href="/asp.net-core-si.html"/>
      <url>/asp.net-core-si.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP-NET-Core-从入门到实战总结"><a href="#ASP-NET-Core-从入门到实战总结" class="headerlink" title="ASP.NET Core 从入门到实战总结"></a>ASP.NET Core 从入门到实战总结</h2><p>看完《ASP.NET Core跨平台开发从入门到实战》后的总结摘抄(写给自己看)。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>ASP.NET Core 配置文件支持多种不同的配置选项，应用程序配置数据可以使用JSON、XML、INI格式。</p><h3 id="1-获取和设置配置文件"><a href="#1-获取和设置配置文件" class="headerlink" title="1.获取和设置配置文件"></a>1.获取和设置配置文件</h3><p>在 ASP.NET Core应用程序中，建议在应用程序的Startup类中只<strong>实例化一个</strong><code>Configuration</code>实例，然后使用<strong>选择模式</strong>来访问各自的设置。</p><p>简单来说，<code>Configuration</code>类只是一个提供读写<code>名称/值</code>的<code>Providers</code>，所以至少需要提供一个<strong>数据源</strong>才能使得<code>Configuration</code>正常工作。</p><p>以下例子演示如何把<code>Configuraion</code>作为一个<strong>键值对</strong>存储来处理：</p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//使用内存集合作为</span>            builder<span class="token punctuation">.</span><span class="token function">AddInMemoryCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> config <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            config<span class="token punctuation">[</span><span class="token string">"somekey"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//do some work</span>            <span class="token keyword">var</span> setting <span class="token operator">=</span> config<span class="token punctuation">[</span><span class="token string">"somekey"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回"some value"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用内置的数据源"><a href="#2-使用内置的数据源" class="headerlink" title="2. 使用内置的数据源"></a>2. 使用内置的数据源</h3><p>使用内置的配置文件作为数据源，如JSON、XML、INI文件。</p><p>并且可以将多个配置提供程序组合在一起，那么重复的配置将会被覆盖（最后指定的配置提供程序覆盖之前的）</p><p>以下例子设置<code>appsetitngs.json</code>为数据源：</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置应用程序物理路径</span>        builder<span class="token punctuation">.</span><span class="token function">SetBasePath</span><span class="token punctuation">(</span>Directory<span class="token punctuation">.</span><span class="token function">GetCurrentDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">AddJsonFile</span><span class="token punctuation">(</span><span class="token string">"appsettings.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> connectionStringConfig <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Core入门 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 入门(三)</title>
      <link href="/asp.net-core-san.html"/>
      <url>/asp.net-core-san.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP-NET-Core-从入门到实战总结"><a href="#ASP-NET-Core-从入门到实战总结" class="headerlink" title="ASP.NET Core 从入门到实战总结"></a>ASP.NET Core 从入门到实战总结</h2><p>看完《ASP.NET Core跨平台开发从入门到实战》后的总结摘抄(写给自己看)。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件是用来组成应用程序管道来处理请求和响应的组件。</p><p>管道中的每个组件都可以选择是否将请求传入下一个组件,并在管道中调用下一个组件之前和之后执行某些操作。</p><p>ASP.NET 内置中间件：</p><ul><li>身份认证（Authentication）：提供身份验证支持</li><li>跨域共享资源（CORS）</li><li>路由（Routing）</li><li>会话（Session）</li><li>静态文件（Static Files）</li></ul><p>更多请看<a href="https://github.com/aspnet" target="_blank" rel="noopener">https://github.com/aspnet</a></p><h3 id="1-实现一个中间件"><a href="#1-实现一个中间件" class="headerlink" title="1. 实现一个中间件"></a>1. 实现一个中间件</h3><p>编写一个获取连接用户的IP并且输出日志的中间件：</p><p><code>RequestIPMiddleware.cs:</code></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestIPMiddleware</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> RequestDelegate _next<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> ILogger _logger<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造函数注入（遵从显式依赖原则，并在构造函数中暴露所有依赖项，通过UseMiddleware&lt;T>方法，直接通过构造函数注入服务）</span>    <span class="token keyword">public</span> <span class="token function">RequestIPMiddleware</span><span class="token punctuation">(</span>RequestDelegate next<span class="token punctuation">,</span> ILoggerFactory loggerFactory<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _next <span class="token operator">=</span> next<span class="token punctuation">;</span>        _logger <span class="token operator">=</span> loggerFactory<span class="token punctuation">.</span><span class="token generic-method function">CreateLogger<span class="token punctuation">&lt;</span>RequestIPMiddleware<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">async</span> Task <span class="token function">Invoke</span><span class="token punctuation">(</span>HttpContext context<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _logger<span class="token punctuation">.</span><span class="token function">LogInformation</span><span class="token punctuation">(</span><span class="token string">"User IP: "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span>Connection<span class="token punctuation">.</span>RemoteIpAddress<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将上下文交与下一个中间件</span>        <span class="token keyword">await</span> _next<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Extensions.cs:</code></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//中间件扩展方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IApplicationBuilder <span class="token function">UseRequestIP</span><span class="token punctuation">(</span><span class="token keyword">this</span> IApplicationBuilder builder<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token generic-method function">UseMiddleware<span class="token punctuation">&lt;</span>RequestIPMiddleware<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Startup类中的Configure方法中添加自定义中间件：</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">        loggerFactory<span class="token punctuation">.</span><span class="token function">AddConsole</span><span class="token punctuation">(</span>minLevel<span class="token punctuation">:</span> LogLevel<span class="token punctuation">.</span>Information<span class="token punctuation">)</span><span class="token punctuation">;</span>        app<span class="token punctuation">.</span><span class="token function">UseRequestIP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后的输出结果：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/consoleip.png" alt="输出结果"></p>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Core入门 </tag>
            
            <tag> 中间件编写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 入门(二)</title>
      <link href="/asp.net-core-er.html"/>
      <url>/asp.net-core-er.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP-NET-Core-从入门到实战总结"><a href="#ASP-NET-Core-从入门到实战总结" class="headerlink" title="ASP.NET Core 从入门到实战总结"></a>ASP.NET Core 从入门到实战总结</h2><p>看完《ASP.NET Core跨平台开发从入门到实战》后的总结摘抄(写给自己看)。</p><h2 id="Application-Startup"><a href="#Application-Startup" class="headerlink" title="Application Startup"></a>Application Startup</h2><p>总结一下Startup的作用和它的方法，包括中间件的编写。</p><h3 id="1-Startup类"><a href="#1-Startup类" class="headerlink" title="1. Startup类"></a>1. Startup类</h3><p>Startup类是应用程序的入口（entry point），开发人员可以在Startup类中配置请求管道，用于处理应用程序中的所有请求。</p><p>类中必须包含两个方法：</p><ul><li>Configure方法（中间件）</li><li>ConfigureServices方法（服务）</li></ul><h3 id="2-Configure方法"><a href="#2-Configure方法" class="headerlink" title="2. Configure方法"></a>2. Configure方法</h3><p>此方法用于指定ASP.NET 应用程序如何响应每一个HTTP请求。</p><p>封装中间件，通过扩展方法添加到<code>IApplicationBuilder</code>上。</p><p>Configure必须接受一个<code>IApplicationBuilder</code>参数。</p><p>一些额外服务，例如：</p><ul><li><code>IHostingEnvironment</code></li><li><code>ILoggerFactory</code></li></ul><p>例如下面这个例子中，多个扩展方法被用于管道中：</p><pre class="line-numbers language-csharp"><code class="language-csharp">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span>IApplicationBuilder app<span class="token punctuation">,</span> IHostingEnvironment env<span class="token punctuation">,</span> ILoggerFactory loggerFactory<span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token preprocessor property">#<span class="token directive keyword">pragma</span> warning disable CS0618 </span><span class="token comment" spellcheck="true">// 类型或成员已过时</span>            loggerFactory<span class="token punctuation">.</span><span class="token function">AddDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//详见https://www.cnblogs.com/anduril/p/11402864.html</span><span class="token preprocessor property">#<span class="token directive keyword">pragma</span> warning restore CS0618 </span><span class="token comment" spellcheck="true">// 类型或成员已过时</span>            <span class="token comment" spellcheck="true">//开发环境 可以在：属性/调试中切换运行环境 “ASPNETCORE_ENVIRONMENT”</span>            <span class="token comment" spellcheck="true">/*             IsDevelopment()             IsStaging()             IsProduction()             IsEnvironment()             */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>env<span class="token punctuation">.</span><span class="token function">IsDevelopment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//env.IsEnvironment("environmentname")</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用开发环境异常页面的中间件</span>                app<span class="token punctuation">.</span><span class="token function">UseDeveloperExceptionPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//引入程序集：Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore</span>                <span class="token comment" spellcheck="true">//EF Core数据库帮助</span>                app<span class="token punctuation">.</span><span class="token function">UseDatabaseErrorPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//引入程序集Microsoft.VisualStudio.Web.BrowserLink</span>                <span class="token comment" spellcheck="true">//"Browser Link "刷新功能</span>                app<span class="token punctuation">.</span><span class="token function">UseBrowserLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//其它环境</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//出现异常时，转到此页面</span>                app<span class="token punctuation">.</span><span class="token function">UseExceptionHandler</span><span class="token punctuation">(</span><span class="token string">"/Home/Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//引入包： Microsoft.AspNetCore.StaticFiles </span>            <span class="token comment" spellcheck="true">//默认静态文件目录为 wwwroot</span>            app<span class="token punctuation">.</span><span class="token function">UseStaticFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//使用MVC并且设置默认路由</span>            app<span class="token punctuation">.</span><span class="token function">UseMvc</span><span class="token punctuation">(</span>routes <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>                routes<span class="token punctuation">.</span><span class="token function">MapRoute</span><span class="token punctuation">(</span>                    name<span class="token punctuation">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>                    template<span class="token punctuation">:</span> <span class="token string">"{controller=Home}/{action=Index}/{id?}"</span>                    <span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-ConfigureServices方法"><a href="#3-ConfigureServices方法" class="headerlink" title="3. ConfigureServices方法"></a>3. ConfigureServices方法</h3><p>通过依赖注入将服务加入服务容器</p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span>IServiceCollection services<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            services<span class="token punctuation">.</span><span class="token function">AddMvcCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-在启动服务时可用"><a href="#4-在启动服务时可用" class="headerlink" title="4. 在启动服务时可用"></a>4. 在启动服务时可用</h3><p>ASP.NET Core 在应用程序启动期间提供了一些应用服务和对象</p><p>Startup:</p><ul><li>IApplicationEnvironment</li><li>IHostingEnvironment</li><li>ILoggerFactory</li></ul><p>ConfigureService：</p><ul><li>IServiceCollection</li></ul><p>Configure:</p><ul><li>IApplicationBuilder</li><li>IApplicationEnvironment</li><li>IHostingEnvironment</li><li>ILoggerFactory</li></ul>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Core入门 </tag>
            
            <tag> Startup类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core 入门(一)</title>
      <link href="/asp.net-core-yi.html"/>
      <url>/asp.net-core-yi.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP-NET-Core-从入门到实战总结"><a href="#ASP-NET-Core-从入门到实战总结" class="headerlink" title="ASP.NET Core 从入门到实战总结"></a>ASP.NET Core 从入门到实战总结</h2><p>看完《ASP.NET Core跨平台开发从入门到实战》后的总结摘抄(写给自己看)。</p><h2 id="ASP-NET-Core-介绍"><a href="#ASP-NET-Core-介绍" class="headerlink" title="ASP.NET Core 介绍"></a>ASP.NET Core 介绍</h2><p>简单介绍一个ASP.NET Core的应用基本组成</p><h3 id="1-ASP-NET-Core应用"><a href="#1-ASP-NET-Core应用" class="headerlink" title="1.ASP.NET Core应用"></a>1.ASP.NET Core应用</h3><h4 id="1-1-在Main方法中创建一个Web服务器的简单控制台应用程序："><a href="#1-1-在Main方法中创建一个Web服务器的简单控制台应用程序：" class="headerlink" title="1.1 在Main方法中创建一个Web服务器的简单控制台应用程序："></a>1.1 在Main方法中创建一个Web服务器的简单控制台应用程序：</h4><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//Builder模式</span>            <span class="token keyword">var</span> host <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebHostBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//定义Web服务器</span>                <span class="token punctuation">.</span><span class="token function">UseKestrel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">//指定startup类型</span>                <span class="token punctuation">.</span><span class="token generic-method function">UseStartup<span class="token punctuation">&lt;</span>Startup<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//构建用于宿主应用程序的IWebHost,启动之后监听传入的Http请求</span>            host<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>使用<code>UseKestrel()</code>扩展方法需要引入<code>Microsoft.AspNetCore.Server.Kestre</code>包</li></ul><h4 id="1-2-更灵活的方法选择使用哪个WebHost（推荐）"><a href="#1-2-更灵活的方法选择使用哪个WebHost（推荐）" class="headerlink" title="1.2 更灵活的方法选择使用哪个WebHost（推荐）:"></a>1.2 更灵活的方法选择使用哪个WebHost（推荐）:</h4><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">BuildeDefaultWebHost</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> IWebHost <span class="token function">BuildeDefaultWebHost</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>        WebHost<span class="token punctuation">.</span><span class="token function">CreateDefaultBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//.UseKestrel()</span>                 <span class="token punctuation">.</span><span class="token generic-method function">UseStartup<span class="token punctuation">&lt;</span>Startup<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><code>WebHost.CreateDefaultBuilder(args)</code>返回<code>IWebHostBuilder</code>类型，它可以提供很多可选方法。</li></ul><h3 id="2-Startup类"><a href="#2-Startup类" class="headerlink" title="2. Startup类"></a>2. Startup类</h3><p>Startup类可用来<strong>定义请求处理管道和配置应用需要的服务。</strong></p><p>该类必须是<code>public</code>的。</p><p>并且包含如下方法：</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Startup</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span>IServiceCollection services<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//定义你所用的服务</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span>IApplicationBuilder app<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//定义请求管道中间件</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li>ConfigureServices定义所用的服务，例如：ASP.NET Core MVC、EF Core、Identity等…</li><li>Configure定义请求管道中间件</li></ul><h3 id="3-服务"><a href="#3-服务" class="headerlink" title="3. 服务"></a>3. 服务</h3><p>服务是应用中通用调用的组件，如Logging，通过依赖注入获取并且使用，Core中内置一个简单的IoC容器，可以使用自己的IoC容器替换，例如AutoFac。</p><h3 id="4-中间件"><a href="#4-中间件" class="headerlink" title="4. 中间件"></a>4. 中间件</h3><p>使用中间件构建处理请求管道，Core中的中间件是一个<code>HttpContext</code>执行异步逻辑，然后<strong>顺序</strong>调用下一个中间件，或者直接终止请求。</p><p>一般情况下，我们在Startup的Configure方法中调用IApplicationBulider上的一个对应的<code>UserXXX()</code>扩展方法即可。</p><p>ASP.NET Core 中的几个内置中间件：</p><ul><li>静态文件(Static files)</li><li>路由(Routing)</li><li>身份验证(Authentication)</li></ul><h3 id="5-服务器"><a href="#5-服务器" class="headerlink" title="5. 服务器"></a>5. 服务器</h3><p>ASP.NET Core托管模式并不直接监听请求，而是依赖一个<code>HTTP Server</code>实现来<strong>转发请求</strong>到应用程序。这个被转发的请求回以一组<code>feature</code>接口的形式被包装，然后被应用程序组合到一个<code>HttpContext</code>中去。Core中包含了一个跨平台的Web服务器：<code>Kestrel</code>。它往往会被运行在一个IIS或者Nginx的生产Web服务器之后。</p><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-2.2" target="_blank" rel="noopener">跨平台Web服务器Kestrel</a></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/kes.png" alt="Kestrel服务器的作用"></p><h3 id="6-内容根目录"><a href="#6-内容根目录" class="headerlink" title="6. 内容根目录"></a>6. 内容根目录</h3><p>默认情况下，内容根目录是于宿主的可执行程序的应用根目录相同。</p><p>可以通过<code>WebHostBuilder</code>设置。</p><h3 id="7-网站根目录"><a href="#7-网站根目录" class="headerlink" title="7. 网站根目录"></a>7. 网站根目录</h3><p>包含Css、JS和图片文件公开、<strong>静态的资源目录</strong>。Web根目录默认为<code>&lt;contentroot&gt;/wwwroot</code></p><p>可以通过<code>WebHostBuilder</code>设置。</p><h3 id="8-配置"><a href="#8-配置" class="headerlink" title="8. 配置"></a>8. 配置</h3><p>使用键值对进行配置，不基于<code>web.config</code></p><h3 id="9-环境"><a href="#9-环境" class="headerlink" title="9. 环境"></a>9. 环境</h3><ul><li>Development</li><li>Produciton</li></ul>]]></content>
      
      
      <categories>
          
          <category> ASP.NET Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Core入门 </tag>
            
            <tag> Core应用组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc框架之Autofac的使用</title>
      <link href="/ioc-kuang-jia-zhi-autofac-de-shi-yong.html"/>
      <url>/ioc-kuang-jia-zhi-autofac-de-shi-yong.html</url>
      
        <content type="html"><![CDATA[<h1 id="AutoFac依赖注入框架的使用"><a href="#AutoFac依赖注入框架的使用" class="headerlink" title="AutoFac依赖注入框架的使用"></a>AutoFac依赖注入框架的使用</h1><p><strong>AutoFac的基本流程：</strong></p><p>声明容器-&gt;注册实例-&gt;解析对象-&gt;调用方法</p><h2 id="Demo类创建"><a href="#Demo类创建" class="headerlink" title="Demo类创建"></a>Demo类创建</h2><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> System<span class="token punctuation">;</span><span class="token keyword">namespace</span> DemoApp<span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IOutput</span>  <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">string</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//继承接口IOutput</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsoleOutput</span> <span class="token punctuation">:</span> IOutput  <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">string</span> content<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDateWriter</span>  <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">WriteDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//继承接口IDateWriter</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TodayWriter</span> <span class="token punctuation">:</span> IDateWriter  <span class="token punctuation">{</span>    <span class="token keyword">private</span> IOutput _output<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//演示构造函数注入</span>    <span class="token keyword">public</span> <span class="token function">TodayWriter</span><span class="token punctuation">(</span>IOutput output<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_output <span class="token operator">=</span> output<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">WriteDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//若没有使用IoC容器此处报错</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_output<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Today<span class="token punctuation">.</span><span class="token function">ToShortDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-创建生成器-Builder"><a href="#1-创建生成器-Builder" class="headerlink" title="1.创建生成器 Builder"></a>1.创建生成器 Builder</h2><p> 创建注册组件/服务的生成器。 </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-注册组件"><a href="#2-注册组件" class="headerlink" title="2.注册组件"></a>2.注册组件</h2><h3 id="2-1-通过类型注册"><a href="#2-1-通过类型注册" class="headerlink" title="2.1 通过类型注册"></a>2.1 通过类型注册</h3><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ConsoleLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">RegisterType</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ConfigReader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1-构造函数匹配规则"><a href="#2-1-1-构造函数匹配规则" class="headerlink" title="2.1.1 构造函数匹配规则"></a>2.1.1 构造函数匹配规则</h4><ul><li>当使用基于反射的组件时，AutoFac自动为你的类从容器中<strong>寻找匹配拥有最多参数</strong>的构造方法。</li></ul><p><strong>例如，此时拥有三个构造函数的类：</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyComponent</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>ILogger logger<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>ILogger logger<span class="token punctuation">,</span> IConfigReader reader<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>现在我们在容器中注册组件和服务：</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>MyComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ConsoleLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> component <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>MyComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当解析组件时，Autofac发现<code>ILogger</code>已经被注册（第三行），但是我们并没有注册<code>IConfigReader</code>，所以它寻找匹配<strong>最多</strong>参数的构造方法，即<strong>第二个</strong>构造函数。</p><h4 id="2-1-2-指定构造函数"><a href="#2-1-2-指定构造函数" class="headerlink" title="2.1.2  指定构造函数"></a>2.1.2  指定构造函数</h4><p>我们可以使用<code>UsingConstructor</code>手动指定一个构造函数。</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>MyComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">UsingConstructor</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>ILogger<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>IConfigReader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要注意的是, 在解析时你仍然需要提供必要的参数，否则在你尝试解析对象时将出现错误. </p><p>你可以 <a href="https://autofaccn.readthedocs.io/zh/latest/register/parameters.html" target="_blank" rel="noopener">在注册时传参</a> 或 <a href="https://autofaccn.readthedocs.io/zh/latest/resolve/parameters.html" target="_blank" rel="noopener">在解析时传参</a>. </p><h3 id="2-2-实例组件"><a href="#2-2-实例组件" class="headerlink" title="2.2 实例组件"></a>2.2 实例组件</h3><p> 通过使用 <code>RegisterInstance</code> 方法 ：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">RegisterInstance</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>TextWriter<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-1-自己控制组件的生命周期"><a href="#2-2-1-自己控制组件的生命周期" class="headerlink" title="2.2.1 自己控制组件的生命周期"></a>2.2.1 自己控制组件的生命周期</h4><p>当使用new实例化一个组件之时，必然会遇到内存释放问题，Autofac会自动处理已注册组件的释放，当时也可以自己控制生命周期。</p><p>我们可以使用<code>ExternallyOwned</code>  方法来注册实例：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">RegisterInstance</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>TextWriter<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">ExternallyOwned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-Lambda表达式组件"><a href="#2-3-Lambda表达式组件" class="headerlink" title="2.3 Lambda表达式组件"></a>2.3 Lambda表达式组件</h3><p> Autofac接收一个委托或者lambda表达式, 用作组件创建者: </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>B<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-3-1-参数注入"><a href="#2-3-1-参数注入" class="headerlink" title="2.3.1 参数注入"></a>2.3.1 参数注入</h4><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> MyB <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token generic-method function">ResolveOptional<span class="token punctuation">&lt;</span>B<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-暴露服务"><a href="#2-4-暴露服务" class="headerlink" title="2.4 暴露服务"></a>2.4 暴露服务</h3><p>我们注册组件时，需要告诉Autofac，组件暴露了哪些服务。</p><p>使用类型注册(RegisterType)时，大多数情况下组件<strong>自身</strong>将被暴露。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// "CallLogger"将被暴露</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>CallLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>组件能够被它暴露的服务<strong>解析</strong>：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//可以解析成功</span>scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>CallLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不能解析成功，因为ILogger未能暴露</span>scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以让一个组件暴露一个或多个服务  ：使用 <code>As</code></p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>CallLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//暴露ILogger服务</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ICallInterceptor<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//暴露ICallInterceptor服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>暴露服务之后，你就可以解析基于该服务的组件了。</p><p>不过要注意的是，一旦你将组件暴露为一个特定的服务，那么默认的服务/组件类型将被<strong>覆盖</strong>：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//解析成功</span>scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>ICallInterceptor<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解析失败</span>scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>CallLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>AsSelf</code>方法可以让组件技能暴露一系列特定服务，也能让它暴露默认服务。</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>CallLogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">AsSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//AsSelf</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ILogger<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ICallInterceptor<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-默认注册"><a href="#2-5-默认注册" class="headerlink" title="2.5 默认注册"></a>2.5 默认注册</h3><p>如果多个组件暴露了相同的服务，那么Autofac将会选取<strong>最后注册</strong>的组件作为服务提供方：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">namespace</span> DemoIBLL<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//接口IUserBLL</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUserBLL</span>    <span class="token punctuation">{</span>        <span class="token keyword">string</span> <span class="token function">GetUserInformation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//UserBLL</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserBLL</span> <span class="token punctuation">:</span> IUserBLL    <span class="token punctuation">{</span>         <span class="token keyword">public</span> <span class="token keyword">string</span> <span class="token function">GetUserInformation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token string">"我是wk。"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//SuperUserBLL</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperUserBLL</span> <span class="token punctuation">:</span> IUserBLL    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">string</span> <span class="token function">GetUserInformation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"我是超人"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp">ContainerBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>UserBLL<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IUserBLL<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个注册的组件将会成为服务的提供商</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>SuperUserBLL<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IUserBLL<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> IContainer container <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IUserBLL userBLL <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IUserBLL<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span> userBLL<span class="token punctuation">.</span><span class="token function">GetUserInformation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出：我是超人</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-两种注册扩展方式"><a href="#2-6-两种注册扩展方式" class="headerlink" title="2.6 两种注册扩展方式"></a>2.6 两种注册扩展方式</h3><ul><li><code>OnlyIf()</code> - 提供一个表达式, 使用一个 <code>IComponentRegistry</code> 来决定注册是否发生.<em>（仅当XX服务注册时注册）</em></li><li><code>IfNotRegistered()</code> - 有其他服务已被注册的情况下阻止注册发生的快捷方法. <em>（XX服务注册时不注册）</em></li></ul><p>这些方法在 <code>ContainerBuilder.Build()</code> 时执行并且以实际组件注册的顺序执行. </p><p><strong>例子：</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只注册ServiceA</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ServiceA<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ServiceB<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//如果IService服务被注册，则取消注册</span>       <span class="token punctuation">.</span><span class="token function">IfNotRegistered</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>IService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//顺序：A先被注册，因为它在HandleB注册之前运行</span><span class="token comment" spellcheck="true">//C将不会被注册，因为它运行在HandlerB之后</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>HandlerA<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">AsSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">IfNotRegistered</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>HandlerB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>HandlerB<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">AsSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>HandlerC<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">AsSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">IfNotRegistered</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>HandlerB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Manager将被注册，因为IService和HandlerB已经注册</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Manager<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IManager<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">OnlyIf</span><span class="token punctuation">(</span>reg <span class="token operator">=</span><span class="token operator">></span>         reg<span class="token punctuation">.</span><span class="token function">IsRegistered</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypedService</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>IService<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         reg<span class="token punctuation">.</span><span class="token function">IsRegistered</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypedService</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>HandlerB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-注册时传参"><a href="#2-7-注册时传参" class="headerlink" title="2.7 注册时传参"></a>2.7 注册时传参</h3><p>我们在注册组件的时候，可以提供一组参数，用于该组件在服务解析的时候使用，当然也可以在服务解析的时候提供参数。</p><h4 id="2-7-1-可使用的参数类型"><a href="#2-7-1-可使用的参数类型" class="headerlink" title="2.7.1  可使用的参数类型"></a>2.7.1  可使用的参数类型</h4><p>Autofac提供了多种不同的参数匹配机制：</p><ul><li><p><code>NamedParameter</code> - 通过名字匹配目标参数</p></li><li><p><code>TypedParameter</code> - 通过类型匹配目标参数 (需要匹配具体的类型)</p></li><li><p><code>ResolvedParameter</code> - 复杂参数的匹配</p><p><code>NamedParameter</code> 和 <code>TypedParameter</code> 只支持常量值. </p><p><code>ResolvedParameter</code> 可以用于提供不同的值来从容器中动态获取对象, 例如, 通过名字解析服务. </p></li></ul><h4 id="2-7-2-反射组件的参数"><a href="#2-7-2-反射组件的参数" class="headerlink" title="2.7.2 反射组件的参数"></a>2.7.2 反射组件的参数</h4><p>当年注册一个基于反射的组件时，类型的构造方法也许会需要一个无法从容器中解析出来的参数，例如常量类型的参数，你可以在注册时提供该参数值。</p><p><strong>例如：</strong>构造函数ConfigReader中需要传入一个configSectionName</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigReader</span> <span class="token punctuation">:</span> IConfigReader<span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">ConfigReader</span><span class="token punctuation">(</span><span class="token keyword">string</span> configSectionName<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存储配置节点名configSectionName</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 读取基于该节点的配置</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以使用<strong>lambda</strong>表达式组件: </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">ConfigReader</span><span class="token punctuation">(</span><span class="token string">"sectionName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 或者在<strong>反射组件</strong>注册时传参: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//使用NAMED parameter</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">WithParameter</span><span class="token punctuation">(</span><span class="token string">"configSectionName"</span><span class="token punctuation">,</span> <span class="token string">"sectionName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用TYPED parameter:</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">WithParameter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypedParameter</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"sectionName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用RESOLVED parameter:</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">WithParameter</span><span class="token punctuation">(</span>         <span class="token keyword">new</span> <span class="token class-name">ResolvedParameter</span><span class="token punctuation">(</span>           <span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> pi<span class="token punctuation">.</span>ParameterType <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pi<span class="token punctuation">.</span>Name <span class="token operator">==</span> <span class="token string">"configSectionName"</span><span class="token punctuation">,</span>           <span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"sectionName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-3-Lambda表达式组件的参数"><a href="#2-7-3-Lambda表达式组件的参数" class="headerlink" title="2.7.3 Lambda表达式组件的参数"></a>2.7.3 Lambda表达式组件的参数</h4><p> 使用lambda表达式组件注册, 你可以不用 <em>在注册时</em> 传入参数值, 而是可以 <em>在服务解析时</em> 传入具体的参数值 。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/*使用两个参数注册委托:c =动态解析依赖项的当前IComponentContextp =带有传入参数集的IEnumerable&lt;Parameter>*/</span>builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>                 <span class="token keyword">new</span> <span class="token class-name">ConfigReader</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token generic-method function">Named<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"configSectionName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当解析时你需要传入这些值</span><span class="token keyword">var</span> reader <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IConfigReader<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NamedParameter</span><span class="token punctuation">(</span><span class="token string">"configSectionName"</span><span class="token punctuation">,</span> <span class="token string">"sectionName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-属性注入-amp-方法注入"><a href="#2-8-属性注入-amp-方法注入" class="headerlink" title="2.8 属性注入&amp;方法注入"></a>2.8 属性注入&amp;方法注入</h3><p>构造函数注入是一种传值给组件的<strong>首选方法</strong>，但是同样可以使用属性和方法注入来传值。</p><h4 id="2-8-1-属性注入"><a href="#2-8-1-属性注入" class="headerlink" title="2.8.1 属性注入"></a>2.8.1 属性注入</h4><p>如果组件是一个Lambda表达式，我们可以使用对象构造器：</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> B <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>B<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果组件是一个反射组件，我们可以使用 <code>PropertiesAutowired()</code> 修饰语来注入属性: </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>A<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">PropertiesAutowired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如果你需要绑定一个特定的属性和它的值, 使用 <code>WithProperty()</code> 修饰语: </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>A<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"PropertyName"</span><span class="token punctuation">,</span> propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-8-2-方法注入"><a href="#2-8-2-方法注入" class="headerlink" title="2.8.2 方法注入"></a>2.8.2 方法注入</h4><p>想要调用一个方法来设置组件上的某个值, 最简单的方法是使用 <strong>lambda表达式</strong>组件 然后在<code>activator</code>中进行正确的方法调用:</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> dep <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>TheDependency<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   result<span class="token punctuation">.</span><span class="token function">SetTheDependency</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//SetTheDependency为方法注入口</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不使用注册<strong>Lambda</strong>表达式，你可以添加一个激活时事件处理程序 <a href="https://autofaccn.readthedocs.io/zh/latest/lifetime/events.html" target="_blank" rel="noopener">(activating event handler)</a>: </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder  <span class="token punctuation">.</span><span class="token generic-method function">Register<span class="token punctuation">&lt;</span>MyObjectType<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//OnActivating 激活时事件处理程序</span>  <span class="token punctuation">.</span><span class="token function">OnActivating</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> dep <span class="token operator">=</span> e<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>TheDependency<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">SetTheDependency</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-扫描程序集"><a href="#2-9-扫描程序集" class="headerlink" title="2.9 扫描程序集"></a>2.9 扫描程序集</h3><p> Autofac可以在程序集中通过约定找到和注册组件.  </p><h4 id="2-9-1-扫描类型"><a href="#2-9-1-扫描类型" class="headerlink" title="2.9.1 扫描类型"></a>2.9.1 扫描类型</h4><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//获得当前代码运行的程序集</span><span class="token keyword">var</span> dataAccess <span class="token operator">=</span> Assembly<span class="token punctuation">.</span><span class="token function">GetExecutingAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>dataAccess<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//默认程序集上的类都会被注册，使用linq表达式过滤注册类型</span>       <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"Repository"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">AsImplementedInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-9-1-1-过滤类型"><a href="#2-9-1-1-过滤类型" class="headerlink" title="2.9.1.1 过滤类型"></a>2.9.1.1 过滤类型</h5><p>在版本4.8以上，使用 <code>PublicOnly()</code>扩展方法，可以只让<strong>公有方法</strong>被注册。</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">PublicOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>where()</code>表达式来过滤注册类型：</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//只注册以"repository"为结尾的类</span>       <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"Repository"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>Except()</code>表达式来排除类型：</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">Except<span class="token punctuation">&lt;</span>MyUnwantedType<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Except()</code>还可以自定义被排除类型的规则：</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">Except<span class="token punctuation">&lt;</span>MyCustomisedType<span class="token punctuation">></span></span><span class="token punctuation">(</span>ct <span class="token operator">=</span><span class="token operator">></span>          ct<span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>ISpecial<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用多个过滤条件：</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">PublicOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"Repository"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">Except<span class="token punctuation">&lt;</span>MyUnwantedRepository<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-9-1-2-指定服务"><a href="#2-9-1-2-指定服务" class="headerlink" title="2.9.1.2 指定服务"></a>2.9.1.2 指定服务</h5><p> <code>As()</code>指定单一服务： </p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>asm<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"Repository"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//指定注册IRepository服务，若一个类使用了其它服务，将报错未注册</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IRepository<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <code>AsImplementedInterfaces()</code> 把一个类注册给它实现的全部接口。 </p><p><code>AsSelf()</code>注册自身。</p><h4 id="2-9-2-扫描模块"><a href="#2-9-2-扫描模块" class="headerlink" title="2.9.2 扫描模块"></a>2.9.2 扫描模块</h4><p> 我们通过 <code>RegisterAssemblyModules()</code> 方法进行模块扫描。</p><p> 假设下面两个普通的模块类在<strong>同一个程序集</strong>中, 并且每个模块注册一个组件: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AModule</span> <span class="token punctuation">:</span> Module<span class="token punctuation">{</span>  <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Load</span><span class="token punctuation">(</span>ContainerBuilder builder<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">AComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>AComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BModule</span> <span class="token punctuation">:</span> Module<span class="token punctuation">{</span>  <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Load</span><span class="token punctuation">(</span>ContainerBuilder builder<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">BComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>BComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RegisterAssemblyModules()</code>的重载，不接受类型参数，他将会注册所提供程序集中的所有IModule类，例如在下面的示例中，<strong>所有的模块</strong>都将被注册：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> assembly <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>AComponent<span class="token punctuation">)</span><span class="token punctuation">.</span>Assembly<span class="token punctuation">;</span><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Registers both modules</span>builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyModules</span><span class="token punctuation">(</span>assembly<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用泛型参数的 <code>RegisterAssemblyModules()</code>的重载允许你指定被注册模块：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> assembly <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>AComponent<span class="token punctuation">)</span><span class="token punctuation">.</span>Assembly<span class="token punctuation">;</span><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Registers AModule but not BModule</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterAssemblyModules<span class="token punctuation">&lt;</span>AModule<span class="token punctuation">></span></span><span class="token punctuation">(</span>assembly<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-解析服务"><a href="#3-解析服务" class="headerlink" title="3. 解析服务"></a>3. 解析服务</h2><p>我们在注册完并且暴露相应的服务之后，你可以从创建的容器或者其子生命周期中接续服务。</p><p>使用<code>Resolve()</code>方法实现：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>MyComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从子容器生命周期中解析服务，并不是直接从容器中</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> service <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> <strong>有时在我们的应用中也许可以从根容器中解析组件, 然而这么做有可能会导致内存泄漏.</strong> 推荐你总是从生命周期中解析组件, 以确保服务实例被妥善地释放和垃圾回收. 在 <a href="https://autofaccn.readthedocs.io/zh/latest/lifetime/index.html" target="_blank" rel="noopener">控制作用域和生命周期章节</a> 阅读更多相关内容. </p></blockquote><p>如果你并不清楚一个服务是否被注册，那么可以通过  <code>ResolveOptional()</code> 或 <code>TryResolve()</code> 尝试解析: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//如果服务被注册了，那么就可以获得服务，如果没有被注册，则获得null</span><span class="token keyword">var</span> service <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">ResolveOptional<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>IProvider provider <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>scope<span class="token punctuation">.</span><span class="token generic-method function">TryResolve<span class="token punctuation">&lt;</span>IProvider<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">out</span> provider<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果注册了，则对解析后的的提供者执行某些操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-解析时传入参数"><a href="#3-1-解析时传入参数" class="headerlink" title="3.1 解析时传入参数"></a>3.1 解析时传入参数</h3><p>与2.7类似，选一种方式即可。</p><h3 id="3-2-隐式关系类型"><a href="#3-2-隐式关系类型" class="headerlink" title="3.2 隐式关系类型"></a>3.2 隐式关系类型</h3><p><a href="https://autofaccn.readthedocs.io/zh/latest/resolve/relationships.html" target="_blank" rel="noopener">隐式关系类型</a>用于优化注册，暂时不总结。</p><h2 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h2><p>当你解析服务时, Autofac将会追踪被解析的可释放/可销毁 (<code>IDisposable</code>) 组件. 在工作单元最后, 你释放了相关的生命周期作用域然后Autofac将会自动清理/释放那些被解析的服务. </p><h3 id="4-1开始使用生命周期作用域"><a href="#4-1开始使用生命周期作用域" class="headerlink" title="4.1开始使用生命周期作用域"></a>4.1开始使用生命周期作用域</h3><h4 id="4-1-1创建一个新的生命周期作用域"><a href="#4-1-1创建一个新的生命周期作用域" class="headerlink" title="4.1.1创建一个新的生命周期作用域"></a>4.1.1创建一个新的生命周期作用域</h4><p>你可以通过在一个已存在的生命周期上调用 <code>BeginLifetimeScope()</code> 方法来创建另一个生命周期作用域 。</p><p>生命周期可以嵌套，并且是需要释放的，在释放之时会追踪组件的释放，所以需要加<code>using</code>或者手动调用<code>Dispose()</code></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从根容器的子范围内解析服务</span>  <span class="token keyword">var</span> service <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 嵌套</span>  <span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> unitOfWorkScope <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">var</span> anotherService <span class="token operator">=</span> unitOfWorkScope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IOther<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-向生命周期作用域中添加注册"><a href="#4-1-2-向生命周期作用域中添加注册" class="headerlink" title="4.1.2 向生命周期作用域中添加注册"></a>4.1.2 向生命周期作用域中添加注册</h4><p>我们可以在创建生命周期作用域的同时随手添加注册。</p><p>使用情景:</p><ul><li>需要在作用域内注册一些不想全局注册的东西</li></ul><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">//传递一个引用 ContainerBuilder 的lambda表达式</span>  builder <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Override<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IService<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterModule<span class="token punctuation">&lt;</span>MyModule<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// The additional registrations will be available</span>  <span class="token comment" spellcheck="true">// only in this lifetime scope.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-实例作用域"><a href="#4-2-实例作用域" class="headerlink" title="4.2 实例作用域"></a>4.2 实例作用域</h3><p>实例作用域决定了对于相同的服务解析出的实例如何在请求之间<strong>被共享</strong>. </p><p>当一个请求的完成需要某个服务，Autofac可以返回单一实例，也可以每次返回新的实例（每个依赖的作用域），或者返回某种上下文共享的单一实例，例如每一次请求，每一个线程。</p><h4 id="4-2-1-每次都返回不同的实例（InstancePerDependency）"><a href="#4-2-1-每次都返回不同的实例（InstancePerDependency）" class="headerlink" title="4.2.1 每次都返回不同的实例（InstancePerDependency）"></a>4.2.1 每次都返回不同的实例（InstancePerDependency）</h4><p>在其他容器中也被称为 ‘transient’ 或者 ‘factory’ . </p><p><strong>对于一个服务每次请求都会返回一个唯一的实例。</strong> </p><p>如果没有指定特定的选项，这个行为是<strong>默认的</strong>。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 上下两种方式等同</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InstancePerDependency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//循环一百次就返回100个不同的实例</span>    <span class="token keyword">var</span> w <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">DoWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-返回单一实例（SingleInstance）"><a href="#4-2-2-返回单一实例（SingleInstance）" class="headerlink" title="4.2.2 返回单一实例（SingleInstance）"></a>4.2.2 返回单一实例（SingleInstance）</h4><p>相当于单例，在根容器和所有的嵌套作用域中所有请求都返回的是同一个实例。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//从根容器中解析获得实例（不推荐）</span><span class="token keyword">var</span> root <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们可以从嵌套的生命周期范围的任何级别、任意次数解析worker。</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope1 <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">var</span> w1 <span class="token operator">=</span> scope1<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope2 <span class="token operator">=</span> scope1<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//root w1 w2返回的都是同一实例</span>      <span class="token keyword">var</span> w2 <span class="token operator">=</span> scope2<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-在每个作用域中为同一实例（InstancePerLifetimeScope）"><a href="#4-2-3-在每个作用域中为同一实例（InstancePerLifetimeScope）" class="headerlink" title="4.2.3 在每个作用域中为同一实例（InstancePerLifetimeScope）"></a>4.2.3 在每个作用域中为同一实例（InstancePerLifetimeScope）</h4><p>每个生命周期作用域的组件在每个嵌套的生命周期作用域中最多只会<strong>有一个</strong>单一实例.</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InstancePerLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope1 <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//每个w1都是同一个实例</span>    <span class="token keyword">var</span> w1 <span class="token operator">=</span> scope1<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope2 <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//每个w2都是同一实例，但是w1和w2不是同一实例</span>    <span class="token keyword">var</span> w2 <span class="token operator">=</span> scope2<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-通过匹配返回同一实例（InstancePerMatchingLifetimeScope）"><a href="#4-2-4-通过匹配返回同一实例（InstancePerMatchingLifetimeScope）" class="headerlink" title="4.2.4 通过匹配返回同一实例（InstancePerMatchingLifetimeScope）"></a>4.2.4 通过匹配返回同一实例（InstancePerMatchingLifetimeScope）</h4><p>类似于<code>InstancePerLifetimeScope</code>但是可以通过设置和传入标签更精准的控制实例的共享。</p><p>大多数的应用中, 只需一层的容器嵌套就足以表示工作单元的作用域. 如果需要更多的嵌套层级 (例如, 全局-&gt;请求-&gt;事务) 组件可以考虑使用标签来在层级关系中特定的层级共享. </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InstancePerMatchingLifetimeScope</span><span class="token punctuation">(</span><span class="token string">"myrequest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在开始一个生命周期时提供标签值来关联，如果提供的名称不匹配，将会抛出异常。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope1 <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token string">"myrequest"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">var</span> w1 <span class="token operator">=</span> scope1<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope2 <span class="token operator">=</span> scope1<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//w1和w2为同一实例</span>      <span class="token keyword">var</span> w2 <span class="token operator">=</span> scope2<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope3 <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token string">"myrequest"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//w3和之前解析的w1和w2不同</span>    <span class="token keyword">var</span> w3 <span class="token operator">=</span> scope3<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope4 <span class="token operator">=</span> scope3<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//w3=w4&lt;>w1&amp;w2</span>      <span class="token keyword">var</span> w4 <span class="token operator">=</span> scope4<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> noTagScope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//会抛出异常，因为没有指定标签，在此作用域中Worker未被注册</span>  <span class="token keyword">var</span> fail <span class="token operator">=</span> noTagScope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-5-每一次请求返回同一实例-Instance-Per-Request"><a href="#4-2-5-每一次请求返回同一实例-Instance-Per-Request" class="headerlink" title="4.2.5 每一次请求返回同一实例(Instance Per Request)"></a>4.2.5 每一次请求返回同一实例(Instance Per Request)</h4><p>仅在 ASP.NET <a href="https://autofaccn.readthedocs.io/zh/latest/integration/webforms.html" target="_blank" rel="noopener">web forms</a> 和 <a href="https://autofaccn.readthedocs.io/zh/latest/integration/mvc.html" target="_blank" rel="noopener">MVC</a> 中应用.  </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>Worker<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InstancePerRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-2-6-每个Owned一个实例-InstancePerOwned"><a href="#4-2-6-每个Owned一个实例-InstancePerOwned" class="headerlink" title="4.2.6 每个Owned一个实例 ( InstancePerOwned)"></a>4.2.6 每个Owned一个实例 ( InstancePerOwned)</h4><p>Owned<t> 隐式关联类型创建嵌套的生命周期范围。使用 instance-per-owned 注册，可将依赖限定在 owned 实例中。 </t></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>MessageHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>ServiceForHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">InstancePerOwned<span class="token punctuation">&lt;</span>MessageHandler<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本例中 ServiceForHandler 服务会限制在 MessageHandler 实例范围内。 </p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">using</span><span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// MessageHandler 和附属的 ServiceForHandler </span>      <span class="token comment" spellcheck="true">// 在 scope 下面的一个微型的 lifetime scope 中。</span>      <span class="token comment" spellcheck="true">// 解析 Owned&lt;T> 需要程序员负责执行清理工作。</span>      Owned<span class="token operator">&lt;</span>MessageHandler<span class="token operator">></span> h1 <span class="token operator">=</span> scope<span class="token punctuation">.</span>Resolve<span class="token operator">&lt;</span>Owned<span class="token operator">&lt;</span>MessageHandler<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      h1<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      h1<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-7-线程作用域（ThreadScope）"><a href="#4-2-7-线程作用域（ThreadScope）" class="headerlink" title="4.2.7 线程作用域（ThreadScope）"></a>4.2.7 线程作用域（ThreadScope）</h4><p>使用InstancePerLifetimeScope，一个线程为一个生命周期</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>MyThreadScopedComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">InstancePerLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样, 每个线程就有了它各自的生命周期作用域: </p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">ThreadStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">var</span> threadLifetime <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">var</span> thisThreadsInstance <span class="token operator">=</span> threadLifetime<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>MyThreadScopedComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li>在多线程的场景下，子线程不能释放父级作用域，如果释放了，将会导致组件不能解析。</li></ul><p>你可以在构造函数中传入一个<code>ILifetimeScope</code>参数把父级的生命周期作用域注入到派生线程的代码中， Autofac会自动注入当前的生命周期作用域然后你就可以从其中创建嵌套的作用域了。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadCreator</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> ILifetimeScope _parentScope<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//传入父级作用域</span>  <span class="token keyword">public</span> <span class="token function">ThreadCreator</span><span class="token punctuation">(</span>ILifetimeScope parentScope<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_parentScope <span class="token operator">=</span> parentScope<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ThreadStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//通过父级作用域创建子作用域</span>    <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">var</span> threadLifetime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_parentScope<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">var</span> thisThreadsInstance <span class="token operator">=</span> threadLifetime<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>MyThreadScopedComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-依赖囚禁"><a href="#4-3-依赖囚禁" class="headerlink" title="4.3 依赖囚禁"></a>4.3 依赖囚禁</h3><p>发生条件：</p><p>一个短时间的组件被另一个长时间的组件所持有就会发生<strong>囚禁依赖</strong>。</p><p>Autofac不会阻止你创建被囚禁依赖，因为这是开发人员的责任，有时候因为囚禁的发生将会得到一个解析异常。</p><h4 id="4-3-1-如何避免囚禁依赖"><a href="#4-3-1-如何避免囚禁依赖" class="headerlink" title="4.3.1 如何避免囚禁依赖"></a>4.3.1 如何避免囚禁依赖</h4><p>避免囚禁依赖的一般准则是：</p><p><strong>使用该服务的组件的生命周期要小于等于正在使用的服务的生命周期。</strong></p><p><strong>例如：</strong></p><p>有一个Web应用，我们通过传入请求中的一些信息来决定连接到哪一个数据库。</p><p>你可能需要以下组件：</p><ul><li>接受当前请求和数据库连接工厂的repository</li><li>类似 <code>HttpContext</code> 的 <em>current request</em> ,可以用于决定业务逻辑. </li><li>一个数据库连接工厂（ <em>database connection factory</em> ），接受一系列参数并且返回正确的数据库连接</li></ul><p>在这个示例中，我们考虑以下应该为每个组件设定怎样的生命周期，而当前请求的上下文是一个很明显的上下文环境，我们可以将当前组件的生命周期设定为<strong>每个请求为同一实例（Instance Per Request）</strong>。</p><p>如果我们将<code>repository</code>设定为<strong>“单例”</strong>模式，即<code>SingleInstance</code>模式，那么这个实例将会缓存在应用的整个生命周期内，该请求上下文<code>(request context)</code>会被传入<code>repository</code>中，并在应用的整个生命周期中一直被<code>repository</code>所持有，即使当次请求已经结束了，这时候repository就是使用该服务的组件，而<code>HttpContext</code>就是正在使用的服务，<code>repository</code>是长期存在的，但是它却一直持有更小生存周期的组件，这就发生了<strong>囚禁依赖。</strong></p><p>如果你将repository也设定为<code>Instance Per Request</code>模式，那么它现在和当前请求存在一样长的生命周期，它们将会被同时释放，就不存在囚禁。</p><p>再进一步，我们将repository设定为<code>Instance Per Dependency</code>即每一次依赖就创建一个新实例，这样也是可以的，它的生命周期比当前请求还要短，也不会发生囚禁现象。</p><p>数据库连接工厂（ <em>database connection factory</em> ）思考过程与之类似，但也需要根据情况分析而选择不同生命周期模式，例如实例化数据库连接工厂比较耗费资源，或者你需要维护一些内部状态它才能正常的工作，这时候可能就需要使用单例模式了。</p><h4 id="4-3-2-应该由开发者决定是否可以接受依赖囚禁"><a href="#4-3-2-应该由开发者决定是否可以接受依赖囚禁" class="headerlink" title="4.3.2 应该由开发者决定是否可以接受依赖囚禁"></a>4.3.2 应该由开发者决定是否可以接受依赖囚禁</h4><p>我们在实际开发中，应该根据情况来决定是否可以接受依赖囚禁的发生。</p><p>例如你有一个缓存类（CacheClass）,它被有意设置为仅在消费组件的生命周期内缓存内容，如果该组件是单例的，那么该组件可以用于整个程序的生命周期中存储东西，如果是<code>Instance Per Request</code>模式，那么它只能存储单次Web请求的数据，在这种情况下选择单例模式更好，虽然发生了依赖囚禁现象，但是只要开发人员理解这样设置生存期的后果，这样也是可以接受的。</p><p>概括来说，<strong>依赖囚禁的发生应该是有意的而不是无意的。</strong></p><h3 id="4-4-释放"><a href="#4-4-释放" class="headerlink" title="4.4 释放"></a>4.4 释放</h3><p>一些工作单元中包含的非托管资源例如：数据库连接、事务、文件句柄等，当工作完成时应该被释放，.net提供了<code>IDisposable</code>接口，让释放的概念更为明确。</p><p>在Autofac的生命周期作用域中，当工作单元完成时，嵌套的容易可以释放其中所有的实例。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">BeginLifetimeScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  scope<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>DisposableComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//using接受，该作用域中的组件都被释放</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果注册模式为<code>SingleInstance()</code>,也就是单例组件，那么他们将会存在于容器的整个生命周期内，也就是应用程序的生命周期，这就意味着组件直到结束都不会被释放。，=</p><h4 id="4-4-1-自动释放"><a href="#4-4-1-自动释放" class="headerlink" title="4.4.1 自动释放"></a>4.4.1 自动释放</h4><p>为了实现自动释放，你的组件必须实现<code>IDisposable</code>接口，<a href="https://www.wukailiving.cn/c-gc-ji-zhi.html#toc-heading-5">Disposable模式参考这篇文章</a>。</p><p>在生命周期作用域结尾组件的<code>Dispose()</code>方法自动会被调用。</p><h4 id="4-4-2-特定释放"><a href="#4-4-2-特定释放" class="headerlink" title="4.4.2 特定释放"></a>4.4.2 特定释放</h4><p>如果你的组件没有实现<code>IDisposable</code>接口，但是仍然需要在生命周期作用域的结尾完成一些释放工作，你可以使用<strong>释放生命周期事件。使用 <code>OnRelease()</code></strong>事件</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>SomeComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//在作用域结尾调用 CleanUp方法进行释放工作</span>       <span class="token punctuation">.</span><span class="token function">OnRelease</span><span class="token punctuation">(</span>instance <span class="token operator">=</span><span class="token operator">></span> instance<span class="token punctuation">.</span><span class="token function">CleanUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-3-禁止释放"><a href="#4-4-3-禁止释放" class="headerlink" title="4.4.3 禁止释放"></a>4.4.3 禁止释放</h4><p>我们可以禁止Autofac自动调用<code>Dispose</code>方法释放组件，在注册的时候使用<code>ExternallyOwned()</code>方法。</p><p>以这种方式注册的组件何时释放取决于你。</p><pre class="line-numbers language-csharp"><code class="language-csharp">builder<span class="token punctuation">.</span><span class="token generic-method function">RegisterType<span class="token punctuation">&lt;</span>SomeComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ExternallyOwned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一种是<code>Owend&lt;T&gt;</code>类型的自拥有组件，我们也是手动释放的。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> Owned<span class="token operator">&lt;</span>DisposableComponent<span class="token operator">></span> _service<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>Owned<span class="token operator">&lt;</span>DisposableComponent<span class="token operator">></span> service<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    _service <span class="token operator">=</span> service<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DoWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// _service is used for some task</span>    _service<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Here _service is no longer needed, so</span>    <span class="token comment" spellcheck="true">// it is released</span>    _service<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-4-以提供实例的方式注册"><a href="#4-4-4-以提供实例的方式注册" class="headerlink" title="4.4.4 以提供实例的方式注册"></a>4.4.4 以提供实例的方式注册</h4><p>使用提供实例的方式注册，Autofac也会帮你释放该组件。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//也会释放</span>builder<span class="token punctuation">.</span><span class="token function">RegisterInstance</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>TextWriter<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-生命周期事件（不太清楚作用）"><a href="#4-5-生命周期事件（不太清楚作用）" class="headerlink" title="4.5 生命周期事件（不太清楚作用）"></a>4.5 生命周期事件（不太清楚作用）</h3><h4 id="4-5-1-组件被激活时的事件"><a href="#4-5-1-组件被激活时的事件" class="headerlink" title="4.5.1 组件被激活时的事件"></a>4.5.1 组件被激活时的事件</h4><p>激活时的事件<code>OnActivating()</code>在组件被使用前触发。</p><p>我们可以利用该事件：</p><ul><li>切换成另一个实例或将其包装在代理中</li><li>做属性注入或者方法注入</li><li>执行其它初始化任务</li></ul><h2 id="5-配置"><a href="#5-配置" class="headerlink" title="5 配置"></a>5 配置</h2><p>可以通过JSON/XML文件配置Autofac。</p><h3 id="5-1-使用Microsoft-Configuration配置-4-0版本以上使用"><a href="#5-1-使用Microsoft-Configuration配置-4-0版本以上使用" class="headerlink" title="5.1 使用Microsoft Configuration配置(4.0版本以上使用)"></a>5.1 使用Microsoft Configuration配置(4.0版本以上使用)</h3><p>更多关于Microsoft Configuration的文档点击<strong><a href="https://www.nuget.org/packages/Microsoft.Extensions.Configuration" target="_blank" rel="noopener">这里</a></strong></p><p>例如一个含有简单注册的配置文件类似如下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"defaultAssembly"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator"</span><span class="token punctuation">,</span>  <span class="token property">"components"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition"</span><span class="token punctuation">,</span>    <span class="token property">"services"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator.Api.IOperation"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"injectProperties"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator.Division.Divide, Autofac.Example.Calculator.Division"</span><span class="token punctuation">,</span>    <span class="token property">"services"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator.Api.IOperation"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"parameters"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"places"</span><span class="token operator">:</span> <span class="token number">4</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然使用XML格式的也可以，推荐使用Json格式的，因为Json更容易读。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>autofac</span> <span class="token attr-name">defaultAssembly</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Autofac.Example.Calculator<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>components</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>Autofac.Example.Calculator.Addition.Add, Autofac.Example.Calculator.Addition<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>services</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Autofac.Example.Calculator.Api.IOperation<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>injectProperties</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>injectProperties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>components</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>components</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>Autofac.Example.Calculator.Division.Divide, Autofac.Example.Calculator.Division<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>services</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Autofac.Example.Calculator.Api.IOperation<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>injectProperties</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>injectProperties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parameters</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>places</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>places</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parameters</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>components</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>autofac</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后需要让AutoFac读取配置文件：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 添加配置文件至ConfiguraBuilder</span><span class="token keyword">var</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Microsoft.Extensions.Configuration.Json/Xml中包含config.AddJsonFile/AddXmlFile()方法</span>config<span class="token punctuation">.</span><span class="token function">AddJsonFile</span><span class="token punctuation">(</span><span class="token string">"autofac.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用Autofac注册配置模块。</span><span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationModule</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContainerBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">RegisterModule</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-1-默认程序集配置"><a href="#5-1-1-默认程序集配置" class="headerlink" title="5.1.1 默认程序集配置"></a>5.1.1 默认程序集配置</h4><p>我们可以在配置文件中指定一个默认程序集的配置项，这样可以缩短写类型的事件，如果你在一个类型或者接口的引用中没有指定一个程序集的类型名称，Autofac将会默认为在默认程序集配置项中的配置。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"defaultAssembly"</span><span class="token operator">:</span> <span class="token string">"Autofac.Example.Calculator"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-2-模块"><a href="#5-2-模块" class="headerlink" title="5.2 模块"></a>5.2 模块</h3><p>使用配置文件这一种方式在后期不易维护，使用<strong>模块这一种方式更具有灵活性。</strong></p><h4 id="5-2-1-例子"><a href="#5-2-1-例子" class="headerlink" title="5.2.1 例子"></a>5.2.1 例子</h4><p>模块需要实现<code>Autofac.Core.IModule</code>接口，通常继承<code>Autofac.Module</code>这一抽象类，复写<code>Load</code>方法，在此方法中注册组件。</p><p>代码示例：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CarTransportModule</span> <span class="token punctuation">:</span> Module<span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">bool</span> ObeySpeedLimit <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Load</span><span class="token punctuation">(</span>ContainerBuilder builder<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token generic-method function">Resolve<span class="token punctuation">&lt;</span>IDriver<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IVehicle<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ObeySpeedLimit<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//实例化理智司机</span>      builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">SaneDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IDriver<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">//实例化疯狂的司机</span>      builder<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">CrazyDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">As<span class="token punctuation">&lt;</span>IDriver<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模块是动态的，我们可以在Load方法里做一些类似于环境检查，根据环境来注册相应的组件。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Load</span><span class="token punctuation">(</span>ContainerBuilder builder<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Environment<span class="token punctuation">.</span>OSVersion<span class="token punctuation">.</span>Platform <span class="token operator">==</span> PlatformID<span class="token punctuation">.</span>Unix<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//unix系统</span>    <span class="token function">RegisterUnixPathFormatter</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token function">RegisterWindowsPathFormatter</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//windows系统</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Autofac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autofac中的依赖囚禁现象</title>
      <link href="/autofac-zhong-de-yi-lai-qiu-jin-xian-xiang.html"/>
      <url>/autofac-zhong-de-yi-lai-qiu-jin-xian-xiang.html</url>
      
        <content type="html"><![CDATA[<h2 id="依赖囚禁-俘获"><a href="#依赖囚禁-俘获" class="headerlink" title="依赖囚禁(俘获)"></a>依赖囚禁(俘获)</h2><p>发生条件：</p><p>一个短时间的组件被另一个长时间的组件所持有就会发生<strong>囚禁依赖</strong>。</p><p>Autofac不会阻止你创建被囚禁依赖，因为这是开发人员的责任，有时候因为囚禁的发生将会得到一个解析异常。</p><h3 id="1-如何避免囚禁依赖"><a href="#1-如何避免囚禁依赖" class="headerlink" title="1. 如何避免囚禁依赖"></a>1. 如何避免囚禁依赖</h3><p>避免囚禁依赖的一般准则是：</p><p><strong>使用该服务的组件的生命周期要小于等于正在使用的服务的生命周期。</strong></p><p><strong>例如：</strong></p><p>有一个Web应用，我们通过传入请求中的一些信息来决定连接到哪一个数据库。</p><p>你可能需要以下组件：</p><ul><li>接受当前请求和数据库连接工厂的repository</li><li>类似 <code>HttpContext</code> 的 <em>current request</em> ,可以用于决定业务逻辑. </li><li>一个数据库连接工厂（ <em>database connection factory</em> ），接受一系列参数并且返回正确的数据库连接</li></ul><p>在这个示例中，我们考虑以下应该为每个组件设定怎样的生命周期，而当前请求的上下文是一个很明显的上下文环境，我们可以将当前组件的生命周期设定为<strong>每个请求为同一实例（Instance Per Request）</strong>。</p><p>如果我们将<code>repository</code>设定为<strong>“单例”</strong>模式，即<code>SingleInstance</code>模式，那么这个实例将会缓存在应用的整个生命周期内，该请求上下文<code>(request context)</code>会被传入<code>repository</code>中，并在应用的整个生命周期中一直被<code>repository</code>所持有，即使当次请求已经结束了，这时候repository就是使用该服务的组件，而<code>HttpContext</code>就是正在使用的服务，<code>repository</code>是长期存在的，但是它却一直持有更小生存周期的组件，这就发生了<strong>囚禁依赖。</strong></p><p>如果你将repository也设定为<code>Instance Per Request</code>模式，那么它现在和当前请求存在一样长的生命周期，它们将会被同时释放，就不存在囚禁。</p><p>再进一步，我们将repository设定为<code>Instance Per Dependency</code>即每一次依赖就创建一个新实例，这样也是可以的，它的生命周期比当前请求还要短，也不会发生囚禁现象。</p><p>数据库连接工厂（ <em>database connection factory</em> ）思考过程与之类似，但也需要根据情况分析而选择不同生命周期模式，例如实例化数据库连接工厂比较耗费资源，或者你需要维护一些内部状态它才能正常的工作，这时候可能就需要使用单例模式了。</p><h3 id="2-应该由开发者决定是否可以接受依赖囚禁"><a href="#2-应该由开发者决定是否可以接受依赖囚禁" class="headerlink" title="2. 应该由开发者决定是否可以接受依赖囚禁"></a>2. 应该由开发者决定是否可以接受依赖囚禁</h3><p>我们在实际开发中，应该根据情况来决定是否可以接受依赖囚禁的发生。</p><p>例如你有一个缓存类（CacheClass）,它被有意设置为仅在消费组件的生命周期内缓存内容，如果该组件是单例的，那么该组件可以用于整个程序的生命周期中存储东西，如果是<code>Instance Per Request</code>模式，那么它只能存储单次Web请求的数据，在这种情况下选择单例模式更好，虽然发生了依赖囚禁现象，但是只要开发人员理解这样设置生存期的后果，这样也是可以接受的。</p><p>概括来说，<strong>依赖囚禁的发生应该是有意的而不是无意的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Autofac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#GC机制</title>
      <link href="/c-gc-ji-zhi.html"/>
      <url>/c-gc-ji-zhi.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-GC机制（垃圾回收）"><a href="#C-GC机制（垃圾回收）" class="headerlink" title="C#GC机制（垃圾回收）"></a>C#GC机制（垃圾回收）</h1><h2 id="1-资源"><a href="#1-资源" class="headerlink" title="1. 资源"></a>1. 资源</h2><h4 id="1-1-什么是资源"><a href="#1-1-什么是资源" class="headerlink" title="1.1 什么是资源"></a>1.1 什么是资源</h4><p>所谓资源就是程序中可利用的数据。</p><p>例如：字符串，图片等任何二进制数据，包括任何类型的文件。</p><p>在面向对象的环境中，每一个类型都标识为某些程序所用的资源，要想使用这些资源，必须为相应的类型分配一定的内存空间。 </p><h4 id="1-2-访问资源的步骤"><a href="#1-2-访问资源的步骤" class="headerlink" title="1.2  访问资源的步骤"></a>1.2  访问资源的步骤</h4><p>访问资源需要如下几个步骤：</p><p><strong>分配内存空间👉初始化内存👉使用资源👉销毁资源👉释放内存</strong></p><ol><li>分配内存空间：调用中间语言（IL）(使用new操作符时，将产生newobj指令)，为某个特定资源的类型分配一定的内存空间。</li><li>初始化内存：一个类型的实例构造器负责这样的初始化操作。</li><li>使用资源：通过访问类型成员来使用资源，根据需要可能会反复使用。</li><li>销毁资源：执行清理工作。</li><li>释放内存：托管堆上的内存由GC全权负责，值类型的在栈上的内存会随着栈空间的消亡而自动消失。</li></ol><h4 id="1-3-托管资源和非托管资源"><a href="#1-3-托管资源和非托管资源" class="headerlink" title="1.3 托管资源和非托管资源"></a>1.3 托管资源和非托管资源</h4><p><strong>托管资源：</strong></p><ul><li>指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。 </li><li>托管资源的回收工作是不需要人工干预的，有.NET运行库在合适调用垃圾回收器进行回收。 </li></ul><p><strong>非托管资源：</strong></p><ul><li>指的是.NET不知道如何回收的资源。</li><li>最常见的一类非托管资源是<strong>包装操作系统</strong>资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。 </li><li>这类资源，垃圾回收器在清理的时候会调用<code>Object.Finalize()</code>方法。  默认情况下，方法是空的，对于非托管对象，需要在此方法中<strong>编写回收非托管资源的代码</strong>，以便垃圾回收器正确回收资源。 </li><li>在.NET中，<code>Object.Finalize()</code>方法是无法重载的，编译器是根据类的<strong>析构函数</strong>来自动生成<code>Object.Finalize()</code>方法的，所以对于包含非托管资源的类，<strong>可以将释放非托管资源的代码放在析构函数。</strong> </li></ul><p><strong>注意点：</strong></p><ol><li>非托管资源GC无法释放，需要在析构函数中编写释放方法。</li><li>不能再析构函数中释放托管资源， <strong>因为析构函数是有垃圾回收器调用的，可能在析构函数调用之前，类包含的托管资源已经被回收了，从而导致无法预知的结果。</strong> </li></ol><h2 id="2-资源释放"><a href="#2-资源释放" class="headerlink" title="2. 资源释放"></a>2. 资源释放</h2><p>如何进行资源释放，.net提供了三种方法，也是最常见的方法：</p><ol><li>析构函数</li><li>继承IDisposable接口，实现Dispose方法</li><li>提供Close方法</li></ol><table><thead><tr><th></th><th>析构函数</th><th>Dispose方法</th><th>Close方法</th></tr></thead><tbody><tr><td>意义</td><td>销毁对象</td><td>销毁对象</td><td>关闭对象资源</td></tr><tr><td>调用方式</td><td>不能被显式调用，会被GC调用</td><td>需要显式调用或者通过using语句</td><td>需要显式调用</td></tr><tr><td>调用时机</td><td>不确定</td><td>确定，在显式调用或者离开using程序块</td><td>确定，在显式调用时</td></tr></tbody></table><h3 id="2-1-Dispose模式"><a href="#2-1-Dispose模式" class="headerlink" title="2.1 Dispose模式"></a>2.1 Dispose模式</h3><p>为了及时释放宝贵的非托管资源和托管资源，并且保证资源在被gc回收的时候可以正确释放资源，同时兼顾执行效率 </p><p>手动调用Dispose（） 可以释放所有资源，并且在gc标记不需要再调用析构函数，从而提高了效率。</p><p>如果忘记调用Dispose（）， 则当gc调用析构函数的时候也会把非托管资源释放掉</p><p><strong>IDisposable接口：</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// 摘要:</span>    <span class="token comment" spellcheck="true">//     提供一种用于释放非托管资源的机制。 若要浏览此类型的.NET Framework 源代码，请参阅Reference Source。</span>    <span class="token punctuation">[</span><span class="token function">ComVisible</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDisposable</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token comment" spellcheck="true">// 摘要:</span>        <span class="token comment" spellcheck="true">//     执行与释放或重置非托管资源关联的应用程序定义的任务。</span>        <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DisposablClass</span> <span class="token punctuation">:</span> IDisposable<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//是否回收完毕</span>    <span class="token keyword">bool</span> _disposed<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        GC<span class="token punctuation">.</span><span class="token function">SuppressFinalize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//标记gc不再调用析构函数，阻止GC去调用Finalize方法</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">DisposableClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//防止二次释放</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token keyword">bool</span> disposing<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>_disposed<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果已经被回收，就中断执行</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>disposing<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//TODO:释放本对象中管理的托管资源</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//TODO:释放非托管资源</span>        _disposed <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>问题：</strong></p><ol><li><p>为什么析构函数调用的dispose（false）不释放托管资源？ </p><p> 答：因为析构函数由gc来调用，gc会依次释放所有的死对象（不可到达），释放的顺序是随机的，如果在一个对象的析构里调用了一个本次gc已经释放的对象，就会发生释放两次的错误。 </p></li><li><p>既然gc是另外一线程执行的，为什么Dispose（bool）函数里不加锁？ </p><p>答：因为如果可以主动调用的时候，肯定此对象不是死对象，也不会被回收，因此不会同时调用到 </p></li></ol><h3 id="2-2-Close模式"><a href="#2-2-Close模式" class="headerlink" title="2.2 Close模式"></a>2.2 Close模式</h3><p>先做一个小测试：</p><pre class="line-numbers language-csharp"><code class="language-csharp">SqlConnection conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlConnection</span><span class="token punctuation">(</span><span class="token string">"连接字符串"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> conn<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先关闭</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>State<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接状态：关闭</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>ConnectionString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此时连接字符串还在</span>conn<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再打开。正常</span>conn<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先释放</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>State<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接状态：关闭</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>ConnectionString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接字符串已经置为空：string.Empty  </span>conn<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再打开。抛异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试结果：</p><ol><li>两个方法都关闭了数据库连接。</li><li>Close之后数据库连接可以再次打开，而DIspose之后连接字符串被清空，连接不能再次打开。</li></ol><p>总结：</p><ol><li><p>Dispose隐含Close，</p></li><li><p>Close负责关闭业务，Dispose负责销毁对象。Dispose会负责Close的一切事务，额外还有销毁对象的工作，即Dispose包含Close </p></li><li><p>当有明确需求的时候，不要混用二者 </p></li><li><p>两者连在一起用没什么意义。要么关闭以便再次使用，要么销毁不再使用。  </p><p>Close方法是不存在的，你不写就没有， 那为什么要加一个Close方法呢？为了避免不熟悉C#语法的开发人员更直观的释放资源，因此提供了Close方法。提供一个Close方法仅仅是为了更符合其他语言（如C++）的规范。正常情况Close方法里面会调用Dispose()方法。 </p></li></ol><h3 id="2-3-析构函数-Finalize-方法）"><a href="#2-3-析构函数-Finalize-方法）" class="headerlink" title="2.3 析构函数(Finalize 方法）"></a>2.3 析构函数(Finalize 方法）</h3><p> 来自百度百科）析构函数(destructor) 与<a href="http://baike.baidu.com/view/411124.htm" target="_blank" rel="noopener">构造函数</a>相反，当对象脱离其<a href="http://baike.baidu.com/view/657404.htm" target="_blank" rel="noopener">作用域</a>时（例如对象所在的函数已调用完毕），系统<strong>自动执行</strong>析构函数。析构函数往往用来做“清理善后” 的工作.</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeClass</span>    <span class="token punctuation">{</span>        <span class="token operator">~</span><span class="token function">FinalizeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//在这里，清理非托管资源</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Finalize方法只能由GC调用，我们是不能调用的。下面说下GC调用Finalize的流程！ </p><p><strong>Finalization List（Queue）（终结列表）</strong></p><p>我们new 一个对象，如果这个对象包含Finalize方法，开辟内存后，指向它的指针会被存放到<strong>终结列表</strong>中（Object对象除外）。 </p><p><strong>Freachable Queue （F-reachable终结可到达队列）</strong></p><p>垃圾回收开始时，被判定为垃圾（不可达）的对象如果同时存在于Finalization List中，就会将该对象的指针从Finalization List移除，并存入Freachable Queue中。同时这些对象都变为可达（reachable），不会被GC回收，这样就意味着这些对象提升到另一代，这里假设为2代对象。 </p><p>该队列中的对象都是可达的，并需要执行<code>Finalize</code>方法。执行<code>Finalize</code>方法是由一个高优先级的CLR线程进行的，执行完毕后，会将对象的指针从Freachable Queue中移除（当该队列为空时，此线程将睡眠，在不为空时被唤醒）。 </p><p>当再次进行垃圾回收时，原Freachable Queue中的对象经过处理都变为不可达对象（2代），只有当2代内存不足时才会对2代对象进行垃圾回收，这些对象内存才会真正释放掉。因此含有Finalize方法的对象最少要经过<strong>两次</strong>垃圾回收才会被真正释放 </p><p><strong>图解：</strong></p><p>2、3、5、6、10包含Finalize方法，所以被放入Finalization队列</p><p>垃圾回收开始 ，2、5、7、9为不可达对象，成为GC的目标。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/GC3.png" alt></p><p>进行GC时，由于2、5对象包含Finalize方法，因此被放入Freachable Queue中，变为可达对象并提升代，不进行垃圾回收。而对象7、9直接被回收。 </p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/GC1.png" alt></p><p>如果原Freachable所在代进行GC，就会回收对象2、5的内存。 </p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/GC2.png" alt></p><p><strong>总结：</strong></p><p>1.含有Finalize方法的对象最少要经过两次垃圾回收才会被真正释放。</p><p>2.如非必要，不建议定义Finalize方法（用Dispose模式替代）。</p><p><strong>参考博客：</strong></p><p> <a href="https://www.cnblogs.com/hetring/p/4755516.html" target="_blank" rel="noopener">https://www.cnblogs.com/hetring/p/4755516.html</a> </p><p> <a href="https://www.cnblogs.com/newlive/p/5393873.html" target="_blank" rel="noopener">https://www.cnblogs.com/newlive/p/5393873.html</a> </p><p> <a href="https://www.cnblogs.com/xyzf/p/9021513.html" target="_blank" rel="noopener">https://www.cnblogs.com/xyzf/p/9021513.html</a> </p><p> <a href="https://blog.csdn.net/zrf2112/article/details/50644652" target="_blank" rel="noopener">https://blog.csdn.net/zrf2112/article/details/50644652</a> </p><p> <a href="https://www.cnblogs.com/wuyuankun/p/4103620.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyuankun/p/4103620.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> C#基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC垃圾回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语法高级篇</title>
      <link href="/sql-gao-ji-pian.html"/>
      <url>/sql-gao-ji-pian.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL高级篇"><a href="#SQL高级篇" class="headerlink" title="SQL高级篇"></a>SQL高级篇</h2><h3 id="1-TOP-子句"><a href="#1-TOP-子句" class="headerlink" title="1. TOP 子句"></a>1. TOP 子句</h3><p> TOP 子句用于规定要返回的记录的数目。 </p><p> 对于拥有<strong>数千条</strong>记录的大型表来说，TOP 子句是非常有用的。 </p><p><strong><em>语法：</em></strong></p><p><strong><em>SQL Server 的语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> number<span class="token operator">|</span><span class="token keyword">percent</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>例子：</em></strong></p><p>从 “Persons” 表中选取头两条记录。 </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从 “Persons” 表中选取 50% 的记录。 </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">50</span> <span class="token keyword">PERCENT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="2-LIKE-操作符"><a href="#2-LIKE-操作符" class="headerlink" title="2. LIKE 操作符"></a>2. LIKE 操作符</h3><p>LIKE 操作符用于在 <strong>WHERE</strong> 子句中搜索列中的指定模式。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> pattern<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong><em>Persons 表</em></strong>： </p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p><strong><em>例子1：</em></strong></p><p> 从上面的 “Persons” 表中选取居住在以 “N” 开始的城市里的人： </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span class="token keyword">WHERE</span> City <span class="token operator">LIKE</span> <span class="token string">'N%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>提示：</strong><code>&quot;%&quot;</code> 可用于定义<strong>通配符</strong>（模式中缺少的字母）。 </p><p><strong><em>结果集：</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr></tbody></table><p><strong><em>例子2：</em></strong></p><p> 从 “Persons” 表中选取居住在以 “g” 结尾的城市里的人： </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span class="token keyword">WHERE</span> City <span class="token operator">LIKE</span> <span class="token string">'%g'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>结果集：</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p><strong><em>例子3：</em></strong></p><p> 从 “Persons” 表中选取居住在包含 “lon” 的城市里的人： </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span class="token keyword">WHERE</span> City <span class="token operator">LIKE</span> <span class="token string">'%lon%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>结果集：</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr></tbody></table><p><strong><em>例子4：</em></strong></p><p> 通过使用 <code>NOT</code> 关键字，我们可以从 “Persons” 表中选取居住在<em>不包含</em> “lon” 的城市里的人： </p><pre class="line-numbers language-sql"><code class="language-sql">SELSCT <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span class="token keyword">WHERE</span> City <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">'%lon%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3. 通配符"></a>3. 通配符</h3><p> SQL 通配符<strong>必须</strong>与 LIKE 运算符一起使用。 </p><p> 在 SQL 中，可使用以下通配符： </p><table><thead><tr><th align="left">通配符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">%</td><td align="left">替代一个或多个字符</td></tr><tr><td align="left">_</td><td align="left">仅替代一个字符</td></tr><tr><td align="left">[charlist]</td><td align="left">字符列中的任何单一字符</td></tr><tr><td align="left">[^charlist]或者[!charlist]</td><td align="left">不在字符列中的任何单一字符</td></tr></tbody></table><p>%和_使用方法省略…</p><p><strong>使用[charlist]通配符：</strong></p><p><strong><em>Persons 表:</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p> 从上面的 “Persons” 表中选取居住的城市以 “A” 或 “L” 或 “N” 开头的人： </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons <span class="token keyword">WHERE</span> City <span class="token operator">LIKE</span> <span class="token string">'[ALN]%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="4-IN-操作符"><a href="#4-IN-操作符" class="headerlink" title="4. IN 操作符"></a>4. IN 操作符</h3><p> IN 操作符允许我们在 WHERE 子句中规定<strong>多个值</strong>。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">IN</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>Persons 表:</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p><strong><em>例子：</em></strong></p><p> 从上表中选取姓氏为 Adams 和 Carter 的人： </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Persons<span class="token keyword">WHERE</span> FirstName <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'Adams'</span><span class="token punctuation">,</span><span class="token string">'Carter'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="5-BETWEEN-操作符"><a href="#5-BETWEEN-操作符" class="headerlink" title="5. BETWEEN 操作符"></a>5. BETWEEN 操作符</h3><p> 操作符 BETWEEN … AND 会选取<strong>介于两个值之间的数据范围</strong>。这些值可以是数值、文本或者日期。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name<span class="token operator">BETWEEN</span> value1 <span class="token operator">AND</span> value2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Persons 表:</em></strong></p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">4</td><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><p><strong><em>例1：</em></strong></p><p>查询 Id在1和3之间的人（在SQL Server 中包含1和3）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Person<span class="token keyword">WHERE</span> Id<span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>例2：</em></strong></p><p>使用上面的例子，显示范围之外的人，使用NOT 操作符</p><pre><code>SELECT * FROM PersonWHERE IdNOT BETWEEN 1 AND 3</code></pre><hr><h3 id="6-JOIN-关键字"><a href="#6-JOIN-关键字" class="headerlink" title="6. JOIN 关键字"></a>6. JOIN 关键字</h3><p> <strong>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</strong> </p><p>有时为了得到完整的结果，我们需要从<strong>两个或更多</strong>的表中获取结果。我们就需要执行 join。</p><p>数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。</p><p> <strong>*”Persons” 表：*</strong>主键为<code>Id_P</code></p><table><thead><tr><th align="left">Id_P</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p> <strong>*”Orders” 表：*</strong> 主键为<code>Id_O</code>外键为Id_P</p><table><thead><tr><th align="left">Id_O</th><th align="left">OrderNo</th><th align="left">Id_P</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">77895</td><td align="left">3</td></tr><tr><td align="left">2</td><td align="left">44678</td><td align="left">3</td></tr><tr><td align="left">3</td><td align="left">22456</td><td align="left">1</td></tr><tr><td align="left">4</td><td align="left">24562</td><td align="left">1</td></tr><tr><td align="left">5</td><td align="left">34764</td><td align="left">65</td></tr></tbody></table><h4 id="6-1-使用引用的方式"><a href="#6-1-使用引用的方式" class="headerlink" title="6.1 使用引用的方式"></a>6.1 使用引用的方式</h4><p><strong><em>例子1：</em></strong></p><p> 从两个表中查出谁订购了产品，并且他们订购了什么产品？ </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span>p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span>o<span class="token punctuation">.</span>OrderNo<span class="token keyword">FROM</span> Person <span class="token keyword">AS</span> p<span class="token punctuation">,</span>Orders <span class="token keyword">AS</span> o<span class="token keyword">WHERE</span> p<span class="token punctuation">.</span>Id_P<span class="token operator">=</span>o<span class="token punctuation">.</span>Id_P<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>LastName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-使用INNER-JOIN-关键字"><a href="#6-2-使用INNER-JOIN-关键字" class="headerlink" title="6.2 使用INNER JOIN 关键字"></a>6.2 使用INNER JOIN 关键字</h4><p> 在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 </p><p><code>INNER JOIN</code> 也可以写作 <code>JOIN</code>，两者相同。</p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table_name2 <span class="token keyword">ON</span> table_name1<span class="token punctuation">.</span>column_name<span class="token operator">=</span>table_name2<span class="token punctuation">.</span>column_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span>p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span>o<span class="token punctuation">.</span>OrderNo<span class="token keyword">FROM</span> Persons <span class="token keyword">AS</span> p<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">AS</span> o<span class="token keyword">ON</span> p<span class="token punctuation">.</span>Id_P<span class="token operator">=</span>o<span class="token punctuation">.</span>Id_P<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>LastName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>两种方式的结果都是：</em></strong></p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">OrderNo</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">22456</td></tr><tr><td align="left">Adams</td><td align="left">John</td><td align="left">24562</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">77895</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">44678</td></tr></tbody></table><h4 id="6-3-LEFT-JOIN-关键字"><a href="#6-3-LEFT-JOIN-关键字" class="headerlink" title="6.3 LEFT JOIN 关键字"></a>6.3 LEFT JOIN 关键字</h4><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，<strong>即使在右表 (table_name2) 中没有匹配的行。</strong> </p><p><strong>“左表为主”</strong></p><p><strong><em>语法：</em></strong>把 <code>INNER</code> 改成了 <code>LEFT</code></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table_name2 <span class="token keyword">ON</span> table_name1<span class="token punctuation">.</span>column_name<span class="token operator">=</span>table_name2<span class="token punctuation">.</span>column_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>注释：</strong>在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。 </p><p><strong><em>例子：</em></strong></p><p> 列出<strong>所有</strong>的人，以及他们的定购 - <strong>如果有的话。</strong> </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> o<span class="token punctuation">.</span>OrderNo<span class="token keyword">FROM</span> Persons <span class="token keyword">AS</span> p<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">AS</span> o<span class="token keyword">ON</span> p<span class="token punctuation">.</span>Id_P<span class="token operator">=</span>o<span class="token punctuation">.</span>Id_P<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>LastName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">OrderNo</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">22456</td></tr><tr><td align="left">Adams</td><td align="left">John</td><td align="left">24562</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">77895</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">44678</td></tr><tr><td align="left">Bush</td><td align="left">George</td><td align="left"></td></tr></tbody></table><p>可以看到，LastName为Bush的这一行，OrderNo为空，这是因为我们使用的时LEFT JOIN 以左表为主，而左表为Persons表，所以就算某一个人没有订单，他也会被列出来。</p><h4 id="6-4-RIGHT-JOIN"><a href="#6-4-RIGHT-JOIN" class="headerlink" title="6.4 RIGHT JOIN"></a>6.4 RIGHT JOIN</h4><p> RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。</p><p><strong><em>语法：</em></strong>相较于INNER JOIN ，将<code>INNER</code>改成了<code>RIGHT</code> </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name1<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> table_name2 <span class="token keyword">ON</span> table_name1<span class="token punctuation">.</span>column_name<span class="token operator">=</span>table_name2<span class="token punctuation">.</span>column_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>注释：</strong>在某些数据库中， RIGHT JOIN 称为 RIGHT OUTER JOIN。 </p><p><strong><em>例子：</em></strong></p><p> 列出所有的定单，以及定购它们的人 - 如果有的话。 </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> o<span class="token punctuation">.</span>OrderNo<span class="token keyword">FROM</span> Persons <span class="token keyword">AS</span> p<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">AS</span> o<span class="token keyword">ON</span> p<span class="token punctuation">.</span>Id_P<span class="token operator">=</span>o<span class="token punctuation">.</span>Id_P<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>LastName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">OrderNo</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">22456</td></tr><tr><td align="left">Adams</td><td align="left">John</td><td align="left">24562</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">77895</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">44678</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">34764</td></tr></tbody></table><p>其实可以将RIGHT JOIN 中的Persons表和Order表换个位置也可以得到相同的结果集。</p><h4 id="6-5-FULL-JOIN"><a href="#6-5-FULL-JOIN" class="headerlink" title="6.5 FULL JOIN"></a>6.5 FULL JOIN</h4><p>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name1<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> table_name2 <span class="token keyword">ON</span> table_name1<span class="token punctuation">.</span>column_name<span class="token operator">=</span>table_name2<span class="token punctuation">.</span>column_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子：</em></strong></p><p> 列出所有的人，以及他们的定单，以及所有的定单，以及定购它们的人。 </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> o<span class="token punctuation">.</span>OrderNo<span class="token keyword">FROM</span> Persons <span class="token keyword">AS</span> p<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Orders <span class="token keyword">AS</span> o<span class="token keyword">ON</span> p<span class="token punctuation">.</span>Id_P<span class="token operator">=</span>o<span class="token punctuation">.</span>Id_P<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>LastName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">OrderNo</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">22456</td></tr><tr><td align="left">Adams</td><td align="left">John</td><td align="left">24562</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">77895</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">44678</td></tr><tr><td align="left">Bush</td><td align="left">George</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">34764</td></tr></tbody></table><p> FULL JOIN 关键字会从左表 (Persons) 和右表 (Orders) 那里返回所有的行。如果 “Persons” 中的行在表 “Orders” 中没有匹配，或者如果 “Orders” 中的行在表 “Persons” 中没有匹配，这些行同样会列出。 </p><h3 id="7-UNION和UNION-ALL操作符"><a href="#7-UNION和UNION-ALL操作符" class="headerlink" title="7. UNION和UNION ALL操作符"></a>7. UNION和UNION ALL操作符</h3><h4 id="7-1-UNION-操作符"><a href="#7-1-UNION-操作符" class="headerlink" title="7.1  UNION 操作符"></a>7.1  UNION 操作符</h4><p> UNION 操作符用于合并两个或多个 <strong>SELECT 语句</strong>的结果集。 </p><p> <strong>注意：</strong></p><ol><li>UNION内部的SELECT语句必须拥有相同数量的列</li><li>列必须拥有相似的数据类型</li><li>每条SELECT语句中的列的顺序必须相同</li></ol><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行之后， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 </p><p><strong><em>例子：</em></strong></p><p><strong><em>Employees_China:</em></strong></p><table><thead><tr><th align="left">E_ID</th><th align="left">E_Name</th></tr></thead><tbody><tr><td align="left">01</td><td align="left">Zhang, Hua</td></tr><tr><td align="left">02</td><td align="left">Wang, Wei</td></tr><tr><td align="left">03</td><td align="left">Carter, Thomas</td></tr><tr><td align="left">04</td><td align="left">Yang, Ming</td></tr></tbody></table><p><strong><em>Employees_USA:</em></strong></p><table><thead><tr><th align="left">E_ID</th><th align="left">E_Name</th></tr></thead><tbody><tr><td align="left">01</td><td align="left">Adams, John</td></tr><tr><td align="left">02</td><td align="left">Bush, George</td></tr><tr><td align="left">03</td><td align="left">Carter, Thomas</td></tr><tr><td align="left">04</td><td align="left">Gates, Bill</td></tr></tbody></table><p> 列出所有在中国和美国的不同的雇员名： </p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT E_Name FROM Employees_ChinaUNIONSELECT E_Name FROM Employees_USA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><table><thead><tr><th align="left">E_Name</th></tr></thead><tbody><tr><td align="left">Zhang, Hua</td></tr><tr><td align="left">Wang, Wei</td></tr><tr><td align="left">Carter, Thomas</td></tr><tr><td align="left">Yang, Ming</td></tr><tr><td align="left">Adams, John</td></tr><tr><td align="left">Bush, George</td></tr><tr><td align="left">Gates, Bill</td></tr></tbody></table><p><strong>注意：</strong></p><p>使用UNION命令之后，重名的雇员仅仅只列出了一位， <strong>UNION 命令只会选取不同的值。</strong> </p><h4 id="7-2-UNION-ALL操作符"><a href="#7-2-UNION-ALL操作符" class="headerlink" title="7.2 UNION ALL操作符"></a>7.2 UNION ALL操作符</h4><p> UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。 </p><hr><h3 id="8-SELECT-INTO-语句"><a href="#8-SELECT-INTO-语句" class="headerlink" title="8. SELECT  INTO 语句"></a>8. SELECT  INTO 语句</h3><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p><p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT column_name(s)INTO new_table_name [IN externaldatabase] FROM old_tablename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>例子1：</em></strong></p><p>制作备份附件</p><p>制作Persons表的备份附件Persons_backup</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *INTO Persons_backupFROM Persons<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> IN 子句可用于向<strong>另一个</strong>数据库中拷贝表： </p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT *INTO Persons IN 'Backup.mdb'FROM Persons<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>例子2：</em></strong></p><p> 从一个以上的表中选取数据 </p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT Persons.LastName,Orders.OrderNoINTO Persons_Order_BackupFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_P<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="9-CREATE-DATABASE-语句"><a href="#9-CREATE-DATABASE-语句" class="headerlink" title="9. CREATE DATABASE 语句"></a>9. CREATE DATABASE 语句</h3><p> CREATE DATABASE 用于创建数据库。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE DATABASE database_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="10-CREATE-TABLE-语句"><a href="#10-CREATE-TABLE-语句" class="headerlink" title="10.  CREATE TABLE 语句"></a>10.  CREATE TABLE 语句</h3><p> CREATE TABLE 语句用于创建数据库中的表。 </p><p><strong><em>语法：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子：</em></strong></p><p>创建Persons表， 该表包含 5 个列，列名分别是：</p><ul><li>“Id_P”</li><li>“LastName”</li><li>“FirstName”</li><li>“Address” </li><li>“City”：</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><table><thead><tr><th align="left">Id_P</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><hr><h3 id="11-SQL-约束（Constraints）⭐"><a href="#11-SQL-约束（Constraints）⭐" class="headerlink" title="11. SQL 约束（Constraints）⭐"></a>11. SQL 约束（Constraints）⭐</h3><p>约束用于限制加入表的数据的类型。</p><p>可以在创建表时规定约束（通过 <code>CREATE TABLE</code> 语句），或者在表创建之后也可以（通过 <code>ALTER TABLE</code> 语句）。</p><p>有以下几种约束：</p><ul><li>NOT NULL (不接受NULL)</li><li>UNIQUE （唯一标识）</li><li>PRIMARY KEY （主键）</li><li>FOREIGN KEY （外键）</li><li>CHECK  （值范围）</li><li>DEFAULT （默认值）</li></ul><h4 id="11-1-NOT-NULL约束"><a href="#11-1-NOT-NULL约束" class="headerlink" title="11.1 NOT NULL约束"></a>11.1 NOT NULL约束</h4><p> NOT NULL 约束强制列不接受 NULL 值。 </p><p> NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 </p><p><strong><em>例子：</em></strong></p><p> 强制 “Id_P” 列和 “LastName” 列不接受 NULL 值： </p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-2-UNIQUE-约束"><a href="#11-2-UNIQUE-约束" class="headerlink" title="11.2 UNIQUE 约束"></a>11.2 UNIQUE 约束</h4><p> UNIQUE 约束<strong>唯一标识</strong>数据库表中的每条记录。 </p><p> UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p><p> PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p><p><strong><em>注意：</em></strong></p><p> 每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 </p><p><strong><em>例子1：在数据表创建时，给列创建UNIQUE约束</em></strong></p><p> 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束： </p><p><strong><em>MySQL：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),    UNIQUE (Id_P))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>给多个列添加UNIQUE约束，并且给UNIQUE约束命名：</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonId UNIQUE (Id_P,LastName))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uc_PersonId</code>为UNIQUE名称。</p><p><strong><em>例子2：当表以被创建之后，创建UNIQUE约束</em></strong></p><p> 当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL： </p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD UNIQUE (Id_P)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法： </p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>例子3：撤销UNIQUE约束</em></strong></p><p><strong>MySQL:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP INDEX uc_PersonID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="11-3-Primary-Key-约束"><a href="#11-3-Primary-Key-约束" class="headerlink" title="11.3 Primary Key 约束"></a>11.3 Primary Key 约束</h4><p> PRIMARY KEY 约束唯一标识数据库表中的每条记录。 </p><ul><li>主键必须包含唯一的值。 </li><li>主键列不能包含 NULL 值。 </li><li>每个表都应该有一个主键，并且每个表只能有一个主键。 </li></ul><p><strong><em>例子1：在创建表时给列添加主键</em></strong></p><p><strong>MySQL:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (Id_P))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子2：定义联合主键并且给键命名</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子3：表被创建好之后添加主键</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD PRIMARY KEY (Id_P)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>给主键命名：</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>例子4：撤销主键</em></strong></p><p><strong>MySQL:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP PRIMARY KEY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="11-4-FOREIGN-KEY-约束"><a href="#11-4-FOREIGN-KEY-约束" class="headerlink" title="11.4  FOREIGN KEY 约束"></a>11.4  FOREIGN KEY 约束</h4><p> 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 </p><p><strong><em>例子1：创建外键</em></strong></p><p><strong>MySQL:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),FOREIGN KEY (Id_P) REFERENCES Persons(Id_P))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Orders(Id_O int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,Id_P int FOREIGN KEY REFERENCES Persons(Id_P))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子2：多个列定义外键约束，并且命名</em></strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)REFERENCES Persons(Id_P))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子3：表存在情况下，增加约束</em></strong></p><p><strong>MySQL / SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE OrdersADD FOREIGN KEY (Id_P)REFERENCES Persons(Id_P)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法：</p><p><strong>MySQL / SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (Id_P)REFERENCES Persons(Id_P)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子4：撤销外键约束</em></strong></p><p><strong>MySQL:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h4 id="11-5-CHECK-约束"><a href="#11-5-CHECK-约束" class="headerlink" title="11.5 CHECK 约束"></a>11.5 CHECK 约束</h4><p> CHECK 约束用于限制列中的值的范围。 </p><ul><li>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 </li><li>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。 </li></ul><p><strong><em>例子1：在表创建时添加CHECK约束</em></strong></p><p><strong>SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL CHECK (Id_P>0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子2：多个列定义CHECK约束并且命名</em></strong></p><p><strong>MySQL / SQL Server / Oracle / MS Access:</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>例子3：ALTER TABLE</em></strong></p><p>MySQL / SQL Server / Oracle / MS Access:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD CHECK (Id_P>0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命名：</p><p>MySQL / SQL Server / Oracle / MS Access:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (Id_P>0 AND City='Sandnes')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>例子4：撤销</em></strong></p><p>如需撤销 CHECK 约束，请使用下面的 SQL：</p><p>SQL Server / Oracle / MS Access:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP CONSTRAINT chk_Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MySQL:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsDROP CHECK chk_Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h4 id="11-6-Default"><a href="#11-6-Default" class="headerlink" title="11.6 Default"></a>11.6 Default</h4><p>DEFAULT 约束用于向列中插入默认值。</p><p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p><p><strong><em>例子1:ALTER TABLE 下的DEFAULT</em></strong></p><p>MySQL:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SQL Server / Oracle / MS Access:</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE PersonsALTER COLUMN City SET DEFAULT 'SANDNES'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>例子2：撤销</em></strong></p><p>如需撤销 DEFAULT 约束，请使用下面的 SQL：</p><p>MySQL:</p><pre><code>ALTER TABLE PersonsALTER City DROP DEFAULT</code></pre><p>SQL Server / Oracle / MS Access:</p><pre><code>ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT</code></pre><h3 id="12-CREATE-INDEX-语句"><a href="#12-CREATE-INDEX-语句" class="headerlink" title="12. CREATE INDEX 语句"></a>12. CREATE INDEX 语句</h3><p>您可以在表中创建索引，以便更加快速高效地查询数据。</p><p>用户无法看到索引，它们只能被用来加速搜索/查询。</p><p><strong>注释：</strong>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被<strong>搜索的列</strong>（以及表）上面创建索引。</p><p><strong><em>语法：</em></strong></p><p>CREATE INDEX</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE INDEX index_nameON table_name (column_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>CREATE UNIQUE INDEX 唯一索引</p><p> 唯一的索引意味着两个行不能拥有相同的索引值。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语法扩展篇</title>
      <link href="/sql-kuo-zhan-pian.html"/>
      <url>/sql-kuo-zhan-pian.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语法扩展篇"><a href="#SQL语法扩展篇" class="headerlink" title="SQL语法扩展篇"></a>SQL语法扩展篇</h1><h2 id="1-SQL中EXISTS的用法"><a href="#1-SQL中EXISTS的用法" class="headerlink" title="1.SQL中EXISTS的用法"></a>1.SQL中EXISTS的用法</h2><ul><li><p>EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值<code>True</code>或<code>False</code></p></li><li><p>一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。 </p></li></ul><p><strong>传送门</strong>👉<strong><a href="https://www.cnblogs.com/netserver/archive/2008/12/25/1362615.html" target="_blank" rel="noopener">EXISTS的用法1</a></strong>、<strong><a href="https://www.cnblogs.com/netserver/archive/2008/12/25/1362615.html" target="_blank" rel="noopener">EXISTS的用法2</a></strong>、</p><h2 id="2-EXISTS-和-IN-的比较"><a href="#2-EXISTS-和-IN-的比较" class="headerlink" title="2.EXISTS 和 IN 的比较"></a>2.EXISTS 和 IN 的比较</h2><ul><li>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。 </li></ul><p><strong>传送门</strong>👉<strong><a href="https://www.cnblogs.com/clarke157/p/7912871.html" target="_blank" rel="noopener">SQL中IN和EXISTS用法的区别</a></strong></p><h2 id="3-ANY-和-ALL"><a href="#3-ANY-和-ALL" class="headerlink" title="3.ANY 和 ALL"></a>3.ANY 和 ALL</h2><p><strong>传送门</strong>👉<a href="https://www.cnblogs.com/feiquan/p/8654171.html" target="_blank" rel="noopener">ANY、ALL、SOME的用法</a></p><h2 id="4-Privot的用法"><a href="#4-Privot的用法" class="headerlink" title="4.Privot的用法"></a>4.Privot的用法</h2><ul><li>行转列 可以替代 CASE WHEN</li></ul><p>传送门👉<a href="https://www.cnblogs.com/rockywood/p/6560648.html" target="_blank" rel="noopener">Privot的用法</a>、<a href="https://www.cnblogs.com/simple-blog/p/4371240.html" target="_blank" rel="noopener">纵横表转换</a></p><h2 id="5-CASE-WHEN-THEN"><a href="#5-CASE-WHEN-THEN" class="headerlink" title="5.CASE WHEN THEN"></a>5.CASE WHEN THEN</h2><ul><li>判断语句</li></ul><p>传送门👉 <a href="https://www.cnblogs.com/zybcn/p/8931297.html" target="_blank" rel="noopener">CASE WHEN的用法</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础篇</title>
      <link href="/vue-xue-xi.html"/>
      <url>/vue-xue-xi.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础篇"><a href="#Vue基础篇" class="headerlink" title="Vue基础篇"></a>Vue基础篇</h1><p>前端是第一生产力😋</p><h2 id="一-Vue实例"><a href="#一-Vue实例" class="headerlink" title="一. Vue实例"></a>一. Vue实例</h2><h3 id="1-1-声明式渲染"><a href="#1-1-声明式渲染" class="headerlink" title="1.1 声明式渲染"></a>1.1 声明式渲染</h3><p><code>Vue.js</code>的核心是一个允许采用简洁的<strong>模板语法</strong>来<strong>声明式地将数据渲染进 DOM 的系统：</strong> </p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     {{content}} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-Vue生命周期"><a href="#1-2-Vue生命周期" class="headerlink" title="1.2 Vue生命周期"></a>1.2 Vue生命周期</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue声明周期"></p><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>        template<span class="token punctuation">:</span><span class="token string">"&lt;div>hello world&lt;/div>"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//创建之前</span>        beforeCreate<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'before Create'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">//创建之后</span>        created<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'create'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//页面挂载前（未渲染）</span>        beforeMount<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'beforeMount'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//页面挂载后</span>        mounted<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Mounted'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//当 vm.$destroy()调用时</span>        beforeDestroy<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'beforeDestyor'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        destroyed<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'destroyed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//当数据更改时</span>        beforeUpdate<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        updated<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-Vue指令"><a href="#二-Vue指令" class="headerlink" title="二. Vue指令"></a>二. Vue指令</h2><p> <strong>数据绑定：</strong></p><p> <strong>绑定数据有三种方式，插值，v-model和v-bind。</strong> </p><h3 id="2-1-v-model"><a href="#2-1-v-model" class="headerlink" title="2.1 v-model"></a>2.1 v-model</h3><p> <strong>v-model</strong>是一个指令，实现数据<strong>双向绑定</strong>，再表单元素外使用不起作用，限制在<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>、<code>components</code>中使用 </p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>inputValue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> //绑定数据inputValue    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span> <span class="token punctuation">{</span>                inputValue<span class="token punctuation">:</span> <span class="token string">''</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-v-bind"><a href="#2-2-v-bind" class="headerlink" title="2.2 v-bind"></a>2.2 v-bind</h3><p> <strong>v-bind</strong> 指令被用来响应地更新 HTML 属性，其实它是支持一个单一 JavaScript 表达式 （<code>v-for</code> 除外）。 </p><p> 其缩写为—- <code>:</code></p><pre class="line-numbers language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 完整语法 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 缩写 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-v-on"><a href="#2-3-v-on" class="headerlink" title="2.3 v-on"></a>2.3 v-on</h3><p><strong>v-on</strong> 指令用来绑定事件。</p><p>其缩写为—-<code>@</code></p><pre class="line-numbers language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 完整语法 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>handleBtnClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 缩写 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">@:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>handleBtnClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>                handleBtnClick<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//dosomething...</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-v-for"><a href="#2-4-v-for" class="headerlink" title="2.4 v-for"></a>2.4 v-for</h3><p> <strong>v-for 可以绑定数据到数组来渲染一个列表：</strong> </p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span> <span class="token punctuation">{</span>                list<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>v-for 可以通过一个对象的属性来迭代数据：</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value in object<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    {{ value }}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    object<span class="token punctuation">:</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> <span class="token string">'wukai'</span><span class="token punctuation">,</span>      age<span class="token punctuation">:</span> <span class="token number">18</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>输出：     wukai    18</code></pre><p> <strong>你也可以提供第二个的参数为键名：</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(value, key) in object<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    {{ key }} : {{ value }}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>输出：    name : wukai    age : 18</code></pre><p> <strong>第三个参数为索引：</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(value, key, index) in object<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     {{ index }}. {{ key }} : {{ value }}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>输出：    0. name : wukai    1. age : 18</code></pre><p><strong>v-for实现列表渲染，key值唯一且不为index可以最大化提高性能</strong></p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) of list<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            {{item.text}}----{{index}}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span><span class="token punctuation">{</span>     list<span class="token punctuation">:</span><span class="token punctuation">[</span>         <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token string">"AKL001"</span><span class="token punctuation">,</span>text<span class="token punctuation">:</span><span class="token string">"Wukai"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token string">"AKL002"</span><span class="token punctuation">,</span>text<span class="token punctuation">:</span>"XXXXX<span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token string">"AKL003"</span><span class="token punctuation">,</span>text<span class="token punctuation">:</span><span class="token string">"XXXXXXXX"</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>直接操作数组改变数组某一项的值不会使页面改变，若想改变需要使用数组变异方法：</strong>    </p><pre><code>push, pop,shift, unshift, splice, sort, reverse</code></pre><p><strong>使用Set方法修改对象或数组，让页面发生变化:</strong>        </p><pre class="line-numbers language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>obj<span class="token punctuation">,</span><span class="token string">"property"</span><span class="token punctuation">,</span><span class="token string">"value"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-v-if-v-else"><a href="#2-5-v-if-v-else" class="headerlink" title="2.5 v-if / v-else"></a>2.5 v-if / v-else</h3><p><strong>v-if的值为’true’时显示则v-else不显示，两个标签要挨着写。</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"show"</span><span class="token operator">></span>v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>      <span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">></span><span class="token keyword">else</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span><span class="token punctuation">{</span>            show<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>             <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>默认条件渲染会复用标签，增加key值之后就会取消标签的复用。</strong></p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>show<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        邮箱：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三-计算属性和侦听器"><a href="#三-计算属性和侦听器" class="headerlink" title="三. 计算属性和侦听器"></a>三. 计算属性和侦听器</h2><h3 id="3-1-计算属性"><a href="#3-1-计算属性" class="headerlink" title="3.1 计算属性"></a>3.1 计算属性</h3><h4 id="3-1-1-计算属性"><a href="#3-1-1-计算属性" class="headerlink" title="3.1.1 计算属性"></a>3.1.1 计算属性</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  {{ message.split('').reverse().join('') }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Computed fullName: "{{ fullName }}"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#example'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token string">'Wu'</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">'Kai'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//computed 计算属性</span>  computed<span class="token punctuation">:</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//计算属性的getter</span>        fullName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// `this` 指向 vm 实例</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以打开浏览器的控制台，自行修改例子中的 <code>vm</code>。<code>vm.fullName</code> 的值始终取决于 <code>vm.firstName</code>和<code>vm.lastName</code> 的值。 </p><p> Vue 知道 <code>vm.fullName</code> 依赖于 <code>vm.lastName</code>和<code>vm.firstName</code>，因此当 <code>vm.firstName</code> 发生改变时，所有依赖 <code>vm.fullName</code> 的绑定也会更新。 </p><p><strong>计算得到的属性的，计算执行一次后，将结果存储在缓存中，如果依赖属性没有变化，则不再执行计算，性能高。</strong></p><h4 id="3-1-2-计算属性的get和set"><a href="#3-1-2-计算属性的get和set" class="headerlink" title="3.1.2 计算属性的get和set"></a>3.1.2 计算属性的get和set</h4><p> 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： </p><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">//计算属性</span>        computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>            fullName<span class="token punctuation">:</span> <span class="token punctuation">{</span>                <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">//当值被重置时，获得设置值</span>                <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">var</span> arr<span class="token operator">=</span>value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">=</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">=</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-侦听器"><a href="#3-2-侦听器" class="headerlink" title="3.2 侦听器"></a>3.2 侦听器</h3><p><strong>监听某一属性，当监听的属性值发生变化之后，触发函数。</strong></p><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的<strong>侦听器</strong>。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 </p><pre class="line-numbers language-javascript"><code class="language-javascript">    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token string">'Wu'</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">'Kai'</span><span class="token punctuation">,</span>        fullName<span class="token punctuation">:</span><span class="token string">"WuKai"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>fullName<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>fullName<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码，当<code>firstName</code>或者<code>lastName</code>改变时，触发函数，相应的改变<code>fullName</code>的值。</p><h3 id="3-3-方法vs计算属性"><a href="#3-3-方法vs计算属性" class="headerlink" title="3.3 方法vs计算属性"></a>3.3 方法vs计算属性</h3><p>我们可以通过在表达式中调用方法来达到同样的效果：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>fullName: "{{ fullName() }}"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">      <span class="token comment" spellcheck="true">//在组件中</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token string">'Wu'</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">'Kai'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        fullName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 </p><p> 然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。 </p><p> 只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>firstName</code> 还没有发生改变，多次访问 <code>fullName</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p><h2 id="四-Class与Style绑定"><a href="#四-Class与Style绑定" class="headerlink" title="四. Class与Style绑定"></a>四. Class与Style绑定</h2><p>我们可以用b-bind 绑定Dom元素的Class或者Style，并且绑定的表达式类型除了字符串之外，还可以是对象或者数组。</p><h3 id="4-1-Class绑定"><a href="#4-1-Class绑定" class="headerlink" title="4.1 Class绑定"></a>4.1 Class绑定</h3><h4 id="4-1-1-绑定一个对象"><a href="#4-1-1-绑定一个对象" class="headerlink" title="4.1.1 绑定一个对象"></a>4.1.1 绑定一个对象</h4><p> <strong>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</strong> </p><pre class="line-numbers language-css"><code class="language-css"> <span class="token selector"><span class="token class">.redFontColorClass</span></span><span class="token punctuation">{</span>     <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>     <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>     <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{redFontColorClass: IsActivated}<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        Hello wk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        IsActivated<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 上面的语法表示 <code>redFontColorClass</code> 这个 class 存在与否将取决于数据属性 <code>IsActivated</code> 的 truthiness(真值)</p><h4 id="4-1-2-与普通class属性并存"><a href="#4-1-2-与普通class属性并存" class="headerlink" title="4.1.2 与普通class属性并存"></a>4.1.2 与普通class属性并存</h4><p> <strong><code>v-bind:class</code> 指令也可以与普通的 class 属性共存。当有如下模板:</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ active: isActive, <span class="token punctuation">'</span>text-danger<span class="token punctuation">'</span>: hasError }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  isActive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  hasError<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果渲染为：</p><pre class="line-numbers language-vue"><code class="language-vue"><div class="static active"></div><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。 </p><h4 id="4-1-3-绑定的对象定义在data中"><a href="#4-1-3-绑定的对象定义在data中" class="headerlink" title="4.1.3 绑定的对象定义在data中"></a>4.1.3 绑定的对象定义在data中</h4><p> <strong>绑定的数据对象不必内联定义在模板里：</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classObject<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  classObject<span class="token punctuation">:</span> <span class="token punctuation">{</span>    active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token string">'text-danger'</span><span class="token punctuation">:</span> <span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-4-绑定一个计算属性"><a href="#4-1-4-绑定一个计算属性" class="headerlink" title="4.1.4 绑定一个计算属性"></a>4.1.4 绑定一个计算属性</h4><p><strong>并且可以绑定一个对象的计算属性：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classObject<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  isActive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  error<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">,</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  classObject<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      active<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">,</span>      <span class="token string">'text-danger'</span><span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>error <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'fatal'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-5-绑定一个数组："><a href="#4-1-5-绑定一个数组：" class="headerlink" title="4.1.5 绑定一个数组："></a>4.1.5 绑定一个数组：</h4><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[redFontClass]<span class="token punctuation">"</span></span>                  <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>changeFontColor<span class="token punctuation">"</span></span>    <span class="token punctuation">></span></span>        Hello World  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        redFontClass<span class="token punctuation">:</span><span class="token string">""</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        changeFontColor<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*            点击绑定的元素时，如果这个元素的redFontClass为redFont这个class时            将redFontClass的样式切换为""(即去除样式)            否则将redFontClass的class切换为 redFont这个class            */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>redFontClass<span class="token operator">===</span><span class="token string">"redFont"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>redFontClass<span class="token operator">=</span><span class="token string">""</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>redFontClass<span class="token operator">=</span><span class="token string">"redFont"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/classBind.gif" alt="效果"></p><h3 id="4-2-Style绑定"><a href="#4-2-Style绑定" class="headerlink" title="4.2 Style绑定"></a>4.2 Style绑定</h3><p> <code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span></span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> activeColor, <span class="token property">fontSize</span><span class="token punctuation">:</span> fontSize + <span class="token string">'px'</span> <span class="token punctuation">}</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  activeColor<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>  fontSize<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-1-绑定一个对象"><a href="#4-2-1-绑定一个对象" class="headerlink" title="4.2.1 绑定一个对象"></a>4.2.1 绑定一个对象</h4><p> <strong>直接绑定到一个样式对象通常更好，这会让模板更清晰：</strong> </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span></span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">styleObject</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  styleObject<span class="token punctuation">:</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>    fontSize<span class="token punctuation">:</span> <span class="token string">'13px'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 同样的，对象语法常常结合返回对象的计算属性使用。 </p><h4 id="4-2-1-绑定一个数组"><a href="#4-2-1-绑定一个数组" class="headerlink" title="4.2.1 绑定一个数组"></a>4.2.1 绑定一个数组</h4><p> <code>v-bind:style</code> 的数组语法可以将<strong>多个样式</strong>对象应用到同一个元素上： </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span></span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">[baseStyles, overridingStyles]</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端难点总结并扩展</title>
      <link href="/qian-duan-nan-dian-bei-zhu.html"/>
      <url>/qian-duan-nan-dian-bei-zhu.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端难点总结并扩展"><a href="#前端难点总结并扩展" class="headerlink" title="前端难点总结并扩展"></a>前端难点总结并扩展</h1><p>文本是对以下博客的搬运总结，推荐去原博客查看👇：</p><p><a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">王福朋博客</a></p><h2 id="一-JavaScript中的对象"><a href="#一-JavaScript中的对象" class="headerlink" title="一.JavaScript中的对象"></a>一.JavaScript中的对象</h2><h3 id="1-1-值类型和引用类型"><a href="#1-1-值类型和引用类型" class="headerlink" title="1.1 值类型和引用类型"></a>1.1 值类型和引用类型</h3><pre class="line-numbers language-javascript"><code class="language-javascript">       <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// undefined</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// number</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// boolean</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//function</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//object</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//object</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//object</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//object</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>简单值类型：</strong></p><ul><li><code>undefined</code></li><li><code>number</code></li><li><code>string</code></li><li><code>boolean</code></li><li><code>null</code></li></ul><p><strong>引用类型：</strong></p><ul><li>函数<code>function</code></li><li>数组 <code>[ ]</code></li><li>对象 <code>{ }</code></li><li><code>new</code> Number(10)</li></ul><h3 id="1-2-null和undefined区分"><a href="#1-2-null和undefined区分" class="headerlink" title="1.2 null和undefined区分"></a>1.2 null和undefined区分</h3><p><strong>❗需要注意的是</strong></p><p><strong>1. null到底是不是对象？</strong></p><blockquote><p>null不是object,typeof null返回object是因为.在js中，因为底层是用二进制编码的，所以如果前三位是000的话,用 typeof 的话就会返回object,而null的编码是全部都是0，所以也会被返回object ,所以这其实是js的一个bug而已。</p></blockquote><p><strong>2.</strong> <strong>null和undefined的区别？</strong></p><blockquote><p>undefined表示变量声明但未初始化时的值，<br>null表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null值表示一个空对象指针。</p><p>任何时候都不建议显式的设置一个变量为undefined，但是如果保存对象的变量还没有真正保存对象，应该设置成null。<br>实际上，undefined值是派生自null值的，ECMAScript标准规定对二者进行相等性测试要返回true，即<br>alert(null==undefined); // true</p></blockquote><h3 id="1-3-何为对象？"><a href="#1-3-何为对象？" class="headerlink" title="1.3 何为对象？"></a>1.3 何为对象？</h3><blockquote><p>在JavaScript中，数组、函数、对象都是对象</p></blockquote><p>在Java/C#等语言中的对象都是<code>new</code>出来的，而且对象包含字段、方法和属性，规定的很严格，但是JavaScript中的对象很随意：数组是一个对象，函数是对象，对象也是对象。<strong>对象里的一切都是属性，就算方法也是一种属性</strong>，因为它的属性使用<strong>键值对</strong>来表示。</p><table><thead><tr><th>语言</th><th>产生方法</th><th>对象包含</th></tr></thead><tbody><tr><td>Java</td><td>new</td><td>字段、方法、属性</td></tr><tr><td>JavaScript</td><td>[]、function、{}</td><td>属性</td></tr></tbody></table><p>总结来说，对象就是：<strong>若干属性的集合</strong></p><h4 id="1-3-1-对象可以随意扩展属性"><a href="#1-3-1-对象可以随意扩展属性" class="headerlink" title="1.3.1 对象可以随意扩展属性"></a>1.3.1 对象可以随意扩展属性</h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//自定义对象obj</span><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//属性a是数值</span>    a<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//属性b是函数</span>    b<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//属性c是对象</span>    c<span class="token punctuation">:</span><span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">'wk'</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token string">'18'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-函数和数组如何定义属性"><a href="#1-3-2-函数和数组如何定义属性" class="headerlink" title="1.3.2 函数和数组如何定义属性"></a>1.3.2 函数和数组如何定义属性</h4><p>函数定义属性和<code>{  }</code>不同，需要以<strong>赋值</strong>的形式定义属性。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token string">'wk'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span><span class="token string">'18'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Jquery</code>中 <code>$</code>即为一个函数，它也是用这种方式扩展属性的。</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> $<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// function</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><ol><li>在JavaScript中，为值类型的有：number、undefined、null、string、Boolean</li><li>引用类型有：数组[ ]、对象{}、函数function、new Number(10)</li><li>函数和数组可以使用赋值的办法扩展属性。</li></ol><p><span style="color:red;font-weight:800;">一切（引用类型）都是对象，对象是属性的集合</span></p><h2 id="二-JavaScript中函数和对象的关系"><a href="#二-JavaScript中函数和对象的关系" class="headerlink" title="二.JavaScript中函数和对象的关系"></a>二.JavaScript中函数和对象的关系</h2><blockquote><p>函数是对象的一种，可以使用<code>instanceof</code>函数判断</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是，函数和对象之间<strong>不仅仅是包含和被包含的关系</strong>，它们之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。</p><h3 id="2-1-对象都是通过函数创建的"><a href="#2-1-对象都是通过函数创建的" class="headerlink" title="2.1 对象都是通过函数创建的"></a>2.1 对象都是通过函数创建的</h3><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wk'</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">typeof</span> FN <span class="token comment" spellcheck="true">//function</span>        <span class="token keyword">typeof</span> fn1 <span class="token comment" spellcheck="true">//object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的这个例子很简单，它能说明：<strong>对象可以通过函数来创建</strong>。对！也只能说明这一点。</p><h4 id="2-1-1-JavaScript创建数组和对象的语法糖"><a href="#2-1-1-JavaScript创建数组和对象的语法糖" class="headerlink" title="2.1.1  JavaScript创建数组和对象的语法糖"></a>2.1.1  JavaScript创建数组和对象的语法糖</h4><p>我们在JavaScript中创建数组和对象一般都是像下面这样的👇：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看起来好像是没有通过函数创建，但是其实这都是javascript的语法糖，以上创建方式本质上是这样的：</p><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        obj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，可以很负责任的说——对象都是通过函数来创建的。</strong></p><h3 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h3><ul><li><p><span style="color:red;font-weight:800;">对象都是通过函数来创建的</span></p></li><li><p><strong>对象是函数创建的，而函数却又是一种对象</strong></p></li></ul><h2 id="三-prototype原型"><a href="#三-prototype原型" class="headerlink" title="三.prototype原型"></a>三.prototype原型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>之前我们对函数进行了属性赋值，而<strong>prototype</strong>是JavaScript给函数的一个<strong>默认属性</strong>，每一个函数都有一个属性叫做prototype。</p><p>并且！<strong>prototype的属性值是一个对象</strong>。</p><p>而且，该对象中默认的只有一个叫<code>constructor</code>的属性，指向了这个函数的本身。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/proto1.png" alt></p><p>如上图所示，SuperType是一个函数，右侧为它的原型。</p><p>prototype原型作为一个包含在函数中的对象， 对象又是属性的集合，那么它肯定可以自定义很多属性，不仅仅只包含一个constructor,例如下面的Object，它的prototype中就包含了很多属性。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qiandian1.jpg" alt="多属性prototype"></p><h3 id="3-2-给自己的函数方法的prototype添加属性"><a href="#3-2-给自己的函数方法的prototype添加属性" class="headerlink" title="3.2 给自己的函数方法的prototype添加属性"></a>3.2 给自己的函数方法的prototype添加属性</h3><p>在自己自定义的方法的prototype中新增自己的属性：</p><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'王福朋'</span><span class="token punctuation">;</span>        Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getYear <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1988</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中，我们在函数<code>Fn</code>的<code>protorype</code>属性中添加了<code>name</code>属性和<code>getYea</code>r属性，这样就变成了：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan2.jpg" alt></p><h3 id="3-3-用函数创建对象调用函数的prototype中的属性值"><a href="#3-3-用函数创建对象调用函数的prototype中的属性值" class="headerlink" title="3.3 用函数创建对象调用函数的prototype中的属性值"></a>3.3 用函数创建对象调用函数的prototype中的属性值</h3><p>我们给函数的prototype中的属性值添加属性又有什么用呢？</p><pre class="line-numbers language-javascript"><code class="language-javascript">        <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wk'</span><span class="token punctuation">;</span>        Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getAge <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">18</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上代码我们可以看到，<code>Fn</code>他是一个函数，还记得之前说到，对象都是由函数 <code>new</code> 出来的，即<code>fn</code>是由函数<code>Fn</code> <code>new</code>出来的一个对象，并且<code>fn</code>对象可以调用<code>Fn.prototype</code>属性值中的属性。</p><p>因为每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。</p><p>即：fn.<strong>proto</strong> === Fn.prototype</p><p>这里的”<strong>proto</strong>“成为“隐式原型”</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><ul><li><strong>prototype</strong>是JavaScript给函数的一个<strong>默认属性</strong>，每一个函数都有一个属性叫做prototype。</li><li><strong>prototype的属性值是一个对象</strong>，该对象默认有一个叫<code>constructor</code>的属性，指向了这个函数的<strong>本身</strong>。</li><li>我们可以给函数的prototype属性值添加属性</li><li>使用函数创建的对象可以调用函数中的prototype属性</li></ul><h2 id="四-隐式原型-proto"><a href="#四-隐式原型-proto" class="headerlink" title="四. 隐式原型__proto__"></a>四. 隐式原型<code>__proto__</code></h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>每个函数function都有一个<strong>prototype</strong>，即原型。</p><p>这里再加一句话——每个对象都有一个<code>__proto__</code>，可成为隐式原型。</p><p>这个<code>__proto__</code>是一个隐藏的属性，JavaScript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。</p><h3 id="4-2-proto-与prototype的关系"><a href="#4-2-proto-与prototype的关系" class="headerlink" title="4.2 __proto__与prototype的关系"></a>4.2 <code>__proto__</code>与prototype的关系</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/foo4.jpg" alt></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan3.jpg" alt></p><p>上面截图看</p><p>​        来，<code>obj.__proto__</code>和<code>Object.prototype</code>的属性一样！这么巧！</p><p>答案就是一样。</p><p>obj这个对象本质上是被Object函数创建的，因此<code>obj.__proto__=== Object.prototype</code>。我们可以用一个图来表示。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan4.jpg" alt></p><p>即，<strong>每个对象都有一个<code>__proto__</code>属性，指向创建该对象的函数的prototype。</strong></p><h3 id="4-3-Object-prototype的-proto-指向何处？"><a href="#4-3-Object-prototype的-proto-指向何处？" class="headerlink" title="4.3 Object prototype的__proto__指向何处？"></a>4.3 Object prototype的<code>__proto__</code>指向何处？</h3><p>之前有讲到，函数的原型 Fn.prototype本质上是一个对象，是对象那么必定有<code>__proto__</code>这一个属性。</p><p>那么上图中的“Object prototype”它的<code>__proto__</code>指向哪里？</p><p>在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p><p><strong>但是Object.prototype确实一个特例——它的<code>__proto__</code>指向的是<code>null</code>，切记切记！</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/foo.png" alt></p><h3 id="4-4-函数（function）的-proto-指向"><a href="#4-4-函数（function）的-proto-指向" class="headerlink" title="4.4  函数（function）的__proto__指向"></a>4.4  函数（function）的<code>__proto__</code>指向</h3><p>之前说过，函数（function）也是对象的一种，而对象都有隐式原型<code>__proto__</code>,那么函数也有么？</p><p>答案是——<strong>当然有！</strong></p><p>一个对象的<code>__proto__</code>指向创建它的函数的prototype属性，那么有时什么创建了函数(function)呢❓</p><p><strong>————————</strong>是 <code>Function</code>,注意“F”是大写的。</p><p>且看如下代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//30</span><span class="token keyword">var</span> fn1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span><span class="token string">"y"</span><span class="token punctuation">,</span><span class="token string">"return x+y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，第一种方式是比较传统的函数创建方式，第二种是用<code>new Functoin</code>创建。</p><p><strong>但是并不推荐用第二种方式创建。</strong></p><p>这里只是向大家演示，函数是被Function创建的。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan5.jpg" alt></p><p>上图中，很明显的标出了：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code>，唉，怎么还有一个……<code>Function.__proto__</code>指向<code>Function.prototype</code>？这不成了循环引用了？</p><p>对！是一个环形结构。</p><p>Function也是一个函数，函数是一种对象，也有<code>__proto__</code>属性。既然是函数，那么它一定是被Function创建。所以——<strong>Function是被自身创建的</strong>。所以它的<code>__proto__</code>指向了<strong>自身的Prototype。</strong></p><p>最后一个问题：<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>是不是也指向<code>Object.prototype</code>？</p><p>答案是<strong>肯定的</strong>。因为<code>Function.prototype</code>指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan6.png" alt></p><h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><ul><li><strong>每个对象都有一个<code>__proto__</code>属性，指向创建该对象的函数的prototype。</strong></li><li>自定义函数：<code>function Fn(){}</code>的 <code>Fn.prototype</code>也是一个对象，也是由<strong>Object</strong>创建的，所以，<code>Fn.prototype.__proto__</code>指向的是<code>Object.prototype</code>,即：</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token operator">===</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>Object.prototype</code>是一个特例，它指向<code>null</code></p></li><li><p>Function创建了函数，例如Object、自定义函数等，<strong>函数的创建可以用以下方法</strong>👇：</p></li></ul><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span><span class="token string">"y"</span><span class="token punctuation">,</span><span class="token string">"return x+y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>函数也是一个对象，它的<code>__ptoto__</code>指向的是<code>Function.prototype</code></li><li>Object函数也是由Function创建的，所以<code>Object.__proto__</code>也指向<code>Function.prototype</code></li><li>Function是被自身所创建的，所以它的<code>__proto__</code>指向了<strong>自身的Prototype。</strong></li><li><code>Function.prototype</code>指向的对象，它的<code>__proto__</code>也指向<code>Object.prototype</code></li></ul><h2 id="五-instanceof"><a href="#五-instanceof" class="headerlink" title="五. instanceof"></a>五. instanceof</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>对于值类型，你可以通过<code>typeo</code>f判断，string/number/boolean都很清楚，但是<code>typeof</code>在判断到<strong>引用类型</strong>的时候，<strong>返回值只有object/function</strong>，你不知道它到底是一个object对象，还是数组，还是new Number等等。</p><h3 id="5-2-分析"><a href="#5-2-分析" class="headerlink" title="5.2 分析"></a>5.2 分析</h3><p>这个时候就需要用到instanceof。例如：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/foo2.jpg" alt></p><p><code>f1</code>这个对象是被<code>Foo</code>创建，但是“<strong>f1 instanceof Object</strong>”为什么是<strong>true</strong>呢？</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan7.jpg" alt></p><p>Instanceof运算符的第一个变量是一个<strong>对象</strong>，暂时称为A；第二个变量一般是一个<strong>函数</strong>，暂时称为B。</p><p>Instanceof的判断队则是：</p><p><strong>沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</strong></p><p>根据上图很容易就能看出来，就是true。</p><p>通过上以规则，你可以解释很多比较怪异的现象，例如：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan8.jpg" alt></p><p>这些看似很混乱的东西，答案却都是true，这是为何？</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan9.jpg" alt></p><p>问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？</p><p>重点就这样被这位老朋友给引出来了</p><p><strong>——继承——原型链。</strong></p><h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><ul><li>引用类型判断其类型时，需要使用instanceof</li><li>instanceof的判断规则是：</li></ul><blockquote><p><strong>沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</strong></p></blockquote><h2 id="六-继承"><a href="#六-继承" class="headerlink" title="六. 继承"></a>六. 继承</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>“继承”是面向对象中常用的概念，但是javascript中的继承和java等强类型语言中的继承是两码事，这里把“继承”着重拿出来，就为了体现这个不同。</p><h3 id="6-2-JavaScript中的继承是通过原型链来体现的"><a href="#6-2-JavaScript中的继承是通过原型链来体现的" class="headerlink" title="6.2  JavaScript中的继承是通过原型链来体现的"></a>6.2  JavaScript中的继承是通过原型链来体现的</h3><p>先看几句代码：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan10.jpg" alt></p><p>分析以上代码，<code>f1</code>是<code>Foo</code>函数<code>new</code>出来的对象,<code>f1.a</code>是<code>f1</code>对象的基本属性，<strong><code>f1.b</code>是怎么来的呢？</strong></p><p>——————是从<code>Foo.prototype</code>中来的，之前说过，对象都是通过函数<strong>new</strong>出来的，每个对象都有<code>__proto__</code>这个属性，并且此出现指向<strong>new</strong>它出来的函数的<strong>prototype</strong>属性，即<strong><code>f1.__proto__</code>指向的是<code>Foo.prototype</code></strong></p><p><span style="background:yellow">访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链。</span></p><p>看图说话：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan11.jpg" alt></p><p>上图中，访问<code>f1.b</code>时，<code>f1</code>的基本属性中没有<code>b</code>，于是沿着<code>__proto__</code>找到了<code>Foo.prototype.b</code>。</p><h3 id="6-3-如何区分对象的属性是基本的还是从原型链来的"><a href="#6-3-如何区分对象的属性是基本的还是从原型链来的" class="headerlink" title="6.3 如何区分对象的属性是基本的还是从原型链来的"></a>6.3 如何区分对象的属性是基本的还是从原型链来的</h3><p>那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢❓</p><p>大家可能都知道答案了——<code>hasOwnProperty</code></p><p>特别是在for…in…循环中，一定要注意。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan12.jpg" alt></p><p>我们发现，<code>f1</code>竟然由<code>hasOwnProperty</code>这个属性,<code>f1</code>本身没有这个属性，<code>Foo.protytype</code>也没有这个属性，那么它的这个属性从哪来的？</p><p>它是从<code>Object.prototype</code>中来的 ! 请看图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan13.jpg" alt></p><p>对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，就会顺着原型链一直查找到<code>Object.prototype</code>。</p><p>由于<strong>所有的对象的原型链都会找到<code>Object.prototype</code></strong>，因此<strong>所有的对象都会有<code>Object.prototype</code>的方法</strong>。这就是所谓的<strong>“继承”</strong>。</p><p>当然这只是一个例子，你可以<strong>自定义函数和对象来实现自己的继承</strong>。</p><p>来一个经常见到的继承例子👇：</p><p>每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的，之前说过，函数都是由<code>Function</code>函数创建的，因此继承的都是<code>Function.prototype</code>中的方法。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan14.jpg" alt></p><p>看到了吧，有call、length等这些属性。</p><p>并且，我们还看到有<code>hasOwnProptrty</code>这个属性，这个属性不是在<code>Object.prototype</code>中定义的么？那怎么还会有<code>hasOwnProperty</code>呢？</p><p>——那是因为<code>Function.prototype</code>继承自<code>Object.prototype</code>的方法。有疑问可以看看上一节将instanceof时候那个大图，看看<code>Function.prototype.__proto__</code>是否指<code>Object.prototype</code>。</p><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><ul><li>Javascript中的继承是通过原型链实现的</li><li>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链。</li><li>所有的对象的原型链都会找到<code>Object.prototype</code><strong>，因此</strong>所有的对象都会有<code>Object.prototype</code>的方法<strong>。这就是所谓的</strong>“继承”。</li></ul><h2 id="七-原型的灵活性"><a href="#七-原型的灵活性" class="headerlink" title="七. 原型的灵活性"></a>七. 原型的灵活性</h2><p>在Java和C#中，你可以简单的理解类class是一个模子，都有严格的规定，不能随意修改规则。</p><p>而在JavaScript中，就没有模子了。</p><h3 id="7-1-对象的属性可以随意改动"><a href="#7-1-对象的属性可以随意改动" class="headerlink" title="7.1 对象的属性可以随意改动"></a>7.1 对象的属性可以随意改动</h3><h4 id="7-1-1-添加属性"><a href="#7-1-1-添加属性" class="headerlink" title="7.1.1 添加属性"></a>7.1.1 添加属性</h4><p>对象或者函数在<code>new</code>出来的时候，可能什么属性都没有，但是你可以这会儿加一个，过一会儿在加两个，非常灵活。</p><p>在<code>jQuery</code>的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan15.jpg" alt></p><h4 id="7-1-2-修改继承的属性"><a href="#7-1-2-修改继承的属性" class="headerlink" title="7.1.2 修改继承的属性"></a>7.1.2 修改继承的属性</h4><p>其次，如果继承的方法不合适，<strong>可以做出修改</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/foo3.jpg" alt></p><h4 id="7-1-3-自己创建属性"><a href="#7-1-3-自己创建属性" class="headerlink" title="7.1.3 自己创建属性"></a>7.1.3 自己创建属性</h4><p>例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan16.jpg" alt></p><p>如果你要添加内置方法的原型属性，最好做一步判断，<strong>如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</strong></p><h3 id="7-2-总结"><a href="#7-2-总结" class="headerlink" title="7.2 总结"></a>7.2 总结</h3><ul><li>在javascript中属性的添加修改创建很灵活</li></ul><h2 id="八-执行上下文"><a href="#八-执行上下文" class="headerlink" title="八. 执行上下文"></a>八. 执行上下文</h2><h3 id="8-1-浏览器的”准备工作”"><a href="#8-1-浏览器的”准备工作”" class="headerlink" title="8.1 浏览器的”准备工作”"></a>8.1 浏览器的”准备工作”</h3><h4 id="8-1-1-对变量的准备工作"><a href="#8-1-1-对变量的准备工作" class="headerlink" title="8.1.1 对变量的准备工作"></a>8.1.1 对变量的准备工作</h4><p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan17.jpg" alt></p><p>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，<strong>已经知道了a是undefined</strong>，但却不知道a是10（第三句中）。</p><p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些<strong>“准备工作”</strong></p><p>这些”准备工作”就包括<strong>对变量的声明</strong>而不是赋值。变量赋值是在<strong>赋值语句执行的时候</strong>进行的。可用下图模拟：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan18.jpg" alt></p><h4 id="8-1-2-对this的准备工作"><a href="#8-1-2-对this的准备工作" class="headerlink" title="8.1.2  对this的准备工作"></a>8.1.2  对this的准备工作</h4><p>下面还有。先来个简单的。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan19.jpg" alt></p><p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p><h4 id="8-1-3-对函数的准备工作"><a href="#8-1-3-对函数的准备工作" class="headerlink" title="8.1.3 对函数的准备工作"></a>8.1.3 对函数的准备工作</h4><p>第三种情况。</p><p>在第三种情况中，需要注意代码注释中的两个名词：</p><p>——<strong>“函数表达式”</strong>和<strong>“函数声明”</strong>。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan20.jpg" alt></p><p>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p><p>可以推断出👇：</p><p><strong>在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</strong></p><h4 id="8-1-4-“准备工作”总结"><a href="#8-1-4-“准备工作”总结" class="headerlink" title="8.1.4 “准备工作”总结"></a>8.1.4 “准备工作”总结</h4><p>我们总结一下，在“准备工作”中完成了哪些工作：</p><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ul><p><strong>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</strong></p><h3 id="8-2-代码段"><a href="#8-2-代码段" class="headerlink" title="8.2 代码段"></a>8.2 代码段</h3><p>细心的朋友可能会发现，我们上面所有的例子都是在<strong>全局环境</strong>下执行的。</p><p>其实，javascript在执行一个<strong>代码段</strong>之前，都会进行这些<strong>“准备工作”</strong>来生成执行上下文。这个“代码段”其实分<strong>三种</strong>情况——<strong>全局代码，函数体，eval代码。</strong></p><p>这里解释一下为什么代码段分为这三种。</p><p>所谓“代码段”就是一段<strong>文本形式</strong>的代码。</p><p><strong>Ⅰ：</strong></p><p><strong>全局代码段</strong>是手写文本到<code>&lt;script&gt;</code>标签中的代码</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan21.jpg" alt="全局代码段"></p><p><strong>Ⅱ：</strong></p><p>其次，<strong>eval代码段</strong>接收的也是一段文本形式的代码</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan22.jpg" alt="eval代码段"></p><p><strong>Ⅲ：</strong></p><p>最后，<strong>函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的</strong>，其中需要传入一个文本形式的参数作为函数体。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan23.jpg" alt="函数体代码段"></p><p><span style="color:red">eval不常用，也不推荐大家用。</span></p><h2 id="十-This"><a href="#十-This" class="headerlink" title="十.This"></a>十.This</h2><p><strong>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</strong></p><p>this的取值，分五种情况。</p><h3 id="10-1-情况1-构造函数"><a href="#10-1-情况1-构造函数" class="headerlink" title="10.1 情况1:构造函数"></a>10.1 情况1:构造函数</h3><p>所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是<strong>为了new一个对象</strong>，而有些函数则不是。另外注意，构造函数的函数名第一个字母<strong>大写</strong>（规则约定）。例如：Object、Array、Function等。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan24.jpg" alt></p><p>以上代码中，如果函数作为构造函数用，那么其中的<code>this</code>就代表它即将<code>new</code>出来的对象。</p><p>注意，以上仅限<code>new Foo()</code>的情况，即<code>Foo</code>函数作为<strong>构造函数</strong>的情况。如果<strong>直接调用</strong><code>Foo</code>函数，而不是<code>new Foo()</code>，情况就大不一样了。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan25.jpg" alt></p><p>这种情况<code>this</code>指向的是<code>window</code></p><h3 id="10-2-情况2：函数作为对象的一个属性"><a href="#10-2-情况2：函数作为对象的一个属性" class="headerlink" title="10.2 情况2：函数作为对象的一个属性"></a>10.2 情况2：函数作为对象的一个属性</h3><p>如果函数作为对象的一个属性时，并且作为对象的一个<strong>属性被调用</strong>时，函数中的<code>this</code>指向<strong>该对象</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan26.jpg" alt></p><p>以上代码中，<code>fn</code>不仅作为一个对象的一个<strong>属性</strong>，而且的确是作为对象的一个属性<strong>被调用</strong>。结果<code>this</code>就是<code>obj</code>对象。</p><p>注意，如果<code>fn</code>函数<strong>不作为</strong><code>obj</code>的一个属性被调用，会是什么结果呢？</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan27.jpg" alt></p><p>以上代码中，如果<code>fn</code>函数被赋值到了另一个变量中，并没有作为<code>obj</code>的一个属性被调用，那么<code>this</code>的值就是<code>window</code>，<code>this.x</code>为<code>undefined</code>。</p><h3 id="10-3-情况3：函数用call或者apply调用"><a href="#10-3-情况3：函数用call或者apply调用" class="headerlink" title="10.3 情况3：函数用call或者apply调用"></a>10.3 情况3：函数用call或者apply调用</h3><p>当一个函数被<code>call</code>和<code>apply</code>调用时，<code>this</code>的值就取<strong>传入的对象</strong>的值。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan28.jpg" alt></p><h3 id="10-4-情况4-全局-amp-调用普通函数"><a href="#10-4-情况4-全局-amp-调用普通函数" class="headerlink" title="10.4 情况4: 全局 &amp;调用普通函数"></a>10.4 情况4: 全局 &amp;调用普通函数</h3><p>在<strong>全局环境</strong>下，<code>this</code>永远是<code>window</code></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan29.jpg" alt></p><p><strong>普通函数</strong>在调用时，其中的<code>this</code>也都是<code>window</code>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan30.jpg" alt></p><p>不过下面的情况你需要注意一下👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan31.jpg" alt></p><p>函数f在<code>obj.fn</code>内部定义，虽然<code>obj</code>调用了属性<code>fn</code>，但是它仍是一个普通函数，this仍然指向window。</p><h3 id="10-5-情况5：构造函数的prototype"><a href="#10-5-情况5：构造函数的prototype" class="headerlink" title="10.5 情况5：构造函数的prototype"></a>10.5 情况5：构造函数的prototype</h3><p>在构造函数的prototype中，this又代表着什么❓</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan32.jpg" alt></p><p>如上代码，在<code>Fn.prototype.getName</code>函数中，<code>this</code>指向的是<code>f1</code>对象。因此可以通过<code>this.name</code>获取<code>f1.name</code>的值。</p><p>其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。</p><h3 id="10-6-总结"><a href="#10-6-总结" class="headerlink" title="10.6 总结"></a>10.6 总结</h3><ol><li>构造函数中的This：<ul><li>函数作为构造函数中，则<code>this</code>代表它即将<code>new</code>出来的对象。</li><li>直接调用构造函数，则<code>this</code>指向<code>window</code></li></ul></li><li>函数作为对象的一个属性:<ul><li>作为对象的一个属性被调用时，<code>this</code>指向该对象。</li><li>将该属性赋值给变量时，<code>this</code>指向<code>window</code>.</li></ul></li><li>函数用<code>call</code>或者<code>apply</code>调用时，<code>this</code>指向传入的对象的值。</li><li>在全局环境中，<code>this</code>永远指向<code>window</code></li><li>普通函数在调用时，<code>this</code>指向<code>window</code></li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//window</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>在对象属性函数中定义的内部函数，<code>this</code>指向<code>window</code></li><li>在构造函数的<code>prototype</code>中，定义的属性函数中的<code>this</code>指向的也是当前<code>new</code>出来的对象。</li></ol><p><span style="color:red;">所以还是那句话总结的好，谁调用的函数，this就指向谁</span></p><h2 id="十一-执行上下文栈"><a href="#十一-执行上下文栈" class="headerlink" title="十一. 执行上下文栈"></a>十一. 执行上下文栈</h2><p>执行<strong>全局代码</strong>时，会产生一个<strong>执行上下文环境</strong>，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被<strong>消除</strong>，再重新回到全局上下文环境。<strong>处于活动状态的执行上下文环境只有一个。</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan33.jpg" alt></p><h3 id="11-1-压栈出栈过程"><a href="#11-1-压栈出栈过程" class="headerlink" title="11.1 压栈出栈过程"></a>11.1 压栈出栈过程</h3><p>举个例子：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan34.jpg" alt></p><p>如上代码。</p><p>在执行代码之前，首先将创建全局上下文环境。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan35.jpg" alt></p><p>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan36.jpg" alt></p><p>执行到第13行，调用bar函数。</p><p>跳转到bar函数内部，执行函数体语句之前，会<strong>创建一个新的执行上下文环境。</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan37.jpg" alt></p><p>并将这个执行上下文环境压栈，设置为<strong>活动状态</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan38.jpg" alt></p><p>执行到第5行，又调用了fn函数。</p><p>进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan39.jpg" alt></p><p>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被<strong>销毁</strong>（已经用完了，就要及时销毁，释放内存）。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan40.jpg" alt></p><p>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan41.jpg" alt></p><p>有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——<strong>闭包</strong>。</p><h3 id="11-2-总结"><a href="#11-2-总结" class="headerlink" title="11.2 总结"></a>11.2 总结</h3><ul><li>执行<strong>全局代码</strong>时，会产生一个<strong>执行上下文环境</strong>。</li><li>调用函数时，函数会创建一个属于自己的执行上下文环境，并在调用完后销毁。</li><li>处于活动中的执行上下文只有一个。</li></ul><h2 id="十二-作用域"><a href="#十二-作用域" class="headerlink" title="十二. 作用域"></a>十二. 作用域</h2><h3 id="12-1-js中没有块级作用域"><a href="#12-1-js中没有块级作用域" class="headerlink" title="12.1 js中没有块级作用域"></a>12.1 js中没有块级作用域</h3><p><span style="background:yellow">js中没有块级作用域</span></p><p>所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan42.jpg" alt></p><p>再比如for语句：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan43.jpg" alt></p><p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的<strong>一开始就声明</strong>好了，以避免发生歧义。</p><p>如：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan44.jpg" alt></p><p><span style="background:yellow">并且 javascript除了全局作用域之外，只有函数可以创建的作用域</span></p><p>所以，我们在声明变量时，<strong>全局代码要在代码前端声明</strong>，函数中要在<strong>函数体一开始</strong>就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。</p><h3 id="12-2-作用域解析"><a href="#12-2-作用域解析" class="headerlink" title="12.2 作用域解析"></a>12.2 作用域解析</h3><p>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan45.jpg" alt></p><p>如上图，全局代码和<code>fn</code>、<code>bar</code>两个函数都会形成一个作用域。</p><p>而且，<strong>作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。</strong></p><p>例如，<code>fn</code>作用域下创建了<code>bar</code>函数，那么<code>fn作用域</code>就是<code>bar作用域</code>的<strong>上级</strong>。</p><p><span style="background:yellow">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</span></p><p>例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。</p><h3 id="12-3-总结"><a href="#12-3-总结" class="headerlink" title="12.3 总结"></a>12.3 总结</h3><ul><li>js中是没有块级作用域 “{   }” 的。</li><li>js除了全局作用域之外，只有函数可以创建的作用域。</li><li>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</li></ul><h2 id="十三-作用域和上下文环境"><a href="#十三-作用域和上下文环境" class="headerlink" title="十三. 作用域和上下文环境"></a>十三. 作用域和上下文环境</h2><h3 id="13-1-作用域和执行上下文结合"><a href="#13-1-作用域和执行上下文结合" class="headerlink" title="13.1 作用域和执行上下文结合"></a>13.1 作用域和执行上下文结合</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan46.jpg" alt></p><p>如上图，我们在上文中已经介绍了:</p><p>除了全局作用域之外，每个函数都会创建自己的作用域.</p><p>作用域在函数定义时就已经确定了，而不是在函数调用时确定。</p><h4 id="13-1-1-第一步"><a href="#13-1-1-第一步" class="headerlink" title="13.1.1 第一步"></a>13.1.1 第一步</h4><p>第一步，在<strong>加载程序时</strong>，已经<strong>确定了全局上下文环境</strong>，并随着程序的执行而对变量就行赋值。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan47.jpg" alt></p><h4 id="13-1-2-第二步"><a href="#13-1-2-第二步" class="headerlink" title="13.1.2 第二步"></a>13.1.2 第二步</h4><p>第二步，程序执行到第<code>27</code>行，调用<code>fn(10)</code>，此时生成<strong>此次调用<code>fn</code>函数时的上下文环境</strong>，压栈，并将此上下文环境设置为<strong>活动</strong>状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan48.jpg" alt></p><h4 id="13-1-3-第三步"><a href="#13-1-3-第三步" class="headerlink" title="13.1.3 第三步"></a>13.1.3 第三步</h4><p>第三步，执行到第<code>23行</code>时，调用<code>bar(100)</code>，生成此次调用的上下文环境，压栈，并设置为活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan49.jpg" alt></p><h4 id="13-1-4-第四步"><a href="#13-1-4-第四步" class="headerlink" title="13.1.4 第四步"></a>13.1.4 第四步</h4><p>第四步，执行完第<code>23</code>行，<code>bar(100)</code>调用完成。则<code>bar(100)</code>上下文环境被<strong>销毁</strong>。接着执行第<code>24</code>行，调用<code>bar(200)</code>，则又生成<code>bar(200)</code>的上下文环境，压栈，设置为<strong>活动</strong>状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan50.jpg" alt></p><h4 id="13-1-5-第五步"><a href="#13-1-5-第五步" class="headerlink" title="13.1.5 第五步"></a>13.1.5 第五步</h4><p>第五步，执行完第<code>24</code>行，则<code>bar(200)</code>调用结束，其上下文环境被销毁。此时会回到<code>fn(10)</code>上下文环境，变为活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan51.jpg" alt></p><h4 id="13-1-6-第六步"><a href="#13-1-6-第六步" class="headerlink" title="13.1.6 第六步"></a>13.1.6 第六步</h4><p>第六步，执行完第<code>27</code>行代码，<code>fn(10)</code>执行完成之后，<code>fn(10)</code>上下文环境被<strong>销毁</strong>，<strong>全局上下文环境</strong>又回到活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan52.jpg" alt></p><p>连接起来看就是👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan53.jpg" alt></p><h3 id="13-2-总结"><a href="#13-2-总结" class="headerlink" title="13.2 总结"></a>13.2 总结</h3><p><strong>作用域只是一个“地盘”</strong>，一个抽象的概念，<strong>其中没有变量</strong>。<strong>要通过作用域对应的执行上下文环境来获取变量的值</strong>。同一个作用域下，<strong>不同的调用会产生不同的执行上下文环境</strong>，继而产生不同的变量的值。</p><p><span style="background:yellow">所以，<strong>作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。</strong></span></p><p>所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</p><h2 id="十四-从自由变量到作用域链"><a href="#十四-从自由变量到作用域链" class="headerlink" title="十四. 从自由变量到作用域链"></a>十四. 从自由变量到作用域链</h2><h3 id="14-1-自由变量"><a href="#14-1-自由变量" class="headerlink" title="14.1 自由变量"></a>14.1 自由变量</h3><p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的）</p><p>对于A作用域来说，x就是一个自由变量。如下图</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan54.jpg" alt></p><p>在调用函数<code>fn()</code>时，函数体中的第六行，b值很好取，直接在<code>fn</code>的作用域中取，因为b就在这里定义，而取x值时，就需要到另一个作用域中取了。</p><h3 id="14-2-变量的取值作用域"><a href="#14-2-变量的取值作用域" class="headerlink" title="14.2 变量的取值作用域"></a>14.2 变量的取值作用域</h3><p>那么应该到哪个作用域中取呢？</p><p><span style="background:yellow">有人说过要到父作用域中取，其实有时候这种解释会产生歧义。</span>例如：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan55.jpg" alt></p><p>所以这句话从严格意义上来说是错的，而应该这样描述：</p><p><span style="background:yellow"><strong>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”</strong></span></p><p>其实这就是所谓的<strong>“静态作用域”</strong>。</p><p>对于本文第一段代码，在<code>fn</code>函数中，取自由变量<code>x</code>的值时，要到哪个作用域中取？</p><p><strong>——要到创建<code>fn</code>函数的那个作用域中取——无论<code>fn</code>函数将在哪里调用。</strong></p><h3 id="14-3-作用域链"><a href="#14-3-作用域链" class="headerlink" title="14.3 作用域链"></a>14.3 作用域链</h3><p>上面描述的只是跨一步作用域去寻找。</p><p>如果跨了一步，还没找到呢？——接着跨！——<strong>一直跨到全局作用域为止</strong>。要是在全局作用域中都没有找到，那就是真的没有了。</p><p>这个一步一步“跨”的路线，我们称之为——<span style="background:yellow">作用域链。</span></p><p><strong>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）</strong></p><ul><li>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</li><li>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</li><li>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</li><li>第四步，跳转到第一步。</li></ul><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan56.jpg" alt></p><p>以上代码中：第<code>13</code>行，<code>fn()</code>返回的是<code>bar</code>函数，赋值给<code>x</code>。执行<code>x()</code>，即执行<code>bar</code>函数代码。取<code>b</code>的值时，直接在<code>fn</code>作用域取出。取<code>a</code>的值时，试图在<code>fn</code>作用域取，但是取不到，只能<strong>转向创建<code>fn</code>的那个作用域中去查找</strong>，结果找到了。</p><h3 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h3><ul><li>在A作用域中使用的变量x，却没有在A作用域中声明，这个x就是自由变量</li><li><span style="background:yellow"><strong>自由变量的取值需要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”</strong></span></li><li>寻找自由变量的作用域取值过程称之为<strong>作用域链</strong></li></ul><h2 id="十五-闭包"><a href="#十五-闭包" class="headerlink" title="十五. 闭包"></a>十五. 闭包</h2><p>闭包——<span style="background:yellow">函数作为返回值，函数作为参数传递。</span></p><h3 id="15-1-函数作为返回值"><a href="#15-1-函数作为返回值" class="headerlink" title="15.1 函数作为返回值"></a>15.1 函数作为返回值</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan57.jpg" alt></p><p>如上代码，<code>bar</code>函数作为<strong>返回值</strong>，赋值给<code>f1</code>变量。执行<code>f1(15)</code>时，用到了<code>fn</code>作用域下的<code>max</code>变量的值。</p><h3 id="15-2-函数作为参数被传递"><a href="#15-2-函数作为参数被传递" class="headerlink" title="15.2 函数作为参数被传递"></a>15.2 函数作为参数被传递</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan58.jpg" alt></p><p>如上代码中，<code>fn</code>函数作为一个参数被传递进入另一个函数，赋值给<code>f</code>参数。执行<code>f(15)</code>时，<code>max</code>变量的取值是<strong>10</strong>，而不是100。</p><h3 id="15-3-闭包会增加内容开销"><a href="#15-3-闭包会增加内容开销" class="headerlink" title="15.3 闭包会增加内容开销"></a>15.3 闭包会增加内容开销</h3><p>在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p><p>但是在当时那篇文章中留了一个问号❓</p><p><span style="background:yellow"><strong>——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</strong></span></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan59.jpg" alt></p><p><strong>第一步</strong>，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan60.jpg" alt></p><p><strong>第二步</strong>，执行第17行代码时，调用<code>fn()</code>，产生<code>fn()</code>执行上下文环境，压栈，并设置为活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan61.jpg" alt></p><p><strong>第三步</strong>，执行完第17行，<code>fn()</code>调用完成，按道理说应该<strong>销毁掉</strong><code>fn()</code>的执行上下文环境，但是不能那么做！</p><p><span style="background:yellow"><strong>这是因为：</strong></span></p><p><span style="background:yellow"><strong>执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。</strong></span></p><p>而正巧合的是，<strong>返回的这个函数体中</strong>，还有一个自由变量<code>max</code>要引用<code>fn</code>作用域下的<code>fn()</code>上下文环境中的max。因此，这个<code>max</code>不能被销毁，<strong>销毁了之后bar函数中的max就找不到值了</strong>。</p><p>因此，这里的<code>fn()</code>上下文环境不能被销毁，<strong>还依然存在与执行上下文栈中。</strong></p><p>——即，执行到第<code>18</code>行时，全局上下文环境将变为活动状态，但是<code>fn()</code>上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的<code>max</code>被赋值为100。如下图：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan62.jpg" alt></p><p>第四步，执行到第<code>20</code>行，执行<code>f1(15)</code>，即执行<code>bar(15)</code>，创建<code>bar(15)</code>上下文环境，并将其设置为活动状态。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/qianduan63.jpg" alt></p><p>执行<code>bar(15)</code>时，<code>max</code>是自由变量，需要向创建<code>bar函数</code>的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建<code>bar函数</code>是在执行<code>fn()</code>时创建的。<code>fn()</code>早就执行结束了，<strong>但是<code>fn()</code>执行上下文环境还存在与栈中</strong>，因此执行<code>bar(15)</code>时，<code>max</code>可以查找到。如果<code>fn()</code>上下文环境销毁了，那么<code>max</code>就找不到了。</p><p><span style="background:yellow">使用闭包会增加内容开销，现在很明显了吧</span></p><h3 id="15-4-总结"><a href="#15-4-总结" class="headerlink" title="15.4 总结"></a>15.4 总结</h3><ul><li>函数作为返回值，函数作为参数传递。为闭包。</li><li>闭包会增加内容开销<ul><li>这是因为闭包中可能会用到创建它的执行上下文环境，所有它的父执行上下文不能销毁。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六.装饰器模式之红蓝Buff加身</title>
      <link href="/liu-zhuang-shi-qi-mo-shi-zhi-hong-lan-buff-jia-shen.html"/>
      <url>/liu-zhuang-shi-qi-mo-shi-zhi-hong-lan-buff-jia-shen.html</url>
      
        <content type="html"><![CDATA[<h1 id="装饰器模式之红蓝BUFF加身"><a href="#装饰器模式之红蓝BUFF加身" class="headerlink" title="装饰器模式之红蓝BUFF加身"></a>装饰器模式之红蓝BUFF加身</h1><p>Buff（增益效果）在游戏中非常常见，例如LOL中的红蓝Buff，英雄可以拥有红Buff，蓝Buff或者红蓝Buff加身，当然比较悲催的话，红蓝Buff一整局都拿不到🙃。</p><p>在这里，英雄就是一个对象，我们向现有的对象添加新的功能（获得红蓝Buff），同时又不改变其结构（英雄不会变成小兵等其他角色），这样的需求很符合用装饰器模式来实现。</p><h2 id="1-何为装饰器模式❓"><a href="#1-何为装饰器模式❓" class="headerlink" title="1 何为装饰器模式❓"></a>1 何为装饰器模式❓</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于<strong>结构型模式</strong>，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持<strong>类方法签名完整性</strong>的前提下，提供了额外的功能。</p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li><p>不改变原类文件。</p></li><li><p>不使用继承。</p></li><li><p>动态扩展。</p></li></ul><p>总的来说，装饰器模式动态的给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比增加子类更为灵活。</p><h2 id="2-装饰器模式框架"><a href="#2-装饰器模式框架" class="headerlink" title="2 装饰器模式框架"></a>2 装饰器模式框架</h2><h3 id="2-1-装饰器模式UML图"><a href="#2-1-装饰器模式UML图" class="headerlink" title="2.1 装饰器模式UML图"></a>2.1 装饰器模式UML图</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8FUML.png" alt="UML"></p><h3 id="2-2-角色解析"><a href="#2-2-角色解析" class="headerlink" title="2.2 角色解析"></a>2.2 角色解析</h3><ul><li>抽象组件（Component）：需要装饰的抽象对象。</li><li>具体组件（ConcreteComponent）：是我们需要装饰的对象。</li><li>抽象装饰类（Decorator）：内含指向抽象组件的引用及装饰者共有的方法。</li><li>具体装饰类（ConcreteDecorator）：被装饰的对象。</li></ul><h2 id="3-红蓝Buff加身！"><a href="#3-红蓝Buff加身！" class="headerlink" title="3 红蓝Buff加身！"></a>3 红蓝Buff加身！</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>英雄击倒Buff怪之后获得相应的Buff效果。</p><p><strong>Buff种类包含两种：</strong></p><ul><li>红Buff（回血效果）</li><li>蓝Buff（回蓝效果）</li></ul><h3 id="3-2-确定模式"><a href="#3-2-确定模式" class="headerlink" title="3.2 确定模式"></a>3.2 确定模式</h3><p>通过分析可知：</p><ol><li>不确定英雄身上有哪些Buff效果</li><li>获得相应Buff的顺序可以不同</li><li>得到Buff后英雄这一对象本质并不会改变（不会变成另一个对象）</li></ol><p>通过以上的特点，我们可以看到使用装饰模式很符合本项目的需求。😀</p><h3 id="3-3-编写代码"><a href="#3-3-编写代码" class="headerlink" title="3.3 编写代码"></a>3.3 编写代码</h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五.使用建造者模式建造游戏地图</title>
      <link href="/shi-yong-jian-zao-zhe-mo-shi-jian-zao-you-xi-di-tu.html"/>
      <url>/shi-yong-jian-zao-zhe-mo-shi-jian-zao-you-xi-di-tu.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用建造者模式模拟游戏地图的创建"><a href="#使用建造者模式模拟游戏地图的创建" class="headerlink" title="使用建造者模式模拟游戏地图的创建"></a>使用建造者模式模拟游戏地图的创建</h1><p>换种形式学设计模式，让自己更有兴趣的学设计模式 ：）</p><p>本文使用了建造者模式创建不同的游戏地图，当然是用控制台模拟的假地图…</p><h2 id="1-何为建造者模式"><a href="#1-何为建造者模式" class="headerlink" title="1 何为建造者模式"></a>1 何为建造者模式</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>建造者模式，是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类<br>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><p><strong>总的来说，建造者模式就是把一个个零部件添加到了一样产品上，最后创建出一个完整的产品，不同产品之间需要有共性，例如汽车都有轮子和引擎，可能引擎马力不同，轮子数量不同，用户只需要挑选成品产品而不需要知道造车子的细节。</strong></p><h2 id="2-建造者模式框架"><a href="#2-建造者模式框架" class="headerlink" title="2 建造者模式框架"></a>2 建造者模式框架</h2><h3 id="2-1-建造者模式UML图"><a href="#2-1-建造者模式UML图" class="headerlink" title="2.1 建造者模式UML图"></a>2.1 建造者模式UML图</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8FUML.png" alt="UML图"></p><h3 id="2-2-包含角色"><a href="#2-2-包含角色" class="headerlink" title="2.2 包含角色"></a>2.2 包含角色</h3><ul><li>指挥者（Director）直接和客户（Client）进行需求沟通；</li><li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；</li><li>将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；</li><li>各个具体建造者负责进行产品部件的构建；</li><li>最终构建成具体产品（Product）。</li></ul><h2 id="3-创建游戏地图"><a href="#3-创建游戏地图" class="headerlink" title="3 创建游戏地图"></a>3 创建游戏地图</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>用户通过客户端选择地图种类之后，系统自动为用户创建不同的游戏地图。</p><p><strong>游戏地图包含两种：</strong></p><ul><li>森林地图（树多）</li><li>怪兽地图（怪兽多）</li></ul><p><strong>地图包含的共通元素有：</strong></p><ul><li>树</li><li>路</li><li>怪兽</li><li>NPC</li></ul><h3 id="3-2-确定模式"><a href="#3-2-确定模式" class="headerlink" title="3.2 确定模式"></a>3.2 确定模式</h3><p>通过分析可知：</p><ol><li>最终产品 <strong><em>游戏地图</em></strong> 差异性不大，包含共通性。</li><li>最终产品包含多种元素，有一定的复杂性。</li><li>地图元素的不同决定了地图的差异性，</li></ol><p>通过以上的项目特点，我们可以看到建造者模式很符合本项目需求。😀</p><h3 id="3-3-代码编写"><a href="#3-3-代码编写" class="headerlink" title="3.3 代码编写"></a>3.3 代码编写</h3><h4 id="3-3-1-项目结构图"><a href="#3-3-1-项目结构图" class="headerlink" title="3.3.1 项目结构图"></a>3.3.1 项目结构图</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/GameMap%E9%A1%B9%E7%9B%AE%E5%9B%BE.png" alt="项目图"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/builderpattern.png" alt="项目UML图"></p><h4 id="3-3-2-产品零配件代码"><a href="#3-3-2-产品零配件代码" class="headerlink" title="3.3.2 产品零配件代码"></a>3.3.2 产品零配件代码</h4><p>此项目中的产品零件即为地图元素</p><p><strong><em>地图元素抽象类：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 地图元素抽象类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MapElement</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//x坐标</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> _x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//y坐标</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> _y<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">string</span> _name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">MapElement</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//模拟加载地图元素耗时，并且需要一定间隔让随机数产生不重复</span>            Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>_x <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>_y <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//元素展示</span>        <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>具体地图元素类：</em></strong>包含怪兽、NPC、树、路</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 怪兽类</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">Monster</span> <span class="token punctuation">:</span> MapElement<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> _blood<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Monster</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_blood <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"元素类型：怪兽;血量：{_blood};元素名称：{_name};元素坐标x:{_x},y:{_y};\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// NPC类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">NPC</span> <span class="token punctuation">:</span> MapElement    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">string</span> _job<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">NPC</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">,</span> <span class="token keyword">string</span> job<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>_job <span class="token operator">=</span> job<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"元素类型：NPC;职位：{_job};元素名称：{_name};元素坐标x:{_x},y:{_y};\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 树类</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">Tree</span> <span class="token punctuation">:</span> MapElement<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> _height<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Tree</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_height <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"元素类型：树;高度：{_height}m;元素名称：{_name};元素坐标x:{_x},y:{_y};\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 路</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">Way</span> <span class="token punctuation">:</span> MapElement<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> _length<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Way</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_length <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"元素类型：路;长度：{_length}m;元素名称：{_name};元素坐标x:{_x},y:{_y};\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些地图元素是地图的”零配件”,地图元素的不同导致地图种类的不同。</p><h4 id="3-3-3-具体产品"><a href="#3-3-3-具体产品" class="headerlink" title="3.3.3 具体产品"></a>3.3.3 具体产品</h4><p>此项目中具体的产品即为地图(Game Map)</p><p><strong><em>游戏地图类：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 游戏场景（具体的产品）</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">GameMap</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//地图元素集合</span>    <span class="token keyword">public</span> IList<span class="token operator">&lt;</span>MapElement<span class="token operator">></span> MapElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>MapElement<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 添加地图元素</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token comment" spellcheck="true">/// &lt;param name="MapElement">&lt;/param></span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AddMapElements</span><span class="token punctuation">(</span>MapElement MapElement<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        MapElements<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>MapElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 展示地图</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"——————————————————————地图显示————————————————————\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> element <span class="token keyword">in</span> MapElements<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            element<span class="token punctuation">.</span><span class="token function">Dispaly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-4-创建者接口"><a href="#3-3-4-创建者接口" class="headerlink" title="3.3.4 创建者接口"></a>3.3.4 创建者接口</h4><p>创建者接口为创建一个Product对象的各个部位指定抽象接口。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">interface</span> <span class="token class-name">IGameMapBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">BuilderTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">BuilderWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">BuilderMonster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">BuilderNPC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    GameMap <span class="token function">GetGameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-5-具体创建者"><a href="#3-3-5-具体创建者" class="headerlink" title="3.3.5 具体创建者"></a>3.3.5 具体创建者</h4><p>具体创建者是产品构建差异体现，具体实现如何构建产品。</p><p>本项目中的具体创建者有两个：</p><ul><li>ForestMapBuilder（森林地图创建者）</li><li>MonsterMapBuilder（怪兽地图创建者）</li></ul><p>这两个创建者都继承抽象创建者<code>IGameMapBuilder</code></p><p> <strong><em>ForestMapBuilder：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 森林游戏场景具体建造者----特点：树多 </span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">ForestMapBuilder</span> <span class="token punctuation">:</span> IGameMapBuilder<span class="token punctuation">{</span>    <span class="token keyword">private</span> GameMap gameMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderMonster</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Monster monster1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Monster</span><span class="token punctuation">(</span><span class="token string">"哥斯拉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Monster monster2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Monster</span><span class="token punctuation">(</span><span class="token string">"异形"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Monster monster3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Monster</span><span class="token punctuation">(</span><span class="token string">"女朋友"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>monster1<span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>monster2<span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>monster3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderNPC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        NPC npc1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NPC</span><span class="token punctuation">(</span><span class="token string">"NPC"</span><span class="token punctuation">,</span> <span class="token string">"任务接取处"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>npc1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tree</span><span class="token punctuation">(</span>$<span class="token string">"树{i}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Way way <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Way</span><span class="token punctuation">(</span><span class="token string">"主路"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>way<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> GameMap <span class="token function">GetGameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> gameMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>MonsterMapBuilder:</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 怪物地图创建者 特点：怪物多</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">class</span> <span class="token class-name">MonsterMapBuilder</span> <span class="token punctuation">:</span> IGameMapBuilder<span class="token punctuation">{</span>    <span class="token keyword">private</span> GameMap gameMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderMonster</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Monster</span><span class="token punctuation">(</span>$<span class="token string">"怪物{i}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderNPC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        NPC npc1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NPC</span><span class="token punctuation">(</span><span class="token string">"任务npc"</span><span class="token punctuation">,</span> <span class="token string">"任务接取处"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NPC npc2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NPC</span><span class="token punctuation">(</span><span class="token string">"商店npc"</span><span class="token punctuation">,</span> <span class="token string">"购买物品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>npc1<span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>npc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tree</span><span class="token punctuation">(</span>$<span class="token string">"树{i}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">BuilderWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Way way1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Way</span><span class="token punctuation">(</span><span class="token string">"主路"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Way way2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Way</span><span class="token punctuation">(</span><span class="token string">"史诗之路"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>way1<span class="token punctuation">)</span><span class="token punctuation">;</span>        gameMap<span class="token punctuation">.</span><span class="token function">AddMapElements</span><span class="token punctuation">(</span>way2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> GameMap <span class="token function">GetGameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> gameMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-6-指挥者"><a href="#3-3-6-指挥者" class="headerlink" title="3.3.6 指挥者"></a>3.3.6 指挥者</h4><p>指挥者指定创建者创建，并且决定创建顺序</p><p>本项目中的创建者为<code>GameMapDirect</code></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">GameMapDirector</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Construct</span><span class="token punctuation">(</span>IGameMapBuilder builder<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"---------------正在加载树资源-----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">BuilderTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"---------------正在加载怪物资源---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">BuilderMonster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"---------------正在加载道路资源---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">BuilderWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"---------------正在加载NPC资源----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">BuilderNPC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"-----------------资源加载完毕-----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Construct()</code>方法参数为创建者，方法内部指定了创建顺序。</p><h4 id="3-3-7-客户端代码"><a href="#3-3-7-客户端代码" class="headerlink" title="3.3.7 客户端代码"></a>3.3.7 客户端代码</h4><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"请选择地图类型：1.怪兽地图 2.森林地图"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">string</span> result <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IGameMapBuilder builder <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"--------------正在加载怪兽地图--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MonsterMapBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"--------------正在加载森林地图--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForestMapBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        GameMapDirector director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GameMapDirector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//建造者指派builder去建造地图</span>        director<span class="token punctuation">.</span><span class="token function">Construct</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//建造者建造好地图之后返回地图</span>        GameMap gameMap <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">GetGameMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//地图呈现</span>        gameMap<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Console<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-8-最终结果"><a href="#3-3-8-最终结果" class="headerlink" title="3.3.8 最终结果"></a>3.3.8 最终结果</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p>可以看到，玩家选择了怪兽地图，指挥者指定怪兽地图建造者建造地图，建造顺序按照指挥者方法内部顺序加载地图，最后呈现了一个怪物很多的地图：）</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><h3 id="4-1-优缺点："><a href="#4-1-优缺点：" class="headerlink" title="4.1 优缺点："></a><strong>4.1 优缺点：</strong></h3><p><strong>优点：</strong></p><ul><li>使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>具体的建造者类之间是相互独立的，这有利于系统的扩展。</li><li>具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。</li></ul><p><strong>缺点：</strong></p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="4-2-和抽象工厂对比"><a href="#4-2-和抽象工厂对比" class="headerlink" title="4.2 和抽象工厂对比"></a>4.2 和抽象工厂对比</h3><ul><li>抽象工厂返回一个一系列相关产品族，建造者返回一个组装好的完整产品。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</li></ul><p>​        看到第三点突然想到，本项目中的地图元素可以使用简单工厂实现或者工厂方法模式实现，简单工厂的话就用<code>Switch xxxxx</code>,使用工厂方法模式的话就有<code>TreeFactory</code>、<code>MonsterFactory</code>….</p><p>​        如果再之后怪兽细分为各种怪兽：皮卡丘、小拉达、等等等…那么就可以用抽象工厂模式生产怪兽族。。。妙呀🤭</p><hr><p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><p>我的个人博客地址：<a href="http://www.wukailiving.cn">www.wukailiving.cn</a> </p><p>本人菜鸡，轻喷。</p><p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四.单例模式</title>
      <link href="/si-dan-li-mo-shi.html"/>
      <url>/si-dan-li-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>引言：</p><blockquote><p>终于总结完了简单工厂模式、工厂方法模式、抽象工厂模式三个工厂模式，也初步体会到了设计模式带来的好处，其实各种设计终极目的都是为了设计出可扩展的程序，其中要遵循的原则就是“开放封闭原则”，实现代码之间的“解耦”，各种设计模式是实现方法…</p><p>这篇博客将会总结创建型模式中的一员：单例模式，单例模式又会给我们带来怎样的好处呢？我们拭目以待！</p></blockquote><h2 id="1-何为单例模式❓"><a href="#1-何为单例模式❓" class="headerlink" title="1 何为单例模式❓"></a>1 何为单例模式❓</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>​        单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在<strong>当前进程中</strong>只有一个实例（根据需要，<strong>也有可能一个线程</strong>中属于单例，如：仅线程上下文内使用同一个实例）</p><p>​        单例模式是设计模式中最简单的形式之一。这一模式的目的是<strong>使得类的一个对象成为系统中的唯一实例</strong>。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。</p><h3 id="1-2-动机"><a href="#1-2-动机" class="headerlink" title="1.2 动机"></a>1.2 动机</h3><p>​        对于系统中的某些类来说，<strong>只有一个实例很重要</strong>，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。</p><p>​        如何保证一个类只有一个实例并且这个实例易于被访问呢？<strong>定义一个全局变量</strong>可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个<strong>更好的解决办法是让类自身负责保存它的唯一实例</strong>。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。<strong>这就是单例模式的模式动机</strong>。 </p><h3 id="1-3-要点"><a href="#1-3-要点" class="headerlink" title="1.3 要点"></a>1.3 要点</h3><p>抽象的来说：</p><ol><li>某个类只能有一个实例</li><li>它必须<strong>自行创建</strong>这个实例</li><li>它必须自行向整个系统提供这个实例</li></ol><p>具体实现角度可以概括为：</p><ol><li>单例模式的类只提供<strong>私有构造函数</strong></li><li>类定义中含有一个该类的<strong>静态私有对象</strong></li><li>该类提供了一个<strong>静态的公有函数</strong>用于<strong>创建或获取</strong>它<strong>本身</strong>的<strong>静态私有对象</strong></li></ol><h3 id="1-4-单例模式中的类型"><a href="#1-4-单例模式中的类型" class="headerlink" title="1.4 单例模式中的类型"></a>1.4 单例模式中的类型</h3><h2 id="2-单例模式通用框架"><a href="#2-单例模式通用框架" class="headerlink" title="2 单例模式通用框架"></a>2 单例模式通用框架</h2><h3 id="2-1-单例模式UML图"><a href="#2-1-单例模式UML图" class="headerlink" title="2.1 单例模式UML图"></a>2.1 单例模式UML图</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fuml.png" alt="单例模式UML图"></p><p>通过UML图我们可以看到，单例模式中包含一个私有的构造函数<code>Singleton()</code>,一个私有对象<code>instance</code>,和一个对外开放的公有方法用来创建或者获取它本身的私有对象<code>GetInstance()</code></p><h2 id="3-简单例子"><a href="#3-简单例子" class="headerlink" title="3 简单例子"></a>3 简单例子</h2><h3 id="3-1-项目需求"><a href="#3-1-项目需求" class="headerlink" title="3.1 项目需求"></a>3.1 项目需求</h3><p>需求：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三.抽象工厂模式</title>
      <link href="/san-chou-xiang-gong-han-mo-shi.html"/>
      <url>/san-chou-xiang-gong-han-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p><strong>引言：</strong></p><blockquote><p>上两篇博文总结了简单工厂模式和工厂方法模式，这两个模式是层层递进的。</p><p>简单工厂模式通过工厂类实现了职责分离，让客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</p><p>工厂方法模式是对简单工厂模式的优化，它克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</p></blockquote><p>工厂方法模式存在一个严重的问题：</p><ul><li>一个具体工厂只能创建一类产品</li></ul><p>抽象工厂模式是工厂方法模式的进阶版，那么抽象工厂模式于工厂方法模式相比较，又有什么的优缺点？作为进阶版，它又能做到工厂方法模式做不到的事情？这是本篇博文需要讨论的地方。</p><h2 id="1-何为抽象工厂模式？"><a href="#1-何为抽象工厂模式？" class="headerlink" title="1.何为抽象工厂模式？"></a>1.何为抽象工厂模式？</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p><blockquote><p>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类  </p></blockquote><h3 id="1-2-该模式中包含的角色及职责"><a href="#1-2-该模式中包含的角色及职责" class="headerlink" title="1.2 该模式中包含的角色及职责"></a>1.2 该模式中包含的角色及职责</h3><p>抽象工厂模式包含如下角色：</p><table><thead><tr><th align="left">组成（角色）</th><th align="left">关系</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">抽象产品（Product）</td><td align="left">具体产品的父类</td><td align="left">描述具体产品的公共接口</td></tr><tr><td align="left">具体产品（Concrete Product）</td><td align="left">抽象产品的子类；工厂类创建的目标类</td><td align="left">描述生产的具体产品</td></tr><tr><td align="left">抽象工厂（Creator）</td><td align="left">具体工厂的父类</td><td align="left">描述具体工厂的公共接口</td></tr><tr><td align="left">具体工厂（Concrete Creator）</td><td align="left">抽象工厂的子类；被外界调用</td><td align="left">描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td></tr></tbody></table><h3 id="1-3-解决的问题"><a href="#1-3-解决的问题" class="headerlink" title="1.3 解决的问题"></a>1.3 解决的问题</h3><p>每个工厂只能创建一类产品（即<strong>工厂方法模式</strong>的缺点）</p><h2 id="2-抽象工厂模式通用框架"><a href="#2-抽象工厂模式通用框架" class="headerlink" title="2.抽象工厂模式通用框架"></a>2.抽象工厂模式通用框架</h2><h4 id="2-1-抽象工厂模式UML类图"><a href="#2-1-抽象工厂模式UML类图" class="headerlink" title="2.1 抽象工厂模式UML类图"></a>2.1 抽象工厂模式UML类图</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82uml.jpg" alt="抽象工厂uml图"></p><p><strong>步骤1：</strong> 创建<strong>抽象工厂类</strong>，定义具体工厂的公共接口；<br><strong>步骤2：</strong> 创建<strong>抽象产品类</strong> （继承抽象产品族类），定义具体产品的公共接口；<br><strong>步骤3：</strong> 创建<strong>具体产品类</strong>（继承抽象产品类） &amp; 定义生产的具体产品；<br><strong>步骤4：</strong>创建<strong>具体工厂类</strong>（继承抽象工厂类），定义创建对应具体产品实例的方法；<br><strong>步骤5：</strong>客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例</p><h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3 例子"></a>3 例子</h2><h3 id="3-1-项目需求"><a href="#3-1-项目需求" class="headerlink" title="3.1 项目需求"></a>3.1 项目需求</h3><p>有一套桌面应用软件，需要在不同的系统中展示不同的风格，例如在Mac系统中需要Mac的风格控件，在Windows系统中需要Windows风格的控件。</p><p>需求图如下👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/fengge.png" alt></p><h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><p><strong><em>AbstractFactory（抽象工厂接口）：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 抽象工厂</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token keyword">interface</span> <span class="token class-name">IFactory</span><span class="token punctuation">{</span>    IButton <span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ITextField <span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    IToolBar <span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Product（抽象产品类）：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 抽象产品类--定义具体产品的公共接口</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">interface</span> <span class="token class-name">IButton</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">Click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">ITextField</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">IToolBar</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Concrete Product（具体产品）：</em></strong></p><p><strong>具体的按钮</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 具体的按钮</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">WinButton</span> <span class="token punctuation">:</span> IButton    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Click Windows Button！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Windows Button！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">MacButton</span> <span class="token punctuation">:</span> IButton    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Click Mac Button！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Mac Button！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>具体的文本框</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">WinTextField</span> <span class="token punctuation">:</span> ITextField<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Windows TextFiled！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MacTestField</span> <span class="token punctuation">:</span> ITextField<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Mac TextFiled！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>具体的工具条</strong></p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">WinToolBar</span> <span class="token punctuation">:</span> IToolBar<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Windows ToolBar！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MacToolBar</span> <span class="token punctuation">:</span> IToolBar<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Display Mac ToolBar！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Concrete Creator（具体工厂类）：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">class</span> <span class="token class-name">WinControlFactory</span> <span class="token punctuation">:</span> IFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> IButton <span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> ITextField <span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> IToolBar <span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">MacControlFactory</span> <span class="token punctuation">:</span> IFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> IButton <span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> ITextField <span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacTestField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> IToolBar <span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Client（客户端）：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            IFactory controlFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WinControlFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            IButton button <span class="token operator">=</span> controlFactory<span class="token punctuation">.</span><span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ITextField textField <span class="token operator">=</span> controlFactory<span class="token punctuation">.</span><span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            IToolBar toolBar <span class="token operator">=</span> controlFactory<span class="token punctuation">.</span><span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            button<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            button<span class="token punctuation">.</span><span class="token function">Click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            textField<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            toolBar<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>结果：</em></strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/1569226143945.png" alt="结果显示"></p><p>​        通过上面的例子，我们可以看到使用抽象工厂模式后可以非常方便的交换产品系列，由于具体的工厂类，例如<code>IFactory controlFactory = new MacControlFactory/WinControlFactory()</code>在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂非常容易，它<strong>只需要改变具体工厂</strong>即可使用不同的产品配置。</p><p>​        但是之后若有新需求，例如增加一个在不同系统下的<code>Combox</code>控件，就需要增加一个抽象产品<code>ICombox</code>类，和两个具体产品类<code>WinCombox</code> <code>MacCombox</code>,并且需要在抽象工厂和具体工厂中增加相应的实例化方法<code>CreateCombox()</code>,需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“<strong>开闭原则</strong>”。</p><p>​    而且我们的客户端程序类显然不可能只有一个，有多个客户端类那么就说明需要多次<code>IFactory controlFactory = new MacControlFactory/WinControlFactory()</code>，如果有100个地方需要调用工厂，那就需要修改100次，这样大批量的改动是非常丑陋的做法， 有什么办法可以让改动量最小？</p><h3 id="3-3-用简单工厂方法模式改进抽象工厂模式"><a href="#3-3-用简单工厂方法模式改进抽象工厂模式" class="headerlink" title="3.3 用简单工厂方法模式改进抽象工厂模式"></a>3.3 用简单工厂方法模式改进抽象工厂模式</h3><p>我们去除IFactory、MacControlFactory、WinControlFactory这三个工厂类，取而代之的是增加一个ControlSimpleFactory这个类，利用反射+简单工厂模式实现。</p><p><strong><em>在配置文件中配置当前操作系统：</em></strong></p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appSettings</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>add</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>OS<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Mac<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appSettings</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><em>创建ControlSimpleFactory类利用反射原理返回相应对象：(ConcreteProduct为文件夹名)</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 当前程序集名称</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token keyword">string</span> AssemblyName <span class="token operator">=</span> Assembly<span class="token punctuation">.</span><span class="token function">GetExecutingAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 配置文件Value</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token keyword">string</span> os <span class="token operator">=</span> ConfigurationManager<span class="token punctuation">.</span>AppSettings<span class="token punctuation">[</span><span class="token string">"OS"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> IButton <span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> className <span class="token operator">=</span> $<span class="token string">"{AssemblyName}.ConcreteProduct.{os}Button"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>IButton<span class="token punctuation">)</span>Assembly<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>AssemblyName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> ITextField <span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> className <span class="token operator">=</span> $<span class="token string">"{AssemblyName}.ConcreteProduct.{os}TextField"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>ITextField<span class="token punctuation">)</span>Assembly<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>AssemblyName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> IToolBar <span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> className <span class="token operator">=</span> $<span class="token string">"{AssemblyName}.ConcreteProduct.{os}ToolBar"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>IToolBar<span class="token punctuation">)</span>Assembly<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>AssemblyName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>客户端代码：</em></strong></p><pre class="line-numbers language-csharp"><code class="language-csharp">   <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>   <span class="token punctuation">{</span>            IButton button <span class="token operator">=</span> OsControlSimpleFactory<span class="token punctuation">.</span><span class="token function">CreateButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ITextField textField <span class="token operator">=</span> OsControlSimpleFactory<span class="token punctuation">.</span><span class="token function">CreateTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            IToolBar toolBar <span class="token operator">=</span> OsControlSimpleFactory<span class="token punctuation">.</span><span class="token function">CreateToolBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            button<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            button<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            textField<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            toolBar<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        通过简单工厂模式改进之后，我们可以看到客户端没有出现任何一个<code>new WinControlFactory();</code>或者<code>new MacControlFactory();</code>的字样，达到了解耦的目的，之后如果需要增加一个<code>Combox</code>控件,我们只需要增加两个具体的产品例如<code>WinCombox</code>和<code>MacCombox</code>，并且在<code>ControlSimpleFactory</code>中增加一个<code>ConcreteCombox</code>方法就行，如果要切换为Windows风格的控件，我们只需要在配置文件中修改相应配置即可。</p><h2 id="4-抽象工厂模式的优缺点及使用场景"><a href="#4-抽象工厂模式的优缺点及使用场景" class="headerlink" title="4 抽象工厂模式的优缺点及使用场景"></a>4 抽象工厂模式的优缺点及使用场景</h2><p>​    通过例子我们可以看到，使用了抽象工厂模式之后，我们若需要切换不同系列的系统控件，只需要在客户端中修改一行代码就行：<code>IFactory controlFactory = new MacControlFactory/WinControlFactory();</code></p><p>​        并且抽象工厂模式可以生产一系列相关的产品，例如Mac操作系统下的一族控件，这是使用工厂方法模式不能达到的效果。</p><h3 id="4-1-抽象工厂模式的优缺点"><a href="#4-1-抽象工厂模式的优缺点" class="headerlink" title="4.1 抽象工厂模式的优缺点"></a>4.1 抽象工厂模式的优缺点</h3><p>我们总结一下抽象工厂模式的优缺点：</p><p><strong>主要优点</strong>：</p><p>(1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，<br>更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接<br>口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 </p><p>(2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产<br>品族中的对象。</p><p>(3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><p> <strong>缺点</strong>：</p><p>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，<br>这显然会带来较大的不便，违背了“<strong>开闭原则</strong>”。</p><h3 id="4-2-抽象工厂模式的使用场景"><a href="#4-2-抽象工厂模式的使用场景" class="headerlink" title="4.2 抽象工厂模式的使用场景"></a>4.2 抽象工厂模式的使用场景</h3><p><strong>使用场景</strong>：</p><p>(1) <strong>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节</strong>，这对于所有类型的工<br>厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</p><p>(2) 系统中有<strong>多于一个的产品族</strong>，而每次<strong>只使用其中某一产品族</strong>。可以通过配置文件等方式来<br>使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个<br>产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作<br>系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统<br>的，此时具有一个共同的约束条件：操作系统的类型。</p><p>(4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的<br>产品等级结构。</p><p><strong>我们的设计不能去防止去求的更改，那么我们的理想就是让改动变得最小。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/HTTPS重要摘抄</title>
      <link href="/http-https-chong-yao-zhai-chao.html"/>
      <url>/http-https-chong-yao-zhai-chao.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP全解析</title>
      <link href="/tcpudp.html"/>
      <url>/tcpudp.html</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h1><p><strong>TCP:</strong> 传输控制协议（英语：Transmission Control Protocol，缩写为TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</p><p><strong>UDP:</strong>用户数据报协议（英语：User Datagram Protocol，缩写为UDP），又称使用者资料包协定，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>关于TCP和UDP这两个协议是面试中非常常见的问题，本文讨论以下几个问题：</p><ol><li>什么是TCP</li><li>什么是UDP</li><li>TCP和UDP的异同点</li><li>TCP和UDP的应用场景</li></ol><h2 id="1-TCP和UDP的异同点"><a href="#1-TCP和UDP的异同点" class="headerlink" title="1. TCP和UDP的异同点"></a>1. TCP和UDP的异同点</h2><h3 id="1-1-相同点"><a href="#1-1-相同点" class="headerlink" title="1.1 相同点"></a>1.1 相同点</h3><ul><li>UDP和TCP同属于传输层的协议</li></ul><h3 id="1-2-不同点"><a href="#1-2-不同点" class="headerlink" title="1.2 不同点"></a>1.2 不同点</h3><ol><li><strong>TCP面向字节流，而UDP面向数据报。</strong></li></ol><p><strong>解释：</strong></p><p>TCP收发的是一堆数据，是一个数据流，而每次取多少由主机决定;</p><p>而UDP发的是数据报，客户发送多少就接收多少</p><ol start="2"><li><strong>TCP是面向连接的，而UDP不是面向连接的。</strong></li></ol><p><strong>解释：</strong></p><p>TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的，因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。 </p><p>而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。</p><ol start="3"><li><strong>TCP是可靠的，而UDP是不可靠的。</strong></li></ol><p><strong>解释：</strong></p><p>TCP为提供可靠性传输实行“顺序控制”或“重发控制”机制。此外还具备“流量控制”、“拥塞控制”、提高网络利用率等众多功能，并且只有确认通信端存在才会发送数据，从而可以控制通信流量的浪费。</p><p>在UDP的情况下，虽然可以确保发送信息的大小，却不能保证信息一定会到达。因此，应用有时会根据自己的需要进行重发处理。 UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。它并不需要确认通信端是否存在，可以随时发送数据。</p><ol start="4"><li><strong>TCP是全双工的，UDP支持多播和广播。</strong></li></ol><p><strong>解释：</strong></p><p>TCP是全双工的，所谓全双工就是数据在两个方向上同时进行传送操作，例如我们打电话，说话的同时也能够听到对方的声音，一旦两个通信端口简历TCP连接，那么两个端口只能一对一进行数据传输。</p><p>UDP因为不需要一对一建立连接，所以它可以做到一对一，一对多等传输方式，承担广播或者多播，虽然它不会建立连接，但是会监听这个端口，谁都可以给这个端口传数据，它也可以给任何人传数据。</p><ol start="5"><li><p><strong>UDP 不处理堵塞，应用需要发，就会发送。TCP 还拥有堵塞控制，TCP 会根据网络环境调整发包的频率。</strong></p></li><li><p><strong>TCP的传输效率低，UDP的传输效率高。</strong></p></li></ol><p><strong>解释：</strong>因为UDP不用对收发的数据进行确认校验，有什么发什么，所以使得UDP的开销更小数据传输速率更高。</p><p>来一个直观的对比👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcp.jpg" alt="对比"></p><hr><blockquote><p> 造成TCP和UDP如此大的不同的原因是什么？想要理解TCP和UDP的区别，首先我们要明白什么是UDP,什么是TCP。</p></blockquote><h2 id="2-UDP协议解析"><a href="#2-UDP协议解析" class="headerlink" title="2. UDP协议解析"></a>2. UDP协议解析</h2><h3 id="2-1-UDP包头"><a href="#2-1-UDP包头" class="headerlink" title="2.1 UDP包头"></a>2.1 UDP包头</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/UDP.png" alt="UDP包头"></p><p>由上图可知，UDP包头的组成很简单，包含的字段有：</p><ul><li>目标端口号字段</li><li>源端口号字段</li><li>UDP数据长度字段</li><li>校验和字段</li></ul><p>有用的也就源端口和目标端口，其中校验和字段是可选项，而TCP数据段中的校验和字段是必须有的。</p><p>包头结构的简单，也决定了UDP功能上的简单。</p><h3 id="2-2-UDP特点"><a href="#2-2-UDP特点" class="headerlink" title="2.2 UDP特点"></a>2.2 UDP特点</h3><p><strong>我们可以总结出以下UDP的特点:</strong></p><ol><li>它不需要大量的数据结构，处理逻辑和包头字段，也就说明它的通信方式很简单。</li><li>UDP不会建立连接，但是会监听这个端口，这也决定了谁都可以向这个端口传输数据，并且它也可以传给任何人数据，甚至可以一对多传输（多播）。</li><li>UDP并不会根据网络状况进行堵塞控制，也不会对包进行校验，该怎么发就怎么发。</li><li>因为UDP的简单，所以UDP较TCP被攻击者利用的漏洞就要少一些。</li></ol><h2 id="3-TCP协议解析"><a href="#3-TCP协议解析" class="headerlink" title="3 TCP协议解析"></a>3 TCP协议解析</h2><h3 id="3-1-TCP包头"><a href="#3-1-TCP包头" class="headerlink" title="3.1 TCP包头"></a>3.1 TCP包头</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TCP.jpg" alt="TCP包头">由上图可知TCP包头较于UDP复杂很多，TCP包含的字段有：</p><ol><li><p>源、目端口号：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程</p></li><li><p>顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。</p></li><li><p>确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。</p></li><li><p>首部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p></li><li><p>标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p><ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文段交给应用层。</li><li>RST：重建连接。</li><li>SYN：发起一个连接。</li><li>FIN：释放一个连接。</li></ul></li><li><p>窗口大小字段：占16比特。此字段用来进行<strong>流量控制</strong>。单位为字节数，这个值是本机期望一次接收的字节数。</p></li><li><p>TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p></li><li><p>紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p></li><li><p>选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p></li></ol><h3 id="3-2-TCP特点"><a href="#3-2-TCP特点" class="headerlink" title="3.2 TCP特点"></a>3.2 TCP特点</h3><p>因为有了较于UDP复杂了多的包头，也让TCP的功能多样化，例如：</p><ul><li>数据排序</li><li>数据检测确认，数据重发</li><li>连接维护</li><li>恢复丢失数据</li><li>流量控制和网络拥塞</li></ul><h3 id="3-3-TCP功能实现"><a href="#3-3-TCP功能实现" class="headerlink" title="3.3 TCP功能实现"></a>3.3 TCP功能实现</h3><h4 id="3-3-1-三次握手"><a href="#3-3-1-三次握手" class="headerlink" title="3.3.1 三次握手"></a>3.3.1 三次握手</h4><p>为什么TCP需要进行三次握手？</p><blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。—— 谢希仁《计算机网络》</p></blockquote><p>简单来说，三次握手其实是为了<strong>同步序列号和确认号的相关信息</strong>，而序列号和确认号又是保障数据的正确性以及窗口滑动机制的最基本的根据。</p><p>那么为什么同步序列号需要三次握手？</p><p>举个例子说明：</p><p>大雄给静香寄了个水果包裹，并且通知了静香，但是因为种种原因，包裹并没有按照约定时间送达到静香手中，于是大雄又重新寄了个包裹过去又通知了静香，狗血的是，在第二个包裹到达之前，第一个包裹先到了，但由于没有相关同步的”序列号”和”确认号”,所以静香没有向大雄确认这是哪一次的包裹，因为时间太久的原因包裹中的水果都烂了，导致了静香误会了大雄。</p><p>抽象来讲就是 A 给 B发送一个数据包，这个包由于网络的原因，很久才到 B 端，而这段时间，A 和 B 已经断开，并且重新建立了连接关系。没有相关同步序列号和确认号，B 端认为这个数据还是认为 A 这个时候要发给我的，但是其实这个数据上一次传输的数据，相当于这次传输的数据中插入了其他的数据，那么就会导致这次的数据出现异常。</p><p><strong>那么我们就可以明白为什么不是两次握手❓</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="二次握手"></p><p>在上面一个过程中，对于大雄来说，他通知了静香寄了包裹，静香也回复了大雄收到了包裹，在A端实现了信息的一来一回，但是对于静香来说，她并没有向大雄确认这个包裹是哪一次送的包裹，导致了误会的发生。</p><p>要实现误会的消除，那么静香收到包裹的时候需要向大雄确定这是哪一次的包裹，也就是传说中的<strong>三次握手</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p>由于增加了一次”握手“，让静香确认了包裹是第一次的还是第二次的，消除了大雄和静香之间的误会。</p><p><span style="color:red;">所以TCP 的三次握手除了建立连接外，主要还是为了沟通 TCP 包的序号问题，没有了三次握手，也就无法保证数据的时效性。</span></p><p><strong>那么可以四次握手五次握手乃至一百次握手吗❓</strong></p><p>理论上其实这个同步序列号和确认号的过程，大于三次也不是没有的，应该说几十次上百次都是可以的，但是三次握手的过程已经实现了序号数据同步，在进行太多次的序号同步，已经没有意义。无故浪费宽带。</p><p><strong>实际的三次握手：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.jpg" alt="三次握手"></p><p>这是网上经常见到的关于三次握手的一张图,上图展示三次握手的流程图，文字描述过程如下：</p><p>符号意义：SYN（发起一个连接） 、seq（序列号）、ACK（确认序列号有效）、ack（确认号的值）</p><ol><li><p>客户端向服务端发起一个连接。报文中包含了： SYN = 1, seq=x「序列号」的值， 发送之后客服端进入到 <code>SYN-SENT</code> 状态。</p></li><li><p>服务端接收到 SYN 和 seq「序列号」信息后，需要对这个报文进行的确认。服务端收到客户端发送过来的seq「序列号」的值，服务端会返回一个ack「确认号」的值（序列号+1）<strong>（静香询问大雄这是第几次发送的包裹）</strong>。同时返回 SYN = 1 表示还在同步阶段。 ACK = 1 表示确认号有意义。服务端发送之后，进入到<code>SYN-RCVD</code>状态。</p></li></ol><p>此时——-序列号：表示服务端的序列号 y。 确认号：针对客户端发起连接的一个确认号。 </p><ol start="3"><li><p>客户端接收到服务端返回的数据，使得客户端这一边的相关通信建立，并且同步了相关序列号和确认号的数值，但是服务端还没有接收到客户端回复的确认号。所以客户端需要<strong>再发送一个数据到服务端</strong>，主要包含： ACK = 1，这是确认号的数据有意义<strong>（告诉静香包裹可用）</strong>。 SYN = 0 序列号已经同步完成，不需要再同步序列号。</p></li><li><p>序列号：因为 SYN 已经不是第一次同步序列号的信息了。这个时候的序列号，就表示的是一个单纯的基于序列号最新的数据包的序列号。其值为：x+1。 确认号：返回服务端序列号 y 的确认号，为 y+1。 发送这个值之后，客户端进入到<code>ESTABLISHED</code>状态，服务端接受到这个值之后也进入到<code>ESTABLISHED</code> 状态。然后就可以开始传递数据通信了。</p></li></ol><p>至此<strong>三次握手</strong>已经完成。</p><h4 id="3-3-2-四次挥手"><a href="#3-3-2-四次挥手" class="headerlink" title="3.3.2 四次挥手"></a>3.3.2 四次挥手</h4><p>三次握手可以让服务端和客户端建立连接，那么断开连接也需要一个过程，那就是<strong>四次挥手</strong>。</p><p>TCP四次挥手过程：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><ol><li><p>任意一端（ A 端）发出一条 FIN（释放连接） 的数据。数据包含： FIN = 1, 序列号 A 端发出这个数据之后，进入到 <code>FIN - WAIT -1</code>的状态，等待 B 端的回复.</p></li><li><p>B 收到 A 端的 FIN 的信息就回复ACK=1，ack=seq+1，表示已经知道 A 端请求断开连接这个事情了。此时 B 端进入到 <code>CLOSED - WAIT</code>的状态。</p></li><li><p>A 端接收到这个数据进入到<code>FIN - WAIT -2</code> 的状态。 </p></li><li><p>然后返过来B 端给 A 端发起一次 FIN 的数据。请求结束连接，发送完成之后 B 端进入到<code>LAST - ACK</code> 状态。发送的数据包含： FIN = 1、ACK = 1、seq、ack</p></li><li><p>A 端接收到这个 B 端发送的 FIN 数据进入到<code>TIME- WAIT</code>状态，同时回复 B 端，已经接收到了 FIN 数据。回复的包中包含： ACK = 1; ack</p></li><li><p>然后A端状态变为<code>CLOSED</code>状态，B端收到A端恢复的数据之后，也变为了<code>CLOSED</code>状态。</p></li></ol><p><strong>用例子说明就是：</strong></p><blockquote><p>A：B 啊，我不想玩了<br>B：哦，你不想玩了啊，我知道了<br>这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。<br>B：A 啊，好吧，我也不玩了，拜拜<br>A：好的，拜拜</p></blockquote><p>断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态。</p><p>A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p><p>如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要<strong>等待一段时间</strong>，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要<strong>足够长</strong>。<strong>这也是为什么需要TIME-WAIT这个状态。</strong></p><p>TIME-WAIT这个状态：</p><ol><li>保证TCP协议的全双工连接能够可靠关闭 </li><li>保证这次连接的重复数据段从网络中消失</li></ol><blockquote><p>一、保证TCP协议的全双工连接能够可靠关闭 先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p></blockquote><blockquote><p>二、保证这次连接的重复数据段从网络中消失 再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p></blockquote><h5 id="TCP-为什么进行是四次挥手，而不是三次？"><a href="#TCP-为什么进行是四次挥手，而不是三次？" class="headerlink" title="TCP 为什么进行是四次挥手，而不是三次？"></a>TCP 为什么进行是四次挥手，而不是三次？</h5><p>断开比连接更复杂，比较直接的理解是资源回收比资源分配会更麻烦。使得所有资源能够有效并且不产生错误的情况下释放。</p><p><code>三次握手的本质是：将“四次握手”中的第二次、第三次握手合为一次，因为“四次握手”中的第二次、第三次握手都是由B向A传递报文，而且这两次发送报文的目的允许这两次报文合并为一次。</code>那么，TCP四次挥手中的第二次、第三次挥手，能否也能合为一次呢？</p><p>答案是否定的。将TCP四次挥手中的第二次、第三次挥手，合为一次。也就是将CLOSE_WAIT状态的停留时间变为0。然而，B之所以存在CLOSE_WAIT状态，是因为B可能还存在着需要发送给A但是未发送的数据，如果存在着这些数据，那么这个状态的时间，就是用来发送这些数据的，所以，TCP四次挥手中的第二次、第三次挥手无法合并为一次。所以，也就无法实现“TCP三次挥手”。</p><h4 id="3-3-3-累计确认"><a href="#3-3-3-累计确认" class="headerlink" title="3.3.3  累计确认"></a>3.3.3  累计确认</h4><p>首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为<strong>累计应答</strong>或<strong>累计确认</strong>。</p><p>双方各自维护一个窗口以控制流量（rwnd），然后，发送方维护一个拥塞窗口以调节网络拥塞（cwnd）。</p><p>拥塞窗口（cwnd）是对发送端收到<strong>确认</strong>（<strong>ACK</strong>）之前能向网络传送的最大数据量的一个发送端限制，接收端通知窗口（rwnd）是对未完成数据量的接收端限制。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%B4%AF%E8%AE%A1%E5%BA%94%E7%AD%94.png" alt="累计应答"></p><p>为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p><ul><li>已发送，已经确认</li><li>已发送，未确认</li><li>未发送，可以发送</li><li>未发送，不可发送</li></ul><p>这里的第三部分和第四部分就属于流量控制的内容</p><p>接收方的 rwnd 主要是三个部分：</p><ul><li>接收并已确认的</li><li>等待接收未确认的</li><li>不能接收的</li></ul><p>在 TCP 里，接收端会给发送端报一个窗口大小，叫 <strong>Advertised window</strong>。这个窗口等于发送端的已交代未做完的和马上要交代的，这个窗口应该等于发送端的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了。</p><p>于是，发送端要保持下面的数据结构👇</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%AA%97%E5%8F%A3.jpg" alt="发送端结构"></p><p>接收端锁对应的数据结构：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%8E%A5%E6%94%B6%E7%AB%AF.jpg" alt="接收端结构"></p><h4 id="3-3-4-顺序和丢包问题"><a href="#3-3-4-顺序和丢包问题" class="headerlink" title="3.3.4  顺序和丢包问题"></a>3.3.4  顺序和丢包问题</h4><p>结合上面的图看，在发送端，1、2、3 已发送并已确认(ACK)的；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><p>在接收端来看，1、2、3、4、5 是接受并且已确认的；6、7 是等待接收且未ACK的；8、9 是已经接收还没有 ACK 的。</p><p><strong>发送端和接收端当前的状态如下👇：</strong></p><ul><li>1、2、3 没有问题，双方达成了一致</li><li>4、5 接收方说 ACK 了，但是发送方还没收到回复</li><li>6、7、8、9 ，发送方已经发出，但是如果 8、9 先到，6、7 没到，则出现了乱序，先缓存着但是没办法 ACK。</li></ul><p>根据这个例子可以知道<strong>顺序问题</strong>和<strong>丢包问题</strong>都有可能存在，所以我们先来看<strong>确认与重传机制</strong>。</p><p><strong>假设 接受端 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办❓</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%93%8D%E5%BA%94.png" alt="情况"></p><p>一种方法是<strong>超时重试</strong>，<code>即对每一个发送了但是没有 ACK 的包设定一个定时器</code>，超过了一定的时间就重新尝试。这个时间<strong>必须大于往返时间</strong>，但也不宜过长，否则超时时间变长，访问就变慢了。</p><p>如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 <strong>5 原来接收过</strong>，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是<strong>超时间隔加倍</strong>。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。</p><p>超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？</p><p>有一个快速重传的机制，即当<strong>接收方</strong>接收到一个<strong>序号大于期望的报文段时</strong>，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的<strong>报文段</strong>。</p><p>例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><h4 id="3-3-5-流量控制的问题"><a href="#3-3-5-流量控制的问题" class="headerlink" title="3.3.5 流量控制的问题"></a>3.3.5 流量控制的问题</h4><p>在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小</p><p>简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了</p><h4 id="3-3-6-拥塞控制的问题"><a href="#3-3-6-拥塞控制的问题" class="headerlink" title="3.3.6 拥塞控制的问题"></a>3.3.6 拥塞控制的问题</h4><p>也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。</p><p>水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的</p><p><strong>水 = 水管粗细 * 水管长度</strong>。对于网络上，<strong>通道的容量 = 带宽 * 往返时延</strong>。</p><p>如果我们设置发送窗口，使得<strong>发送但未确认的包为通道的容量</strong>，就能撑满整个管道。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%8B%A5%E5%A1%9E.jpg" alt></p><p>如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，<strong>但是 ACK 还没返回</strong>，<strong>不能算发送成功</strong>，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。</p><p>如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现<strong>接收端处理不过来</strong>，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端，它的缺点会<strong>增加时延</strong>，如果时延达到一定程度就会<strong>超时重传</strong></p><p><strong>TCP 拥塞控制主要来避免两种现象，包丢失和超时重传</strong>，一旦出现了这些现象说明发送的太快了，要慢一点。</p><p>具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来</p><p>慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。</p><p><strong>拥塞的一种表现是丢包</strong>，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>TCP协议需要三次握手通信成功后进行建立，应用场景：互联网和企业网上客户端应用，数据传输性能让位于数据传输的完整性，可控制性和可靠性。<br>UDP协议是直接发送，不会判断是否接收和发送成功，应用场景：当强调输出性能而非完整性时，如音频和多媒体的应用。</p><blockquote><p>TCP 为什么是可靠连接</p></blockquote><ul><li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li><li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li><li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li><li>TCP 拥有流量控制及拥塞控制的机制</li></ul><blockquote><p> TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的<br>拥塞控制时通过拥塞窗口来解决的</p></blockquote><p>参考资料：</p><ul><li>《图解TCP/IP》</li><li><a href="https://blog.csdn.net/zhang6223284/article/details/81414149" target="_blank" rel="noopener">https://blog.csdn.net/zhang6223284/article/details/81414149</a></li></ul><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/dui-tcp-ip-de-zong-jie.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/UDP </tag>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网际协议之ICMP协议</title>
      <link href="/wang-ji-xie-yi-zhi-icmp-xie-yi.html"/>
      <url>/wang-ji-xie-yi-zhi-icmp-xie-yi.html</url>
      
        <content type="html"><![CDATA[<h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><blockquote><p>在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议。也是，ICMP 是为了分担IP 一部分功能而被制定出来的。</p></blockquote><ol><li>什么是ICMP协议?</li><li>ICMP协议的作用是什么?</li></ol><h2 id="1-ICMP协议概述"><a href="#1-ICMP协议概述" class="headerlink" title="1. ICMP协议概述"></a>1. ICMP协议概述</h2><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并<strong>不传输用户数据，但是对于用户数据的传递起着重要的作用。</strong><br>ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个<strong>组成部分</strong>，必须由每个IP模块实现。</p><h2 id="2-ICMP协议作用"><a href="#2-ICMP协议作用" class="headerlink" title="2. ICMP协议作用"></a>2. ICMP协议作用</h2><p>以上是ICMP较为官方的解释，那么ICMP的作用到底是什么？</p><p>我们通过下面这个例子说明ICMP协议的作用👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/ICMB1.png" alt="img"></p><p>上图描述的情景是，一个贵族想通过马车去山的那边，但是他并不知道通往山的路是否能通过马车，于是托斥候去打探山路是否能通过。</p><p>上图的例子中，<strong>斥候这个角色相当于“ICMP协议”，</strong>马车和贵族相当于数据包，斥候去打探的时候轻装上阵，并没有带上马车，也就是说<strong>ICMP协议并不传输用户数据</strong>，斥候打探之后带着结果回来，告诉贵族前方的路的状况。</p><p>贵族托斥候去打探路通不通这一动作相当于我们平时用的<strong>Ping</strong>命令，我们常用Ping命令去Ping一个IP地址或者域名，测试能否连接，<strong>Ping这个命令是ICMP协议的经典实现之一，还有一个是tracert命令。</strong></p><h2 id="3-ICMP协议具体实现"><a href="#3-ICMP协议具体实现" class="headerlink" title="3. ICMP协议具体实现"></a>3. ICMP协议具体实现</h2><h3 id="3-1-Ping命令"><a href="#3-1-Ping命令" class="headerlink" title="3.1 Ping命令"></a>3.1 Ping命令</h3><p>ping 命令用来在IP 层次上调查与指定机器是否连通，调查数据包往复需要多少时间。为了实现这个功能，ping 命令使用了两个ICMP 报文。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/ICMP3.png" alt="Ping命令过程"></p><p><strong>上图这一过程需要注意的有：</strong></p><ol><li><p>向目标服务器发送回送请求。<br>首先，<strong>向目标服务器发出回送请求</strong>（类型是8，代码是0）报文。在这个回送请求报文里，除了类型和代码字段，还被追加了<strong>标识符和序号字段</strong>。标识符和序号字段分别是16 位的字段。ping 命令在发送回送请求报文时，在这两个字段里填入任意的值。对于标识符，应用程序执行期间送出的所有报文里填入相同的值。对于序号，每送出一个报文数值就增加1。而且，回送请求的选项数据部分用来装任意数据。这个任意数据用来调整ping 的交流数据包的大小。</p></li><li><p>鹦鹉学舌一样返回回送回答。<br>计算机送出的回送请求到达目标服务器后，<strong>服务器回答这一请求</strong>，<strong>向送信方发送回送请求（类型是0，代码是0）</strong>。这个ICMP 回送回答报文在IP 层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP 地址字段被交换了，类型字段里填入了表示回送回答的0。也就是，从送信方来看，自己送出的ICMP 报文从目标服务器那里象鹦鹉学舌那样原样返回了。<br>送信方的计算机可以通过收到回送回答报文，来确认目标服务器在工作着。进一步，记住发送回送请求报文的时间，与接收到回送回答报文的时间一比较，就能计算出报文一去一回往复所需要的时间。但是，收到的回送回答报文里写的只是类型和代码的话，发送方计算机将无法判断它是否是自己发出去请求的回答。因此，前面说到的标识符和序号字段就有它的意义了。将这两个值与回送回答报文中的相同字段值一比较，送行方计算机就能够简单地检测回送回答是否正确了。执行ping 命令而调查的结果没什么问题的话，就将目标服务器的IP 地址，数据大小，往复花费的时间打印到屏幕上。</p></li><li><p>用ping 命令不能确定与对方连通的原因大致有三个。</p><ul><li>目标服务器不存在；</li><li>花在数据包交流上的时间太长ping 命令认为超时；</li><li>目标服务器不回答ping 命令。如果是原因2），通过ping 命令的选项来延长到超时的等待时间，就能正确显示结果了。如果原因是1）或3）的话，仅凭ping 命令的结果就不能判断是哪方了。正如这样，ping 命令不一定一定能判断对方是否存在。</li></ul></li></ol><h3 id="3-2-traceroute命令"><a href="#3-2-traceroute命令" class="headerlink" title="3.2 traceroute命令"></a>3.2 traceroute命令</h3><p>为了调查到通信对方的路径现在是怎么样了，使用的是traceroute 命令。它与ping 并列，是代表网络命令。这个traceroute 也是ICMP 的典型实现之一。</p><p>Windows上执行Tracert命令👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tracert.png" alt="Windows上执行tracert命令"></p><p>测试Tracert命令👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/ICMP4.png" alt="traceroute"></p><ol><li><p>执行tracert命令。<br>在Windows 上执行tracert 命令后，首先计算机向目的服务器发送IP 数据包。Windows 上使用的是与ping 同样的ICMP 回送请求报文。但是，有一点和通常的回送请求不一样。那是，最初将IP 首部的TTL(生存时间)字段<strong>设为1</strong> 这一点。<br>路由器每转送一次数据包就将TTL 的值减1。当TTL 变为0 的时候，按规定将丢弃这个数据包。正如这样，与其说TTL 是时间，还不如说TTL 是经过路由器的个数。对于计算机发送出去的数据包，只要它与目标服务器不在同一局域网内，一定会被哪儿的路由器中继。这时如果TTL 的值是1，由于路由器的处理会变为0，则该数据包将会<strong>被丢弃</strong>（同2）。</p></li><li><p>用超时报文来通知送信方。<br>路由器丢弃数据包的同时，用ICMP 报文来通知错误。这时使用的ICMP 报文是，类型为11，代码为0 的ICMP 超时报文。而且在选项数据字段里，将填入原先数据包的IP 首部和ICMP 的开始8 字节。正如ping 命令的时候看到的，ICMP 回送请求的先头8 字节里包含了标识符和序号字段。因此，送信方的计算机看了超时报文后，就知道是针对自己发出的回送请求的错误通知。<br>计算机接到针对第一个数据包的ICMP 超时报文后，接下来将TTL 加1（TTL=2）并同样地送出（同3）。这次通过第一个路由器，TTL 变为1，到达第二个路由器。但是第二个路由器象前面一样，由于TTL变为0，将不能转发该包。因此，同第一个路由器一样，将该包丢弃，并返回ICMP 超时报文。以后，收到错误的发送方计算机将TTL 加1，重复同样的工作（同4）。</p></li><li><p>只有目标服务器的反应不同。<br>如此一个一个增加TTL，某个时候ICMP 回送请求报文将到达最终的目标服务器。这时，只有目标服务器与途中的路由器不同，不返回ICMP 超时报文。为什么呢？因为即使目标服务器收到TTL 为1 的数据包也不会发生错误。<br>作为代替处理，服务器针对送信方计算机发出的ICMP 回送请求报文，返回ICMP 回送回答报文。也就是，送信方计算机与服务器之间，与ping 命令的执行一样了（同5）。得到了ICMP 回送回答报文的送信方知道了路经调查已经到了目标服务器，就结束了tracert 命令的执行（同6）。像这样，通过列出中途路由器返回的错误，就能知道构成到目标服务器路径的所有路由器的信息了。</p></li><li><p>操作系统不同则实现方法略微不同。<br>到这里，以Windows 上的tracert 命令为例看了原理，有些别的操作系统的traceroute 命令的原理略微不同。<br>具体来说，也有用向目标发送UDP 数据包代替ICMP 回送请求报文来实现的。虽说是用UDP，但途中的路由器的处理与図 8完全相同。只是UDP 数据包到达目标后的处理不同。目标计算机突然收到与通信无关的数据包，就返回ICMP 错误，因此根据返回数据包的内容来判断命令的中止。</p></li></ol><h2 id="4-ICMP协议报文格式"><a href="#4-ICMP协议报文格式" class="headerlink" title="4 ICMP协议报文格式"></a>4 ICMP协议报文格式</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/ICMP%E6%8A%A5%E6%96%87.png" alt></p><p>更加详细地看一下数据包的格式吧。用来传送ICMP 报文的IP 数据包上实际上有不少字段。但是实际上与ICMP 协议相关的只有7 个子段。</p><pre><code>   **这四个包含在IP 首部的字段。**</code></pre><ol><li><p>协议；</p></li><li><p>源IP 地址；</p></li><li><p>目的IP 地址；</p></li><li><p>生存时间；</p><p><strong>这三个包含在ICMP数据部分的字段。</strong></p></li><li><p>类型；</p></li><li><p>代码；</p></li><li><p>选项数据；</p></li></ol><p>这里面，1)协议字段值是1。2)和3)是用来交流ICMP 报文的地址信息，没有特殊意义。</p><p>对于理解ICMP 本身，重要的是5)，6)，7)三个字段。</p><p>这里面的可以称为核心的重要字段是5)类型，6)代码这两个字段。所有ICMP 用来交流错误通知和信息询问的报文，都是由类型和代码的组合来表示的。</p><p>RFC 定义了15种类型。“报文不可到达”这样的错误通知和“回送请求”这样的信息查询是由类型字段来区分的。</p><p>ICMP报文由类型来表达它的大概意义，需要传递细小的信息时由代码来分类。进一步，需要向对方传送数据的时候，用7）选项数据字段来放置。</p><p><strong>可能的消息列表：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%B6%88%E6%81%AF.png" alt="可能的消息列表"></p><h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h2><p>ICMP协议还有好多实现，例如<strong>改变路由、源点抑制、端口扫描</strong>等，ICMP协议的安全问题也需要重视，比如<strong>“Ping of Death”</strong>攻击，碍于篇幅关系，在这片博客中不再叙述，感兴趣的朋友可以查找相关资料。</p><p>通过总结，我们可知ICMP协议是非常便利的一个协议。</p><p>CMP协议可以用来<strong>检测网络通信故障和实现链路追踪</strong>等。</p><p>参考资料：</p><ul><li>《图解TCP/IP》</li><li><a href="https://www.cnblogs.com/iiiiher/p/8513748.html" target="_blank" rel="noopener">https://www.cnblogs.com/iiiiher/p/8513748.html</a></li><li><a href="http://m.elecfans.com/article/598375.html" target="_blank" rel="noopener">http://m.elecfans.com/article/598375.html</a></li></ul><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/wang-ji-xie-yi-zhi-icmp-xie-yi.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络层协议 </tag>
            
            <tag> ICMP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP协议详解</title>
      <link href="/ip-xie-yi-xiang-jie.html"/>
      <url>/ip-xie-yi-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><ul><li>IP协议的原理是什么？</li><li>IP协议和IP地址有什么关系？</li><li>IP协议的首部是怎么样的</li></ul><h2 id="1-1-IP协议概述"><a href="#1-1-IP协议概述" class="headerlink" title="1.1 IP协议概述"></a>1.1 IP协议概述</h2><p><span style="color:red;font-weight:800;">无连接、不可靠</span></p><blockquote><p>IP协议（Internet Protocol，互联网协议），是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向<strong>无连接</strong>和<strong>不可靠</strong>的传输功能。</p></blockquote><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/IP%E4%BD%9C%E7%94%A8.png" alt="IP的作用"></p><hr><h2 id="1-2-IP协议原理"><a href="#1-2-IP协议原理" class="headerlink" title="1.2 IP协议原理"></a>1.2 IP协议原理</h2><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Server3.png" alt="无IP"></p><p>如上图所示，当多台接入互联网的设备访问同一台服务器的时候，服务器如何区分不同电脑的请求，并且准确的将资源返回？</p><p>我们只要给每个设备加上一些<strong>“标识”</strong>，并且在通信的时候，将“标识”<strong>嵌入到数据包里</strong>，则整个数据往返过程可以准确无误。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/IPServer.png" alt="加入IP"></p><p>我们给PC和服务器加入IP地址，并且以PC1访问服务器为例：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/ServerPC1.png" alt="PC1访问服务器"></p><p><strong>PC1的IP地址为12.1.8.66,Server的地址为8.8.8.8，那么整个通信过程应该是这样的📞：</strong></p><ol><li>PC1在请求数据包里<strong>封装了源IP地址和目的IP地址</strong>，并将带有IP地址信息的数据包发送到互联网。</li><li>在互联网中有大量的网络通信设备（路由器等），路由器根据数据包中的IP地址查找路由表（Map），然后以<strong>接力的形式</strong>，将数据包逐条转发至目标服务器。</li><li>服务器接收到请求数据包之后，将<strong>源IP地址和目的IP地址翻转</strong>，并封装回应数据包发送到互联网。</li></ol><p><strong>上面这个通信过程类似于我们平时的寄信✉：</strong></p><ol><li>寄信时需要在信封中填写发件人和收件人的姓名和地址，然后将信件塞入信封中。</li><li>邮政公司根据信封中的收件地址，通过物流平台（飞机、货车）将信件跨省市传输，直至收件人城市。</li><li>送信员找到对应的收件人所在的小区地址，然后联系收件人，将信件交付到收件人手中</li></ol><p>在寄信过程中，<strong>信封相当于IP地址，整个信件相当于数据包，邮政公司|送信员相当于路由器|交换机。</strong></p><p><strong>通过以上的案例我们可以明确以下知识点：</strong></p><ol><li>IP协议通过提供IP地址，将IP地址夹带在通信数据包中，为路由器指明通信方向。</li><li>IP协议仅仅指明数据包的源目通信方，但是并不能保证数据包一定能够送达，数据是否被丢弃以及丢弃后如何处理。<strong>（所以IP协议是面向无连接的不可靠传输功能）（TCP协议可以解决P协议的缺陷）</strong></li></ol><p>当然，IP协议不仅仅只有”导航“功能，他还能防止数据包环路，<strong>为数据打上重要或不重要等标签实现流量控制、能验证数据包是否损坏、能实现数据包分片和组装功能</strong>；而要深入学习这些功能，必须掌握<strong>IP头部</strong>的封装格式。</p><hr><h2 id="1-3-IP协议头部"><a href="#1-3-IP协议头部" class="headerlink" title="1.3 IP协议头部"></a>1.3 IP协议头部</h2><p>以下是对某一数据包的抓包结果：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%9C.png" alt="抓包结果"></p><p>我们可以看到IP头部默认有12个字段：</p><ol><li><strong>Version（版本号）：</strong>标识IP协议的版本，目前V4版本地址已经枯竭，V6慢慢成为主流。</li><li><strong>Header Length（头部长度）</strong>：默认为20字节，最大为60字节。</li><li><strong>Differentiated Services Field （服务区分符）</strong>：用于为不同的IP数据包定义不同的服务质量，一般应用在QoS技术中。</li><li><strong>Total Length （总长度）：</strong>标识IP头部加上上层数据的数据包大小，IP包总长度最大为65535个字节。</li><li><strong>Identification （标识符）：</strong>用来实现IP分片的重组，标识分片属于哪个进程，不同进程通过不同ID区分。</li><li><strong>Flags（标志符）：</strong>用来确认是否还有IP分片或是否能执行分片。</li><li><strong>Fragment offset （分片偏移量）：</strong>用于标识IP分片的位置，实现IP分片的重组。</li><li><strong>Time to live （生存时间）：</strong>标识IP数据包还能生存多久，根据操作系统不同，TTL默认值不同，每经过一个三层设备如路由器的处理，则TTL减去1，当TTL=0时，则此数据包被丢弃。</li><li><strong>Protocol （协议号）：</strong>标识IP协议上层应用。当上层协议为ICMP时，协议号为1，TCP协议号为6，UDP的协议号为17。</li><li><strong>Header checksum （头部校验）：</strong>用于检验IP数据包是否完整或被修改，若校验失败则丢弃数据包。</li><li><strong>Source（源IP地址）：</strong>标识发送者IP地址，占用32bit。</li><li><strong>Destination （目的IP地址）：</strong>标识接收者IP地址，占用32bit。</li></ol><p><strong>了方便记忆，可以总结为7个核心知识点：</strong></p><ol><li><strong>Source和Destination即IP源目地址字段，是IP协议最核心的字段；</strong></li><li><strong>Id+Flags+FO三个字段可以实现IP数据分片和重组；</strong></li><li><strong>Total Length和Header Length标记IP头部和上层数据的边界；</strong></li><li><strong>TTL生存时间字段可以实现通信防环；</strong></li><li><strong>DSCP服务区分符可以实现流量控制；</strong></li><li><strong>Checksum字段可以数据包完整性校验；</strong></li><li><strong>Protocol字段标记上层应用；</strong></li></ol><hr><h3 id="1-3-1-length长度字段解读"><a href="#1-3-1-length长度字段解读" class="headerlink" title="1.3.1 length长度字段解读"></a>1.3.1 length长度字段解读</h3><p><span style="color:red;font-weight:800;">划分界限</span></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/IP%E9%95%BF%E5%BA%A6.png" alt="Length"></p><p>长度字段在大部分的协议里都会出现，例如TCP、UDP、IP协议，为了就是<strong>”划分界限“</strong>—&gt;<strong>规定哪里是头部，哪里是数据。</strong></p><p>由上图可知，IP协议的头部是20字节（默认为20字节，最长可到60字节），Total Length在这里表明是100字节，那么数据部分则是100-20=80字节。</p><p>那么这个头部和数据之间的界限有何用处？👇</p><p>当收到数据包之后，无论是电脑/手机还是其他联网设备，网卡模块会对数据包进行拆分、修改IP头部信息、重新进行数据封装等操作，<strong>如果没有”这条线”，那就可能会”越界”，一旦”越界”，则数据包内容可能损坏</strong>，</p><p>我们看下面这张图片👇</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7.png" alt="数据完整性被破坏！"></p><p>当没有长度字段或者长度字段标识错误时，网卡在进行头部剥离的时候，<strong>错误的把数据部分划分到头部里面</strong>，这就会导致右边的数据部分完整性被破坏，接收方最终收到的就是一个损坏的数据包。</p><hr><h3 id="1-3-2-TTL生存时间字段解读"><a href="#1-3-2-TTL生存时间字段解读" class="headerlink" title="1.3.2 TTL生存时间字段解读"></a>1.3.2 TTL生存时间字段解读</h3><p><span style="color:red;font-weight:800;">实现通信防环</span></p><p>TTL（Time to live）即生存时间，用于标识IP数据包<strong>“还能存活多久”</strong>，这个生存值在发送方发送数据时便设置好了。不同电脑/操作系统的初始TTL是不同的，并且TTL值可以修改。</p><p>TTL值占用8个bit位，所以最大值是255（二进制11111111）</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TTL1.png" alt="TTL"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TTL2.png" alt="TTL Dead"></p><p>上图所示👆，IP数据包每经过一个路由器或者其他三层设备时，TTL就会被减去1，当<strong>TTL=0</strong>的时间，就代表这个数据包已经<strong>”死亡“</strong>，此时路由器便会向源发送者返回一个<strong>”TTL Exceed“</strong>的<strong>ICMP</strong>报错包。</p><p>TTL一个重要的功能就是<strong>实现通信防环</strong>，那么何为防环❓请看下图👇：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TTL%E7%8E%AF%E8%B7%AF.png" alt="环路"></p><p>​        我们知道，路由器会将数据包以<strong>接力</strong>的形式逐条传递，很多时候，由于工程师的疏忽，或者因为网络拓扑结构的复杂性，会出现一些Bug环境，例如上图便是一个经典的<strong>”环路拓扑“</strong>，由于网络设备之间存在的<strong>环路”Loop“</strong>，所以数据包一直里面饶起来，而不是发送到最右边的服务器。</p><p>​        如果<strong>没有TTL</strong>，那么这个数据包将会一直存在于链路中，这样不仅占用网络带宽，并且浪费设备的处理器资源，严重的时候将会拖垮其他人的正常通信。</p><p>​        所以，当IP数据包加入TTL值之后，<strong>即便网络拓扑存在环路设计，当数据包被转发到TTL为0的时候，网络设备也可以直接丢弃，以此解决环路带来的危害</strong>。</p><p><span style="color:orange;">但是TTL仍然是一种“被动式”的解决环路的办法，真正要解决环路，还需要从网络设计和协议设计的角度切入。</span></p><hr><h3 id="1-3-3-DSCP字段解读"><a href="#1-3-3-DSCP字段解读" class="headerlink" title="1.3.3 DSCP字段解读"></a>1.3.3 DSCP字段解读</h3><p><span style="color:red;font-weight:800;">DSCP服务区分符可以实现流量控制</span></p><p><span style="color:red;font-weight:800;">“VIP” 待遇</span></p><p>DSCP（Differentiated Services Field） 即服务区分符，用于<strong>为不同的IP数据包定义不同的服务质量</strong>。DSCP的前身叫做TOS（Type of Service，服务类型）。<strong>不管是TOS还是DSCP，它们都是QoS服务质量里面的技术实现。</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/DSCP2.png" alt="DSCP"></p><p>如上图所示👆，当PC1和PC2两个用户同时访问互联网时，由于数据包采用不同的DSCP值，不同的值代表了不同的优先级，例如这里的<strong>AF11和EF</strong>，可以看成一个是<strong>普通等级</strong>，一个是<strong>VIP等级</strong>，此<strong>时VIP等级自然要优先被转发。</strong></p><p>应用场景：<strong>在企业网中，网络运维人员可以为核心数据流采用高优先级的DSCP值，为其他普通的例如BT下载流量采用最普通的优先级。在运营商网络里，可以根据客户购买的不同专线服务，采用不同的DSCP值</strong>。</p><hr><h3 id="1-3-4-Checksum字段解读"><a href="#1-3-4-Checksum字段解读" class="headerlink" title="1.3.4 Checksum字段解读"></a>1.3.4 Checksum字段解读</h3><p><span style="color:red;font-weight:800;">实现数据完整性校验</span></p><p>checksum校验字段跟长度字段类似，存在于很多协议里面，用于实现数据完整性校验。</p><p>不同协议采用的方法有差异，例如IP协议的checksum值只校验IP头部，不包括数据部分，而TCP和UDP的校验则包括数据部分。</p><p>例如PC1发送IP数据包（含checksum1）给PC2，PC2拆开IP头部，然后进行校验计算（checksum2），<strong>若校验没问题则接收并处理，若检验有问题则丢弃</strong>。注意，这里采用的是校验算法，不是简单的相同对比。</p><hr><h5 id="1-1-3-5-Protocol字段解读"><a href="#1-1-3-5-Protocol字段解读" class="headerlink" title="1.1.3.5 Protocol字段解读"></a>1.1.3.5 Protocol字段解读</h5><p><span style="color:red;font-weight:800;">协议号</span></p><p>ICMP、TCP、UDP所对应的Protocol协议号👇：</p><table><thead><tr><th>ICMP</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>1</td><td>6</td><td>17</td></tr></tbody></table><p>无论是IP协议的Protocol字段，还是Internet以太网协议里面的Type字段，又或者是TCP/UDP协议里面的Port字段，这些字段的功能都是<strong>用于标识上层协议或应用</strong>。例如，<strong>ICMP协议号为1，TCP协议号为6，UDP的协议号为17</strong>。</p><p>那么，在IP协议里面加入协议号标识传输层协议，意义何在❓</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Protocol.png" alt="Protocol"></p><p>通过上面这张图我们可以看到，若PC1 PING PC2，则此时会采用ICMP协议，而ICMP协议对应的协议号是1。当PC2收到这个数据包时，拆开IP头部，则会看到协议号，根据协议号调用对应的上层协议或应用来进行上层数据处理。</p><p>以这里例子来看，若PC2采用TCP或UDP来解开ICMP数据包，则无法正常解析，<strong>好比用word程序要打开一部mp4电影，肯定会有故障</strong>。而如果这里PC2根据协议号为1，调用ICMP协议来处理ICMP数据包，则可以正常解读并返回回应包。</p><p>所以，协议号（Protocol）、端口号（Port）、类型值（Type）这些的功能都是：标记上层协议/应用，告诉接收方，有正确的协议/应用来打开这个数据，功能相当于电脑文件的后缀名，告诉电脑用哪些应用程序来打开对应的文件。</p><p>参考资料：</p><ul><li>《TCP/IP》图解</li><li><a href="https://blog.51cto.com/chenxinjie/1970704" target="_blank" rel="noopener">https://blog.51cto.com/chenxinjie/1970704</a></li></ul><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/ip-xie-yi-xiang-jie.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络层协议 </tag>
            
            <tag> IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI分层模型和TCP/IP分层模型</title>
      <link href="/dui-tcp-ip-de-zong-jie.html"/>
      <url>/dui-tcp-ip-de-zong-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="OSI参考模型和TCP-IP分层模型"><a href="#OSI参考模型和TCP-IP分层模型" class="headerlink" title="OSI参考模型和TCP/IP分层模型"></a>OSI参考模型和TCP/IP分层模型</h1><blockquote><p>最近看了《图解TCP/IP》这本书，于是将这本书中的精髓做一个归总，以便之后查阅。</p></blockquote><h2 id="1-何为协议？"><a href="#1-何为协议？" class="headerlink" title="1.何为协议？"></a>1.何为协议？</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><strong>协议</strong>就是计算机与计算机之间通过网络实现通信事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，<strong>只要遵循相同的协议就能够实现通信</strong>。反之，如果使用的协议不同，就无法通信。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcpip.png" alt="协议约定"></p><p style="color:red;">Windows操作系统的平板电脑和Mac操作系统的一体机电脑，虽然操作系统不同，硬件组成不同，但是只要事先达成一个详细的约定，并遵循这一约定进行处理方可建立通信。</p><h2 id="2-协议分层与OSI参考模型"><a href="#2-协议分层与OSI参考模型" class="headerlink" title="2 协议分层与OSI参考模型"></a>2 协议分层与OSI参考模型</h2><h3 id="2-1-OSI参考模型"><a href="#2-1-OSI参考模型" class="headerlink" title="2.1 OSI参考模型"></a>2.1 OSI参考模型</h3><p>协议分层就如同计算机软件中的<strong>模块化开发</strong>，OSI参考模型的建议是比较理想化的一种分层模型。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/osi.png" alt="OSI七层模型"></p><ul><li>OSI参考模型中定义了每一层的<strong>“作用”</strong></li><li>定义每一层作用的是<strong>“协议”</strong></li><li>“协议”是约定，其具体内容为<strong>“规范”</strong></li><li>我们日常所使用的就是遵循各个协议具体“规范”的产品和通信手段</li></ul><h3 id="2-2-OSI参考模型中各层作用"><a href="#2-2-OSI参考模型中各层作用" class="headerlink" title="2.2 OSI参考模型中各层作用"></a>2.2 OSI参考模型中各层作用</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcp%E8%A7%A3%E9%87%8A.png" alt="OSI模型各层解释"></p><h4 id="2-2-1-物理层"><a href="#2-2-1-物理层" class="headerlink" title="2.2.1 物理层"></a>2.2.1 物理层</h4><p style="color:red;font-weight:800;">信号和介质</p><p style="color:red;font-weight:800;">比特流与电子信号之间的切换</p><p>​        物理层（Physical Layer）是计算机网络OSI模型中<strong>最低的一层</strong>。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的数据可在各种<strong>物理媒体</strong>上传输。局域网与广域网皆属第1、2层。<br>​        物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信<strong>提供传输媒体及互连设备</strong>，为数据传输提供可靠的环境。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%89%A9%E7%90%86%E5%B1%82.png" alt="物理层"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%89%A9%E7%90%86%E5%B1%821.png" alt="物理层"></p><h4 id="2-2-2-数据链路层"><a href="#2-2-2-数据链路层" class="headerlink" title="2.2.2 数据链路层"></a>2.2.2 数据链路层</h4><p style="color:red;font-weight:800;">数据帧与比特流之间的转换</p><p>​        数据链路层是OSI参考模型中的<strong>第二层</strong>，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将<strong>源自网络层来的数据可靠地传输到相邻节点的目标机网络层</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="数据链路层"></p><h4 id="2-2-3-网络层"><a href="#2-2-3-网络层" class="headerlink" title="2.2.3 网络层"></a>2.2.3 网络层</h4><p style="color:red;font-weight:800;">路径选择、路由及逻辑寻址</p><p>​        网络层是OSI参考模型中的<strong>第三层</strong>，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，<strong>将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><h4 id="2-2-4-传输层"><a href="#2-2-4-传输层" class="headerlink" title="2.2.4 传输层"></a>2.2.4 传输层</h4><p style="color:red;font-weight:800;">管理两个节点之间的数据传输</p><p style="color:red;font-weight:800;">关键层次之一，TCP/UDP运行在传输层</p><p>​        传输层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。由于一个主机同时运行多个进程，因此运输层具有有<strong>复用和分用</strong>功能。传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段/重组和差错控制来保证数据传输的可靠性。传输层的一些协议是面向链接的，这就意味着传输层能保持对分段的跟踪，并且<strong>重传</strong>那些失败的分段。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%BC%A0%E8%BE%93%E5%B1%82.png" alt="传输层"></p><h4 id="2-2-5-会话层"><a href="#2-2-5-会话层" class="headerlink" title="2.2.5 会话层"></a>2.2.5 会话层</h4><p style="color:red;font-weight:800;">为会话实体间建立连接👉数据传输阶段👉连接释放</p><p>​        会话层(Session)是建立在传输层之上，利用传输层提供的服务，使应用<strong>建立和维持会话</strong>，并能使会话获得<strong>同步</strong>。会话层使用<strong>校验点</strong>可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%BC%9A%E8%AF%9D%E5%B1%82.png" alt="会话层"></p><h4 id="2-2-6-表示层"><a href="#2-2-6-表示层" class="headerlink" title="2.2.6 表示层"></a>2.2.6 表示层</h4><p style="color:red;font-weight:800;">数据的压缩、解压、加密、解密</p><p style="color:red;font-weight:800;">语法转换、语法协商、连接管理</p><p>​        表示层向上对应用层服务，向下接受来自会话层的服务。表示层为在应用过程之间传送的信息提供表示方法的服务，它只关心信息发出的语法和语义。</p><p>​        表示层位于OSI分层结构的第六层，它的主要作用之一是为异种机通信提供一种<strong>公共语言</strong>，以便能进行互操作。<strong>这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同</strong>。与第五层提供透明的数据运输不同，表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。每台计算机可能有它自己的表示数据的内部方法，例如，ASCII码与EBCDIC码，所以需要表示层协定来保证不同的计算机可以彼此理解。</p><p>​        通过前面的介绍,我们可以看出,会话层以下5层完成了端到端的数据传送,并且是可靠,无差错的传送.<strong>但是数据传送只是手段而不是目的,最终是要实现对数据的使用</strong>.由于各种系统对数据的定义并不完全相同,最易明白的例子是键盘,其上的某些键的含义在许多系统中都有差异.这自然给利用其它系统的数据造成了障碍.表<strong>示层和应用层就担负了消除这种障碍的任务.</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%A1%A8%E7%A4%BA%E5%B1%82.png" alt="表示层"></p><h4 id="2-2-7-应用层"><a href="#2-2-7-应用层" class="headerlink" title="2.2.7 应用层"></a>2.2.7 应用层</h4><p style="color:red;font-weight:800;">直接为应用进程提供应用服务</p><p style="color:red;font-weight:800;">每个应用有不同的应用协议</p><p>​        应用层直接和应用程序接口并提供常见的<strong>网络应用服务</strong>。应用层也向表示层发出请求。<br>​        应用层是开放系统的最高层,是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时,完成一系列业务处理所需的服务.其服务元素分为两类:公共应用服务元素CASE和特定应用服务元素SASE.</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="应用层"></p><h3 id="2-3-OSI-7层模型应用通信实例"><a href="#2-3-OSI-7层模型应用通信实例" class="headerlink" title="2.3 OSI 7层模型应用通信实例"></a>2.3 OSI 7层模型应用通信实例</h3><p style="color:red;font-weight:800;">至上而下和至下而上</p><p style="color:red;font-weight:800;">附加首部信息</p><p style="color:red;font-weight:800;">封装和解封装</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B2.jpg" alt="QQ消息"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B.png" alt="发送邮件实例"></p><ol><li><strong>发送方</strong>从模型的第七层到第一层<strong>至上而下</strong>传输数据，<strong>接收方</strong>则<strong>至下而上</strong>从第一层到第七层传输数据</li><li>发送端发送信息的过程中，每个分层上，在处理上一层传过来的数据时，都会在数据中附上当前协议需要包含的<strong>“首部信息”</strong></li><li>接收端对收到的数据进行数据“首部”与“内容”的<strong>分离</strong>，再转发给上一分层，并最终将发送端的数据恢复为原装。</li></ol><h2 id="3-TCP-IP协议"><a href="#3-TCP-IP协议" class="headerlink" title="3 TCP/IP协议"></a>3 TCP/IP协议</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p style="color:red;font-weight:800;">协议“簇”</p><p>​        TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的<strong>协议簇</strong>。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， <strong>只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</strong> </p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%8D%8F%E8%AE%AE%E7%B0%87.png" alt="TCP/IP协议簇"></p><h3 id="3-2-TCP-IP协议分层模型"><a href="#3-2-TCP-IP协议分层模型" class="headerlink" title="3.2 TCP/IP协议分层模型"></a>3.2 TCP/IP协议分层模型</h3><p style="color:red;font-weight:800;">TCP/IP分层模型将OSI参考模型的应用程、表示层、会话层统一归为应用层</p><p style="color:red;font-weight:800;">TCP/IP更强调“在计算机上实现协议应该开发哪种程序</p><p>​        由于TCP/IP尽早地制定了可行性较强的协议，提出了应对技术快速革新的协议，并及时进行后期改良的方案，因此<strong>打败了OSI模型，成为了事实上的标准</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcpip%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="TCP/IP分层模型"></p><p>​        由上图可见👆，OSI和TCP/IP在分层模块上稍有区别，TCP/IP分层模型将应用程、表示层、会话层统一划入应用层，OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪种程序”。</p><h3 id="3-3-TCP-IP分层模型应用通信实例"><a href="#3-3-TCP-IP分层模型应用通信实例" class="headerlink" title="3.3 TCP/IP分层模型应用通信实例"></a>3.3 TCP/IP分层模型应用通信实例</h3><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TCPIP%E5%AE%9E%E4%BE%8B.png" alt="实例"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcpip%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="TCP/IP体系结构"></p><h3 id="3-4-通信过程数据变化"><a href="#3-4-通信过程数据变化" class="headerlink" title="3.4 通信过程数据变化"></a>3.4 通信过程数据变化</h3><p>帧和数据包都是数据的传输形式。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E9%A1%BA%E5%BA%8F.png" alt></p><ul><li><p>数据链路层：Frame（帧）</p></li><li><p>网络层：Packet（数据包）</p></li><li><p>传输层：</p><ul><li>TCP的叫做Segment（数据段）</li><li>UDP的叫做Datagram（数据报）</li></ul></li><li><p>应用层：Message（消息）</p></li></ul><ul><li><p>Frame（帧），工作在二层，数据链路层传输的是数据帧，包含数据包，并且增加相应<strong>MAC地址</strong>与二层信息；</p></li><li><p>Packet（数据包），工作在三层，网络层传输的是数据包，包含数据报文，并且增加传输使用的I<strong>P地址</strong>等三层信息。</p></li></ul><p>Packet（数据包）：封装的基本单元，它穿越网络层和数据链路层的分解面。通常一个Packet映射成一个Frame，但也有例外：即当数据链路层执行拆分或将几个Packet合成一个Frame的时候。  </p><p><strong>通信过程数据结构变化大致如下：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%98%E5%8C%96.png" alt="数据包变化"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%98%E5%8C%962.png" alt="数据包变化"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%AE%80%E4%BB%8B.jpg" alt="数据封装过程"></p><h4 id="3-4-1-传输层报头解析"><a href="#3-4-1-传输层报头解析" class="headerlink" title="3.4.1 传输层报头解析"></a>3.4.1 传输层报头解析</h4><p style="color:red;font-weight:800;">加入端口信息</p><p style="color:red;font-weight:800;">TCP\UDP协议</p><p>​        每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是<strong>无法确定哪个应用程序要接收这个包</strong>，所以需要在数据包中加入<strong>端口</strong>信息。</p><p><strong>TCP数据报头👇：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/TCP%E5%8C%85.png" alt="TCP数据报头结构"></p><p><strong>UDP数据报头👇：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/UDP%E5%8C%85.png" alt="UDP数据报头结构"></p><p><strong>常见端口信息👇：</strong></p><table><thead><tr><th align="left">应用进程</th><th align="left">FTP</th><th align="left">TELNET</th><th align="left">SMTP</th><th align="left">DNS</th><th align="left">TFTP</th><th align="left">HTTP</th><th align="left">SNMP</th></tr></thead><tbody><tr><td align="left"><strong>端口号</strong></td><td align="left"><strong>21</strong></td><td align="left"><strong>23</strong></td><td align="left"><strong>25</strong></td><td align="left"><strong>53</strong></td><td align="left"><strong>69</strong></td><td align="left"><strong>80</strong></td><td align="left"><strong>161</strong></td></tr></tbody></table><p style="color:green;font-weight:800">关于TCP/UDP等协议的异同点将在另一篇博客中专门介绍</p><h4 id="3-4-2-网络层数据报头解析"><a href="#3-4-2-网络层数据报头解析" class="headerlink" title="3.4.2 网络层数据报头解析"></a>3.4.2 网络层数据报头解析</h4><p style="color:red;font-weight:800;">IP数据报</p><p style="color:red;font-weight:800;">IP协议</p><p style="color:red;font-weight:800;">源IP地址、目标IP地址</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/IP%E6%95%B0%E6%8D%AE%E5%8C%85.png" alt="IP数据报解析"></p><p><a href="https://blog.csdn.net/xd_hebuters/article/details/79177349" target="_blank" rel="noopener">关于IP数据报相关博客（Click Me）</a></p><h4 id="3-4-3-数据链路层报头解析"><a href="#3-4-3-数据链路层报头解析" class="headerlink" title="3.4.3 数据链路层报头解析"></a>3.4.3 数据链路层报头解析</h4><p style="color:red;font-weight:800;">MAC帧</p><p style="color:red;font-weight:800;">LLC帧</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/MAC.jpg" alt="数据帧"></p><p><a href="http://m.elecfans.com/article/647662.html" target="_blank" rel="noopener">MAC和LLC子层的区别看这篇博文(Click Me)</a></p><h4 id="3-4-5-数据封装过程总结"><a href="#3-4-5-数据封装过程总结" class="headerlink" title="3.4.5 数据封装过程总结"></a>3.4.5 数据封装过程总结</h4><p>​        上层数据→→在传输层添加TCP头（包含端口信息等）→→在网络层添加IP头（包含IP协议等信息）→→在数据链路层添加LLC头和MAC头（包含MAC地址等信息）→→翻译成比特流（1101101…）</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>​        以上内容是我对《TCP/IP图解》这本书中分层模型等知识点的总结，数据在传输过程中是一个不断封装和解封的过程，一个数据要传输到另一个接收端，必须经过层层封装，封装的意义在于让发送端数据能够定位接收端的位置，让数据精准的被接受端应用程序接受。</p><p style="color:orange;">此篇博客并没有讲解各层具体的协议，这些内容将在下一篇博客中详细说明。</p><p>参考资料：</p><ul><li>《图解TCP/IP》</li><li><a href="https://www.cnblogs.com/edisonchou/p/5987827.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/5987827.html</a></li></ul><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/dui-tcp-ip-de-zong-jie.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议簇</title>
      <link href="/tcp-ip-xie-yi-cu.html"/>
      <url>/tcp-ip-xie-yi-cu.html</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP/IP协议簇"></a>TCP/IP协议簇</h1><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/tcp.png" alt="OSI"></p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</li></ul><h3 id="包含协议"><a href="#包含协议" class="headerlink" title="包含协议"></a>包含协议</h3><ul><li>以太网协议<ul><li>作用<ul><li>以太网规定一组电信号就是一个数据包，一个数据包被称为一帧</li></ul></li><li>规定<ul><li>接入网络的设备都必须安装网络适配器，即网卡， 数据包必须是从一块网卡传送到另一块网卡。</li><li>网卡地址就是数据包的发送地址和接受地址，也就是帧首部所包含的MAC地址。</li></ul></li></ul></li></ul><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li>MAC地址是每块网卡的身份标识</li><li>共6个字节</li><li>前三个是厂商编号，后三个字节是网卡流水号，例如4C-0F-6E-12-D2-19</li></ul><h3 id="以太网数据包组成"><a href="#以太网数据包组成" class="headerlink" title="以太网数据包组成"></a>以太网数据包组成</h3><ul><li>首部（14字节）+数据（46~1500字节）+尾部（4字节）<ul><li>首部：包含目标MAC地址、源MAC地址和类型</li><li>数据：最短为46字节，最长为1500字节，若传输数据很长就需要分割成多个帧发送</li><li>尾部：固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏</li></ul></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ul><li>发送者如何知道接收者的MAC地址？</li><li>发送者如何知道接收者和自己同属一个子网？</li><li>如果接收者和自己不在同一个子网，数据包如何发给对方</li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；</li></ul><h3 id="包含协议-1"><a href="#包含协议-1" class="headerlink" title="包含协议"></a>包含协议</h3><ul><li>IP协议<ul><li>前提<ul><li>无法通过MAC地址来判断两台主机是否属于同一个子网。</li></ul></li><li>作用<ul><li>使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。</li></ul></li><li>版本：IPv4和IPv6<ul><li>IPV4<ul><li>网络地址+局域网地址</li><li>IPv4是一个32位的地址，常采用4个十进制数字表示.IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。</li><li>如果两个IP地址在同一个子网内，则网络地址一定相同。</li><li>由于发送者和接收者的IP地址是已知的(应用层的协议会传入)， 因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。</li></ul></li><li>IPV6</li></ul></li></ul></li><li>ARP协议（地址解析协议）<ul><li>作用<ul><li>根据IP地址获取MAC地址的一个网络层协议</li></ul></li><li>过程<ul><li>ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址。</li><li>然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机。</li><li>每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。</li><li>ARP接收返回消息，以此确定目标机的MAC地址。</li></ul></li><li>特点<ul><li>会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li><li>cmd输入 arp -a 就可以查询本机缓存的ARP数据。</li></ul></li></ul></li><li>路由协议<ul><li>解决问题<ul><li>通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议；定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。</li></ul></li><li>过程<ul><li>首先通过IP协议来判断两台主机是否在同一个子网中<ul><li>如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包</li><li>如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由</li></ul></li><li>网关是互联网上子网与子网之间的桥梁，网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中</li><li>然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方</li></ul></li><li>设备<ul><li>路由器<ul><li>路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。</li></ul></li></ul></li></ul></li></ul><h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h3><ul><li>描述<ul><li>在网络层被包装的数据包就叫IP数据包</li></ul></li><li>组成<ul><li>首部（20字节）+数据（最大65515字节）<ul><li>首部长度为20个字节，主要包含了目标IP地址和源IP地址，目标IP地址是网关路由的线索和依据</li><li>数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节，而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送。</li></ul></li></ul></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。</li></ul><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul><li>定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性</li></ul><h3 id="包含协议-2"><a href="#包含协议-2" class="headerlink" title="包含协议"></a>包含协议</h3><ul><li>UDP协议<ul><li>作用<ul><li>UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息</li></ul></li><li>UDP包<ul><li>首部（8字节）+数据（最大65527字节）<ul><li>首部长度为8个字节，主要包括源端口和目标端口</li><li>数据最大为65527个字节，整个数据包的长度最大可达到65535个字节。</li></ul></li></ul></li><li>特点<ul><li>简单，实现容易</li><li>可靠性较差，没有确认机制， 数据包一旦发出，无法知道对方是否收到</li></ul></li></ul></li><li>TCP协议<ul><li>传输控制协议</li><li>特点<ul><li>是一种面向连接的、可靠的、基于字节流的通信协议。</li><li>简单来说TCP就是有确认机制的UDP协议</li><li>每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。</li><li>TCP 实现过程复杂，消耗连接资源多，传输速度慢。</li><li>TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过IP数据包的长度，以确保单个 TCP 数据包不必再分割。</li></ul></li><li>三次握手</li></ul></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul><li>应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>HTTP协议</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图知识点总结</title>
      <link href="/uml-lei-tu-zhi-shi-dian-zong-jie.html"/>
      <url>/uml-lei-tu-zhi-shi-dian-zong-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML类图知识点总结："><a href="#UML类图知识点总结：" class="headerlink" title="UML类图知识点总结："></a>UML类图知识点总结：</h1><blockquote><p>项目初期，我们往往对业务一无所知，我们最急迫需要解决的问题就是理清楚这些业务概念以及它们的关系，如果能用好类图，你将能深入地剖析系统业务。</p></blockquote><h2 id="1-类图种类"><a href="#1-类图种类" class="headerlink" title="1.类图种类"></a>1.类图种类</h2><p>　在类图中一共包含了以下几种模型元素，分别是：<strong>类（Class）</strong>、<strong>接口（Interface）</strong>以及类之间的<strong>关系。</strong></p><h4 id="1-1-类（Class）"><a href="#1-1-类（Class）" class="headerlink" title="1.1 类（Class）"></a>1.1 类（Class）</h4><p>　在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/Class.png" alt="类"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/2016102822.png" alt="Worker类"></p><p><strong>类</strong></p><ul><li>第一行：类名称</li><li>第二行：特性（字段或者属性）</li><li>第三行：操作（方法或者行为）</li></ul><p><strong>作用域</strong></p><ul><li>“+”表示Public</li><li>“-“表示Private</li><li>“#”表示Protected</li></ul><p style="color:red;font-weight:700;">注意：若类名称为斜体字，则此类为抽象类</p>#### 1.2 接口（Interface）<p>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%A3%92%E6%A3%92%E7%B3%96.png" alt="两种接口表示法"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB.png" alt="接口种类"></p><p><strong>在UML中，接口有两种表示方法：</strong></p><ol><li>棒棒糖表示法：圆圈旁为接口名称，接口方法再实现类中出现</li><li>矩形表示法，顶端有《interface》<ul><li>第一行：接口名称</li><li>第二行：接口方法</li></ul></li></ol><h2 id="2-类图中的关系"><a href="#2-类图中的关系" class="headerlink" title="2.类图中的关系"></a>2.类图中的关系</h2><p>在UML类图中，常见的有以下几种关系: <strong>泛化</strong>（Generalization）, <strong>实现</strong>（Realization），<strong>关联</strong>（Association)，<strong>聚合</strong>（Aggregation），<strong>组合</strong>(Composition)，<strong>依赖</strong>(Dependency)</p><h4 id="2-1-泛化（Generalization）"><a href="#2-1-泛化（Generalization）" class="headerlink" title="2.1 泛化（Generalization）"></a>2.1 泛化（Generalization）</h4><p>【泛化关系】：是一种<strong>继承</strong>关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</p><p>例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</p><p>【箭头及指向】：空心三角形+实线来表示，带三角箭头的实线，<strong>箭头指向父类。</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%B3%9B%E5%8C%96.png" alt="泛化关系"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E6%B3%9B%E5%8C%962.png" alt="泛化关系"></p><h4 id="2-2-实现（Realization）"><a href="#2-2-实现（Realization）" class="headerlink" title="2.2 实现（Realization）"></a>2.2 实现（Realization）</h4><p>【实现关系】：是一种<strong>类与接口</strong>的关系，表示类是接口所有特征和行为的实现。</p><p>【箭头及指向】：实现关系用带三角箭头的虚线，<strong>箭头指向接口</strong>。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%AE%9E%E7%8E%B01.png" alt="实现关系"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%AE%9E%E7%8E%B02.png" alt="实现关系"></p><h4 id="2-3-关联（Association"><a href="#2-3-关联（Association" class="headerlink" title="2.3.关联（Association)"></a>2.3.关联（Association)</h4><p>【关联关系】：是一种<strong>拥有的</strong>关系，当一个类”知道“另一个类的属性和方法时，就可以用关联关系。</p><p>【箭头及指向】：双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头，<strong>箭头指向被拥有者。</strong></p><p><strong>单向一对一关联：</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" alt="关联关系"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E4%BB%A3%E7%A0%81%E4%BD%93%E7%8E%B0.png" alt="代码体现"></p><p><strong>双向多对多关联和单向一对多关联:</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB2.png" alt="双向关联"></p><p>👆上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。</p><p>但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><p><em>代码体现：</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">class</span> <span class="token class-name">Teacher</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span>  ICollection<span class="token operator">&lt;</span>Student<span class="token operator">></span> students<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Student</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span>  ICollection<span class="token operator">&lt;</span>Teacher<span class="token operator">></span> teachers<span class="token punctuation">;</span>        <span class="token keyword">private</span>  ICollection<span class="token operator">&lt;</span>Course<span class="token operator">></span> courses<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Course</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自身关联</strong>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%87%AA%E7%94%9F%E5%85%B3%E8%81%94.png" alt="自身关联"></p><p>自己关联自己，</p><p style="color:grey;">[有点像盗梦空间中的梦中梦，在梦中创造梦境🤔]</p><p></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">class</span> <span class="token class-name">SingleMan</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span> SingleMan singleMan<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-聚合（Aggregation）"><a href="#2-4-聚合（Aggregation）" class="headerlink" title="2.4 聚合（Aggregation）"></a>2.4 聚合（Aggregation）</h4><p>【聚合关系】表示一种弱的’拥有关系’，体现的是<strong>A对象可以包含B对象，但B对象不是A对象的一部分</strong>【DPE】</p><p>是整体与部分的关系，且部分可以离开整体而<strong>单独存在</strong>。</p><p>【箭头及指向】：带空心菱形的实心线，<strong>菱形指向整体</strong></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="聚合关系"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="代码实现"></p><p>如下图所示👇车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E8%81%9A%E5%90%88.png" alt="轮胎和汽车的聚合关系"></p><p><strong>关联与聚合的区别</strong>：</p><p>​        聚合关系是关联关系的一种，是强的关联关系；</p><p>　　在语法上是难以区分的，在语义上才能更好的区分两者的区别。关联关系所涉及的两个对象是处在<strong>同一个层次</strong>上的。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是自行车的组成部分。聚合关系涉及的两个对象处于<strong>不平等的层次</strong>上，<strong>一个代表整体，一个代表部分</strong>。比如：电脑和它的显示器、键盘、主板和内存就是聚集关系。</p><h4 id="2-5-组合-Composition"><a href="#2-5-组合-Composition" class="headerlink" title="2.5  组合(Composition)"></a>2.5  组合(Composition)</h4><p>【组合关系】：<strong>是整体与部分的关系，部分不能离开整体而单独存在，</strong>组合关系是关联关系的一种，是比聚合关系还要<strong>强</strong>的关系。</p><p>它是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样【DPE】。</p><p><strong>它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</strong></p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="组合关系"></p><p>如下图所示👇公司和部门是整体和部分的关系，没有公司就不存在部门。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E5%85%AC%E5%8F%B8%E9%83%A8%E9%97%A8.png" alt="公司和部门的组合关系"></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//部门</span>    <span class="token keyword">class</span> <span class="token class-name">Department</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//公司</span>    <span class="token keyword">class</span> <span class="token class-name">Company</span>    <span class="token punctuation">{</span>        <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Department<span class="token operator">></span> departments<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            departments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>Department<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6-依赖-Dependency"><a href="#2-6-依赖-Dependency" class="headerlink" title="2.6 依赖(Dependency)"></a>2.6 依赖(Dependency)</h4><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，</p><p style="color:red;">所以要尽量不使用双向的互相依赖，会造成系统的过度耦合，设计模式的出现就是要消除这种耦合</p>【代码表现】：**局部变量**、方法的**参数**或者对**静态方法**的调用<p>【箭头及指向】：带箭头的虚线，指向被使用者</p><p>如下图所示👇，动物的新陈代谢必须<strong>依赖</strong>于氧气和水，当依赖关系过多时，系统耦合度过高，不利于系统的维护。</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%BE%9D%E8%B5%961.png" alt="依赖关系"></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E4%BE%9D%E8%B5%962.png" alt="依赖关系代码体现"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>各种关系的强弱顺序：</strong></p><p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p><strong>要点：</strong></p><ol><li><p>软件分析与设计是编码前的两个阶段，其中分析仅与业务有关，而与技术无关。设计以分析为基础，主要与具体技术有关。</p></li><li><p>分析阶段由分析师绘制领域UML类图，设计阶段由设计师绘制实现UML类图。</p></li><li><p>领域UML类图表示系统的静态领域结构，其中的类不与最终程序中的类对应；设计UML类图表示系统的技术架构，是程序员的编码依据，其中的类与系统中的类对应。</p></li><li><p>领域UML类图中类的属性与操作仅关注与业务相关的部分，实现UML类图中的属性与操作要包括最终需要实现的全部方法与操作。</p></li></ol><p><strong>写在后面的话：编程是一门技术，更是一门艺术！</strong></p><p><strong>博客参考：</strong></p><ul><li><a href="http://www.uml.org.cn/oobject/201610282.asp" target="_blank" rel="noopener">http://www.uml.org.cn/oobject/201610282.asp</a></li><li><strong>《大话设计模式》</strong></li></ul><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://www.wukailiving.cn/yi-jian-dan-gong-han-mo-shi.html<p>如有不对的地方，欢迎指正！</p><p>来源: WK Blog作者: Wu Kai链接: </p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建模语言 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四色模型分析法</title>
      <link href="/si-se-yuan-xing-jian-mo-fa.html"/>
      <url>/si-se-yuan-xing-jian-mo-fa.html</url>
      
        <content type="html"><![CDATA[<p style="text-align:center;font:  bold 40px/80px Times New Roman,sans-serif;background-color:#FFFACD;">四色原型建模法</p>1. **moment-interval**2. **role**3. **catalog-entry-like description**4. **party, place or thing**<h2 style="font-height:50px;background-color:#00868B;color:white;">1.moment-interval archetype(瞬时间隔原型)</h2>　    这是一个很重要的原型，重要在于时间概念上：某个时刻(moment)或一段很短时间(interval)内. 意味在某个时刻发生的事情因为**业务要求或合法性**原因需要**跟踪**；或者过一段时间以后，应该是**很短**的时间，可以帮助我们寻找到它。<p>　　卖东西是在某个时刻发生的，它有发生日期和时间。租赁行为是在一段时间内发生，从开始<strong>出租和归还</strong>所租物品；预定也是持续一段时间，什么时候预定；什么时候过期等。</p><p>　　这些我们都使用<strong>moment-interval</strong>原型来表达，UML图如下：</p><p><img src="./medias/loading.gif" data-original="https://www.jdon.com/simgs/tools/moment-interval.gif" alt="img"></p><p>​        Moment-intervals是和组件模型捆绑在一起，代表了组件模块关注的核心和灵魂，在一个Model中，Moment-intervals经常封装的是<strong>最关键的方法</strong>，为让其显目，<strong>moment-interval</strong>的UML图我们使用<span style="color:#F08080">粉红颜色</span>表示。在代码上用<strong>@</strong>标识符标识：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** @archetype moment-interval*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sale</span> <span class="token punctuation">{</span>　　<span class="token keyword">public</span> BigDecimal <span class="token function">calcTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token punctuation">}</span>　　<span class="token keyword">private</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>　　<span class="token keyword">private</span> Date date<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    　在任何领域中，我们都能寻找moment-intervals原型并且开始建模，在原材料资源管理系统中，我们可以这样对待从报价单（RFQ）到购买订单（PO）直至发票，在一个制造管理系统中，我们也就可以将一个计划的过程和步骤分析到实际过程和详细步骤。</p><p>　　原型在帮助指导建模方面一个有效方式是：<strong>它能标识那些被包含在Model模型中的类（Classes）以便于区分，原型不只是简化了类的区别；原型还可以区分类的行为职责（responsibilities），例如类的属性，方法等。</strong></p><h2 style="font-height:50px;background-color:#00868B;color:white;">2.role archetype(角色原型)</h2>​        角色原型比较容易理解，**任何一个系统都需要人或某个组织介入运行**，例如论坛系统需要注册者角色发言；销售订单需要业务员角色制定，等等。<p>　　这里有一个<strong>Party原型定义</strong>：<strong>它表示一个可标识、可定位的单元</strong>，这个单元有自己正常的状态并且能够自主控制自己的一些行为，通常情况下，人或组织是一种Party，但象护照，身份证等<strong>注册性标志</strong>等都可以作为Party。</p><p>　　注意，并不是说Party或人或组织就是Role原型，必须Party或人或组织<strong>参与一种活动后才为角色</strong>，就象张三在电影中表演皇帝，他只有参与电影表演才是皇帝角色；李四在XX公司的角色才是经理，他只有参与这家公司运作才是角色经理；否则他们只是一个Party原型。</p><p>　　所以，<strong>Role角色是Party扮演的</strong>（a role that a Party plays），<strong>Party是角色Role的扮演者</strong>（role-player）。</p><p>　　当我们在建模时，对于一个角色扮演者，可以有他自己的核心属性如名称、年龄（以人为例子），也可以有与业务相关的方法，比如一个小店，当店老板去收钱时，他的角色就是收银员（cashier），此时可以将与收银员角色相关业务特点加于其上；当然，同时他也可以是老板（Owner）角色。那么下图中authorizedFor方法就是参与每个角色的行为，当他作为某个角色被授权登录后，与此角色相关的业务特点就应用在他身上。</p><p><img src="./medias/loading.gif" data-original="https://www.jdon.com/simgs/tools/roleparty.gif" alt="img"></p><p>​        大家已经注意到了：角色原型在UML中是使用<span style="color:#faf0b4;font-weight:bold">黄颜色标识</span>的。角色模型是第二重要的原型，所以使用黄色。</p><p>​    　我们已经知道，Party是一个有自主行为、能够控制自己行为的表示，如人或组织，还有其他没有自主行为的表示，也就是某个地方或位置或某个事情，我们一般称( place, or thing)，不但Party可以成为角色，而且 place或thing也可以成为角色，比如，一个商品Product可能又两种角色：在销售过程中商品；正在使用的商品。</p><h2 style="font-height:50px;background-color:#00868B;color:white;">3.party, place, or thing archetype</h2>​        上面我们说过，party place或thing都可以成为角色原型，注意到角色原型中的UML图，party图是以<span style="color:green;font-weight:bold">绿色</span>表达。<p>​    　<strong>Party表示有自己正常的状态并且能够自主控制自己的一些行为</strong>，通常情况下，人或组织是一种Party，但象护照，身份证等注册性标志等都可以作为Party。</p><p>　　Place or thing表示一样不会说话没有行为的东西，例如商品，当然这个商品可以扮演不同角色，既可以是零售的一个电源插座；也可以批发系统中的一个电源插座，它是被卖的，可能在不同业务系统被卖的方式不一样。</p><h2 style="font-height:50px;background-color:#00868B;color:white;">4.description archetype</h2>​        种类description原型其实是第三重要的原型，一般情况下，它类似目录级别catalog-entry-like的种类，例如某个商品电源插座属于家用电器这个种类，当然家用电器又属于电器这个目录，是一个树形的目录结构。例如论坛中帖子和回帖之间也是一种种类原型。<p>​        比如你的红色福克斯是福特生产的一辆轿车，它有车牌号、购买日期、颜色和里程表等，这些代表Thing原型，那么作为轿车这个种类来说，它有一些种类属性，例如：生产厂家、生产批号、适用颜色等，这些属性是轿车这类所有车辆都共有的。</p><p>　在设计模式这个实现级别，我们通常使用<a href="http://www.jdon.com/designpatterns/composite.htm" target="_blank" rel="noopener">组合模式</a>来实现种类原型。</p><p><img src="./medias/loading.gif" data-original="https://www.jdon.com/simgs/tools/description.gif" alt="img"></p><p>​    Description原型在UML中使用<span style="color:#b4c8d2;font-weight:bold">蓝色</span>表达。</p><h2 style="font-height:50px;background-color:#FFFACD;color:black;">5.四色原型图</h2>![åè²](https://www.jdon.com/simgs/tools/four.gif)<p>​    每个原型图有属性和连接（关联　依赖等关系）两个部分组成。</p><ul><li>用一句话来概括四色原型就是：一个什么什么样的人或组织或物品以某种角色在某个时刻或某段时间内参与某个活动。 其中“什么什么样的”就是DESC，“人或组织或物品”就是PPT，“角色”就是Role，而”<strong>某个时刻或某段时间内的某个活动”就</strong>是MI。</li></ul><hr><p>参考链接：</p><p><a href="https://www.jdon.com/mda/archetypes.html" target="_blank" rel="noopener">https://www.jdon.com/mda/archetypes.html</a></p><p><a href="http://www.step-10.com/notes/index.html" target="_blank" rel="noopener">http://www.step-10.com/notes/index.html</a></p><p><a href="http://www.devshed.com/c/a/Practices/Design-with-ArgoUML/6/" target="_blank" rel="noopener">http://www.devshed.com/c/a/Practices/Design-with-ArgoUML/6/</a></p><p><a href="http://www.uidesign.net/2000/papers/ObservationsOnDNC.html" target="_blank" rel="noopener">Observations on the DNC</a>(David Anderson)</p><p><a href="http://www.uidesign.net/1999/papers/UML_UI.html#no4" target="_blank" rel="noopener">Developing a UI Design from a UML Color Model</a></p><p><a href="http://www.jdon.com/mda/oo_relation.html" target="_blank" rel="noopener">面向对象建模与数据表建模两种分析设计方法的比较</a></p><p><a href="https://www.jdon.com/mda/modeling-events-through-entity-snapshotting.html" target="_blank" rel="noopener">通过实体快照实现事件建模</a></p><p><a href="http://www.jdon.com/tags/427" target="_blank" rel="noopener">四色原型专题</a></p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
          <category> DDD领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四色模型 </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二.工厂方法模式</title>
      <link href="/er-gong-han-fang-fa-mo-shi.html"/>
      <url>/er-gong-han-fang-fa-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="🚗工厂方法模式"><a href="#🚗工厂方法模式" class="headerlink" title="🚗工厂方法模式"></a>🚗工厂方法模式</h1><blockquote><p>引言：上一篇写的的是<a href="https://www.wukailiving.cn/yi-jian-dan-gong-han-mo-shi.html">简单工厂模式</a>，简单工厂模式只有三个要素(工厂、抽象产品、具体产品)，它没有<code>工厂接口</code>，并且得到产品的方法一般是静态的，所以在工厂实现的扩展性上面较差，可以当作工厂模式的简化版。在简单工厂模式中，当增加一个产品子类的时候，还需要在工厂方法的Switch分支中新增一个判断，只做到了对扩展的开放，并没有做到对修改关闭，而这点在工厂方法模式中得到了一定的克服，作为简单工厂模式的升级版，工厂方法模式更适用于复杂一点的创建方法中。</p></blockquote><h2 id="1-何为工厂方法模式❓"><a href="#1-何为工厂方法模式❓" class="headerlink" title="1.何为工厂方法模式❓"></a>1.何为工厂方法模式❓</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​        工厂方法模式（FACTORY METHOD）是一种常用的类<strong>创建型设计模式</strong>,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过<strong>依赖注入</strong>以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品 。</p><h4 id="该模式中包含的角色及其职责：🕺"><a href="#该模式中包含的角色及其职责：🕺" class="headerlink" title="该模式中包含的角色及其职责：🕺"></a>该模式中包含的角色及其职责：🕺</h4><ol><li><p><strong>抽象工厂(Creator)角色：</strong></p><p>是工厂方法模式的<strong>核心</strong>，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。</p></li><li><p><strong>具体工厂(Concrete Creator)角色：</strong></p><p>这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。在上图中有两个这样的角色：BulbCreator与TubeCreator。</p></li><li><p><strong>抽象产品(Product)角色：</strong></p><p>工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</p></li><li><p><strong>具体产品(Concrete Product)角色：</strong></p><p>这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。</p></li></ol><p style="color:red;">可以看到，对比简单工厂模式，工厂方法模式多了个抽象工厂(Creator)的角色，这也是工厂方法模式的核心。</p><h2 id="2-情景再现✨"><a href="#2-情景再现✨" class="headerlink" title="2.情景再现✨"></a>2.情景再现✨</h2><h4 id="情景："><a href="#情景：" class="headerlink" title="情景："></a>情景：</h4><p>​        <a href="https://www.wukailiving.cn/yi-jian-dan-gong-han-mo-shi.html">上一篇</a>的例子中，我们使用了简单工厂模式根据系统的不同从而创建不同的系统实例，这一次我们使用工厂方法模式实现上一篇的需求。    </p><p>上一篇的需求如下👇</p><p>说起操作系统，市面上大概可以分为三种：</p><ol><li>Windows操作系统</li><li>Linux操作系统</li><li>Mac OS操作系统，</li></ol><p>​        现在老板有个需求，根据用户使用的操作系统的不同，分别调用不同操作系统的 <code>SayHello()</code>方法，和用户打招呼。</p><h4 id="编写代码："><a href="#编写代码：" class="headerlink" title="编写代码："></a>编写代码：</h4><h5 id="工厂方法模式代码："><a href="#工厂方法模式代码：" class="headerlink" title="工厂方法模式代码："></a>工厂方法模式代码：</h5><p><em>工厂接口：任何在模式中创建的对象的工厂类必须实现这个接口</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 工厂抽象接口</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">interface</span> <span class="token class-name">IOSFactory</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 创建操作系统类</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        <span class="token comment" spellcheck="true">/// &lt;returns>&lt;/returns></span>        OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>具体工厂：实现抽象工厂接口的具体工厂类</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Windows操作系统工厂</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">WindowsOSFactory</span> <span class="token punctuation">:</span> IOSFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Mac操作系统工厂</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">MacOSFactory</span> <span class="token punctuation">:</span> IOSFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Linux操作系统工厂</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">LinuxOSFactory</span> <span class="token punctuation">:</span> IOSFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LinuxOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>抽象产品角色：工厂方法模式所创建的超类型，也就是产品对象的共同父类或者共同拥有的接口，在此例中为<code>OS</code>类</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">//包含SayHello()方法</span>    <span class="token keyword">interface</span> <span class="token class-name">ISayHelloAble</span>    <span class="token punctuation">{</span>        <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 操作系统抽象父类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">OS</span><span class="token punctuation">:</span>ISayHelloAble    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>具体产品角色：这个角色<strong>实现了</strong>抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应，此例中为不同的操作系统。</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 具体的Windows操作系统,继承抽象的OS类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">WindowsOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Windows操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 具体的Linux操作系统</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">LinuxOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Linux操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 具体的Mac操作系统</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">MacOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Mac OS操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>客户端：</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//之后可以利用反射原理优化代码</span>            IOSFactory oSFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WindowsOSFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OS concreteOS <span class="token operator">=</span> oSFactory<span class="token punctuation">.</span><span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span> greetings <span class="token operator">=</span> concreteOS<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>greetings<span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>结果</em>：</p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%B7%A5%E5%8E%82%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p>​        ❗使用工厂方法模式之后，一个简单工厂模式的工厂类，变成了<strong>一个工厂抽象接口和多个具体生成对象的工厂</strong>，如果我们要对其它的操作系统进行支持，那么我们就不需要更改原有的工厂类了</p><p>​        例如我们需要增加Netware操作系统，我们只需要增加此功能的操作系统类和对应的工厂就行了。🙂</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 具体的Netware操作系统</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">NetwareOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Netware操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Netware操作系统工厂</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">NetwareOSFactory</span> <span class="token punctuation">:</span> IOSFactory    <span class="token punctuation">{</span>        <span class="token keyword">public</span> OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NetwareOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p style="color:red;font-size:700;">但是仔细观察发现，工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现操作系统类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行，你想要增加功能，本来是改工厂类的，而现在是修改客户端！</p><p></p><p>​        那么有什么办法，让选择问题抛在客户端之外解决呢？我们可以使用“<strong>反射</strong>”。。</p><p>关于反射与工厂方法模式的结合将会在下一篇博客<strong>《抽象工厂模式》</strong>实现。</p><h2 id="3-工厂方法模式”骨架”☃"><a href="#3-工厂方法模式”骨架”☃" class="headerlink" title="3.工厂方法模式”骨架”☃"></a>3.工厂方法模式”骨架”☃</h2><h4 id="工厂方法模式UML图："><a href="#工厂方法模式UML图：" class="headerlink" title="工厂方法模式UML图："></a>工厂方法模式UML图：</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FUML.jpg" alt="工厂方法模式UML"></p><h4 id="创建步骤："><a href="#创建步骤：" class="headerlink" title="创建步骤："></a>创建步骤：</h4><p><strong>步骤1：</strong> 创建<strong>抽象工厂类</strong>，定义具体工厂的公共接口；<br><strong>步骤2：</strong> 创建<strong>抽象产品类</strong> ，定义具体产品的公共接口；<br><strong>步骤3：</strong> 创建<strong>具体产品类</strong>（继承抽象产品类） &amp; 定义生产的具体产品；<br><strong>步骤4：</strong>创建<strong>具体工厂类</strong>（继承抽象工厂类），定义创建对应具体产品实例的方法；<br><strong>步骤5：</strong>外界通过调用具体工厂类的方法，从而创建不同<strong>具体产品类的实例</strong></p><h2 id="4-优缺点及使用场景📊"><a href="#4-优缺点及使用场景📊" class="headerlink" title="4.优缺点及使用场景📊"></a>4.优缺点及使用场景📊</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点，和简单工厂模式一样，他们都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户端程序和产品对象的耦合。</li><li>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li><li>一个具体工厂只能创建一种具体产品</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>工厂方法经常用在以下两种情况中:</p><ol><li><p>第一种情况是对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来。Java Collection中的iterator() 方法即属于这种情况。</p></li><li><p>第二种情况，只是需要<strong>一种产品</strong>，而不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程这对于使用者来说是透明的。</p></li></ol><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/er-gong-han-fang-fa-mo-shi.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一.简单工厂模式</title>
      <link href="/yi-jian-dan-gong-han-mo-shi.html"/>
      <url>/yi-jian-dan-gong-han-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="🏭-简单工厂模式"><a href="#🏭-简单工厂模式" class="headerlink" title="🏭 简单工厂模式"></a>🏭 简单工厂模式</h1><blockquote><p>​        引言：设计模式1、2、3篇将会介绍三个工厂模式，分别为简单工厂模式、工厂方法模式和抽象工厂模式，三个工厂模式在实际运用中的频率也很高。</p><p>​        本篇介绍的是三个工厂模式中最基础的简单工厂模式，但是实际运用中也是最常见的，博客构造大体分为四个部分：第一部分是对设计模式的官方解释，先对我们对设计模式有一个较为正统的了解；第二部分是通过生活中的例子解释，官方的概念都是很抽象的，强行记概念对自己帮助不大，通过例子可以让我们对设计模式有一个更深的印象；第三部分是设计模式的抽象编程，是设计模式的骨架，有了前面的例子，理解这一部分并不难；最后一部分是对本篇所讲的设计模式的使用场景和优缺点总结。</p></blockquote><h2 id="1-何为简单工厂模式❓"><a href="#1-何为简单工厂模式❓" class="headerlink" title="1.何为简单工厂模式❓"></a>1.何为简单工厂模式❓</h2><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>​        简单工厂模式是属于<strong>创建型</strong>模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一<strong>。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p><h4 id="该模式中包含的角色及其职责：🕺"><a href="#该模式中包含的角色及其职责：🕺" class="headerlink" title="该模式中包含的角色及其职责：🕺"></a>该模式中包含的角色及其职责：🕺</h4><ol><li><strong>工厂（Creator）角色</strong><br>简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。<strong>工厂类</strong>的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li><strong>抽象产品（Product）角色</strong><br>简单工厂模式所创建的所有对象的<strong>父类</strong>，它负责描述所有实例所共有的<strong>公共接口。</strong></li><li><strong>具体产品（Concrete Product）角色</strong><br>是简单工厂模式的<strong>创建目标</strong>，所有创建的对象都是充当这个角色的某个具体类的实例。</li></ol><h2 id="2-情境再现✨"><a href="#2-情境再现✨" class="headerlink" title="2.情境再现✨"></a>2.情境再现✨</h2><h4 id="情景："><a href="#情景：" class="headerlink" title="情景："></a>情景：</h4><p>说起操作系统，市面上大概可以分为三种：</p><ol><li>Windows操作系统</li><li>Linux操作系统</li><li>Mac OS操作系统，</li></ol><p>​        现在老板有个需求，根据用户使用的操作系统的不同，分别调用不同操作系统的 <code>SayHello()</code>方法，和用户打招呼，需求来了就得办事，接下来秀出代码。</p><h4 id="编写代码："><a href="#编写代码：" class="headerlink" title="编写代码："></a>编写代码：</h4><h5 id="初始代码："><a href="#初始代码：" class="headerlink" title="初始代码："></a>初始代码：</h5><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"请选择你的操作系统：\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"A.Windows操作系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"B.Linux操作系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"C.Mac OS做系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span> systemType <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>systemType<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"A"</span><span class="token punctuation">:</span>                    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"你好，我是Windows操作系统，很高兴为您服务~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"B"</span><span class="token punctuation">:</span>                    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"你好，我是Linux操作系统，很高兴为您服务~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"C"</span><span class="token punctuation">:</span>                    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"你好，我是Mac OS，很高兴为您服务~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token punctuation">:</span>                    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"系统不支持，不能向您问好！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>结果：</em></p><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/1.png" alt="简单工厂结果"></p><p>​        虽然功能是实现了，但是过程式的思维却使得我们的程序只为满足当前的需求，程序<strong>不容易维护</strong>，<strong>不容易扩展，更不容易复用，</strong>从而达不到高质量代码的要求，并且业务逻辑和客户端耦合度太高</p><p>​        我们应道抛弃过程式的思维，转变为面向对象的分析设计编程思想， 开始考虑通过<strong>封装、继承、多态</strong>把程序的<strong>耦合度降低</strong>，<strong>用设计模式使得程序更加的灵活，容易修改，并且易于复用。</strong></p><h5 id="业务封装后的代码："><a href="#业务封装后的代码：" class="headerlink" title="业务封装后的代码："></a>业务封装后的代码：</h5><p><em>操作系统类</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 操作系统类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OS</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token keyword">string</span> systemType<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token keyword">string</span><span class="token punctuation">.</span>Empty<span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>systemType<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"A"</span><span class="token punctuation">:</span>                    result <span class="token operator">=</span> <span class="token string">"你好，我是Windows操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"B"</span><span class="token punctuation">:</span>                    result <span class="token operator">=</span> <span class="token string">"你好，我是Linux操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"C"</span><span class="token punctuation">:</span>                    result <span class="token operator">=</span> <span class="token string">"你好，我是Mac OS，很高兴为您服务~"</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token punctuation">:</span>                    result <span class="token operator">=</span> <span class="token string">"系统不支持，不能向您问好！"</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>客户端代码</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"请选择你的操作系统：\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"A.Windows操作系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"B.Linux操作系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"C.Mac OS做系统\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span> systemType <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> OS<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span>systemType<span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        通过这样的方式，我们将<strong>业务和界面</strong>完全分离了，如果之后又来了一个新的操作系统，比如鸿蒙🙃，只需要在OS类Switch分支上多增加一个判断就行了。</p><p>​        <strong>But…</strong>这样却违反了</p><p style="color:red">开放封闭原则</p>——<strong>软件实体应当对扩展开放，对修改关闭，</strong>当我们修改了<code>OS</code>类时，也破坏了这个类，如果<code>SayHello</code>方法很复杂，当我们修改的时候难免会出错，之后我们用🏭<strong>简单工厂模式</strong>代码。<p></p><h5 id="使用简单工厂模式："><a href="#使用简单工厂模式：" class="headerlink" title="使用简单工厂模式："></a>使用简单工厂模式：</h5><p><em>OS父类</em>：只包含抽象的逻辑方法</p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 操作系统父类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OS</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token keyword">string</span><span class="token punctuation">.</span>Empty<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>具体的操作系统类</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Windows类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">WindowsOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Windows操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Linux系统类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">LinuxOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Linux操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// Mac OS系统类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">MacOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"你好，我是Mac OS操作系统，很高兴为您服务~"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 其他系统类</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">class</span> <span class="token class-name">OtherOS</span> <span class="token punctuation">:</span> OS    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">string</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">string</span> result <span class="token operator">=</span> <span class="token string">"系统不支持，不能向您问好！"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>OSFactory工厂类</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token keyword">class</span> <span class="token class-name">OSFactory</span>    <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> OS <span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token keyword">string</span> systemType<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            OS os <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>systemType<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"A"</span><span class="token punctuation">:</span>                    os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WindowsOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"B"</span><span class="token punctuation">:</span>                    os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinuxOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"C"</span><span class="token punctuation">:</span>                    os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MacOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token punctuation">:</span>                    os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OtherOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> os<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>客户端</em></p><pre class="line-numbers language-csharp"><code class="language-csharp">            <span class="token comment" spellcheck="true">//根据字段不同‘生产不同’的OS类</span>            OS result <span class="token operator">=</span> OSFactory<span class="token punctuation">.</span><span class="token function">CreateOS</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        不管你是Windows操作系统还是Linux操作系统都可以使用这段代码实现功能，当我们要增加一个操作系统，我们只需要添加一个相应的操作系统类，并且需要在工厂类Switch分支上增加一个判断，这样我们就实现了<strong>对扩展开放</strong>，但还没有对修改关闭，这点在<strong>工厂方法模式</strong>中得到了一定的克服。</p><h2 id="3-简单工厂模式模式“骨架”☃"><a href="#3-简单工厂模式模式“骨架”☃" class="headerlink" title="3.简单工厂模式模式“骨架”☃"></a>3.简单工厂模式模式“骨架”☃</h2><h4 id="简单工厂模式UML图："><a href="#简单工厂模式UML图：" class="headerlink" title="简单工厂模式UML图："></a>简单工厂模式UML图：</h4><p><img src="./medias/loading.gif" data-original="http://blog-images-wk.test.upcdn.net/2.png" alt="简单工厂模式uml"></p><h4 id="创建步骤："><a href="#创建步骤：" class="headerlink" title="创建步骤："></a>创建步骤：</h4><ul><li>创建<strong>抽象产品类</strong> &amp; 定义具体产品的公共接口；</li><li>创建<strong>具体产品类</strong>（继承抽象产品类） &amp; 定义生产的具体产品；</li><li>创建<strong>工厂类</strong>，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；</li><li>外界通过调用工厂类的静态方法，<strong>传入不同参数</strong>从而创建不同<strong>具体产品类的实例</strong></li></ul><h2 id="4-优缺点及使用场景📊"><a href="#4-优缺点及使用场景📊" class="headerlink" title="4.优缺点及使用场景📊"></a>4.优缺点及使用场景📊</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>​        工厂类是整个模式的关键。包含了必要的逻辑判断,根据外界给定的信息，决定究竟应该创建哪个具体类的对象.通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而<strong>不必管这些对象究竟如何创建及如何组织的</strong>。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>​        由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，<strong>将全部创建逻辑集中到了一个工厂类中</strong>；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>​        当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求。这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的克服。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>工厂类负责创建的对象比较<strong>少</strong>；</li><li>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；</li><li>由于简单工厂很容易违反<a href="[https://baike.baidu.com/item/%E9%AB%98%E5%86%85%E8%81%9A/5296411?fr=aladdin](https://baike.baidu.com/item/高内聚/5296411?fr=aladdin)">高内聚</a>责任分配原则，因此一般只在很<strong>简单的情况</strong>下应用。</li></ol><p style="color:green">————————————————————————————————————————————</p>版权声明：本文为吴恺的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://www.wukailiving.cn/yi-jian-dan-gong-han-mo-shi.html<p>如有不足之处，欢迎指正！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
